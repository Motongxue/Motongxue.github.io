<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="renderer" content="webkit"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/Motongxue.png?v=2.0.0-rc.0" type="image/png" sizes="16x16"><link rel="icon" href="/assets/Motongxue.png?v=2.0.0-rc.0" type="image/png" sizes="32x32"><meta name="baidu-site-verification" content="&lt;meta name=&quot;baidu-site-verification&quot; content=&quot;7qrvxnH6OF&quot; /&gt;"><meta name="360-site-verification" content="&lt;meta name=&quot;360-site-verification&quot; content=&quot;2c4206decb5f50ba8c3c176299f061a6&quot; /&gt;"><meta name="sogou_site_verification" content="&lt;meta name=&quot;sogou_site_verification&quot; content=&quot;CHFC4tSZrs&quot;/&gt;"><meta name="description" content="@[toc]                     1 Docker 是什么？">
<meta property="og:type" content="article">
<meta property="og:title" content="技术 Docker初体验">
<meta property="og:url" content="https://www.motongxue.cn/posts/4223150074/index.html">
<meta property="og:site_name" content="Motongxue&#39;s Blog">
<meta property="og:description" content="@[toc]                     1 Docker 是什么？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200520225757479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200520225823352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200520225850737.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200520225920538.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200520230232301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFNZkxTODROdlRpYWljekpvQnlNNFRoS0sxalV1WGljR3ZSZG1ScjZhaWNvRUVCR1RzSFU5QXNvcXJ3LzY0MA?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFQZUViUHN0T3BVTXIzWUpqb2x0MndPZGN5czhNNEJkUTk2bkZ3dUwzOEhCZTkxblNlOUpwc1EvNjQw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFSeTdFVldydE9xQUhuZFUwR1Jjb1RCOWljSWN1dDJCaG1RVktER0gyMWlhYVVBU25kZ3RPTzhxUS82NDA?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVF6cUFpYmR1dDc3dEZIMzdjV0J5WjJUNlp4dVlOaWF0S3dORnN0eGphY052aWFmcTJkanU5NTRVRFEvNjQw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVF3M0hmTmJCQlVZVVhsZDVtVTZyREVXTDV3dnpvZEhyNW1uYmhDRkhxMXNLUVVQRGszdlVrZUEvNjQw?x-oss-process=image/format,png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200520230554112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFyR0tnckJpYzZSOW5hV1JqcXV2YUtJOU5LYmZmbU95d1lTQ3ZKOVhvNXkxcjFMRThFbmtNbzVnLzY0MA?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFiRFhZMUR3OUFCRHRrQWNXUDhBQkJvVnM2YjVXdkphV2ljRzNIZmNRanhtUTBCbHNLYjBRQldRLzY0MA?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFJbDk5ODNHenlTTUNoRm1idEJZQzI4TzNxWnFGQnJna1dBU2JrY2ZlSGVrZGhGWnpaemFKb3cvNjQw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFrNlV3aWI2bHMwVmljcWliS0FSbXdhRkxpYzJQRjdlYk9IR0NNWW9GUVdFUWlhM0dvZnJ3dDN2a0M3Zy82NDA?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFRVFhiQnBwd0pQcE5pY255SHljUUxqQ0ZZOEJWU0QwdWR2Rm5RTmVxTW9DSVRVU1dGR2gyTm5nLzY0MA?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFZZTRWN091VmFHdE1RMjZOeldGVjl2V0FaQnhrQ29pYVB6MkVxRW5ROUtXeUdmaEQ4SnVuNGxnLzY0MA?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFLT1hwaENDZTZYbDVMUnNpYkpxRDE2MDZWaWJXdmFNVmtKd3E5bkZOMHNxVFR1TXJTMlRZbGFOdy82NDA?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFXemU2aWFNdWVhczJEZXlmSnh1UmljWXlzSGphTnk4MVpQb2REaWJrYXlBWUV4bW1rMWE5QzhRZmcvNjQw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFqRlRRb1IyTkpoaWJ6QlRhS0FtNHlCeUx6anhkNUNydFNPd3R5SHlIdlZpYjN2NzQzYWp2R05TQS82NDA?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVEyWnNpY1Z1aWF1Qk82V2dsNHpSMEEyR1JUSzU4Y1ZFNjRNcURSNjMyakpEc2tqVlNHZTl2ZnZOUS82NDA?x-oss-process=image/format,png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200520224847506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200520224841377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200520224750301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200520224729202.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200520225704275.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200520224702972.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200520224638400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/202005202246215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200520224511871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2020-05-20T15:39:19.522Z">
<meta property="article:modified_time" content="2020-05-20T15:42:41.914Z">
<meta property="article:author" content="Motongxue">
<meta property="article:tag" content="Docker">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200520225757479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70"><meta name="keywords" content="Motongxue, Motongxue's Blog"><meta name="description" content=""><title>技术 Docker初体验 | Motongxue's Blog</title><link ref="canonical" href="https://www.motongxue.cn/posts/4223150074/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.0-rc.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/MyTech/"><span class="header-nav-menu-item__icon"><i class="fas fa-feather-alt"></i></span><span class="header-nav-menu-item__text">技术</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/MyLife/"><span class="header-nav-menu-item__icon"><i class="fas fa-book"></i></span><span class="header-nav-menu-item__text">生活</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">文章</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/archives/"><span class="header-nav-submenu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-submenu-item__text">归档</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/tags/"><span class="header-nav-submenu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-submenu-item__text">标签</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-angle-double-down"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Motongxue's Blog</div><div class="header-banner-info__subtitle"></div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">技术 Docker初体验</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-05-20</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-05-20</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">10.3k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">63分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body"><p>@[toc]</p>

        <h2 id="1-Docker-是什么？"   >
          <a href="#1-Docker-是什么？" class="heading-link"><i class="fas fa-link"></i></a>1 Docker 是什么？</h2>
      <a id="more"></a>
<p>说了这么多， Docker 到底是个什么东西呢？<br>我们在理解 Docker 之前，首先得先区分清楚两个概念，容器和虚拟机。<br>可能很多读者朋友都用过虚拟机，而对容器这个概念比较的陌生。我们用的传统虚拟机如 VMware ， VisualBox 之类的需要模拟整台机器包括硬件。<br>每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。<br>每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。<br>而容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。<br>容器包含应用和其所有的依赖包，但是与其他容器共享内核。<br>容器在宿主机操作系统中，在用户空间以分离的进程运行。<br>容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。<br>通过使用容器，我们可以轻松打包应用程序的代码、配置和依赖关系，将其变成容易使用的构建块，从而实现环境一致性、运营效率、开发人员生产力和版本控制等诸多目标。<br>容器可以帮助保证应用程序快速、可靠、一致地部署，其间不受部署环境的影响。<br>容器还赋予我们对资源更多的精细化控制能力，让我们的基础设施效率更高。</p>
<p>通过下面这幅图，我们可以很直观的反映出这两者的区别所在：<br>
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/20200520225757479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70"  style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbwpx;"  alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zvq29HPU-1589985834510)(en-resource://database/4423:1)\]">
      </p>
<p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。<br>而 Linux 容器是 Linux 发展出的另一种虚拟化技术，简单来讲， Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离，相当于是在正常进程的外面套了一个保护层。<br>对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。<br>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。<br>程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。<br><strong>总体来说</strong> ，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>

        <h2 id="2-Docker-的优势"   >
          <a href="#2-Docker-的优势" class="heading-link"><i class="fas fa-link"></i></a>2 Docker 的优势</h2>
      <p>Docker 相比于传统虚拟化方式具有更多的优势：</p>
<ul>
<li><strong>Docker 启动快速属于秒级别。</strong> 虚拟机通常需要几分钟去启动。</li>
<li><strong>Docker 需要的资源更少。</strong> Docker 在操作系统级别进行虚拟化，Docker 容器和内核交互，几乎没有性能损耗，性能优于通过 Hypervisor 层与内核层的虚拟化。</li>
<li><strong>Docker 更轻量。</strong> Docker 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境，Docker 运行的镜像数远多于虚拟机数量，对系统的利用率非常高。</li>
<li><strong>与虚拟机相比，Docker 隔离性更弱。</strong> Docker 属于进程之间的隔离，虚拟机可实现系统级别隔离。</li>
<li><strong>安全性。</strong> Docker 的安全性也更弱，Docker 的租户 Root 和宿主机 Root 等同，一旦容器内的用户从普通用户权限提升为 Root 权限，它就直接具备了宿主机的 Root 权限，进而可进行无限制的操作。虚拟机租户 Root 权限和宿主机的 Root 虚拟机权限是分离的，并且虚拟机利用如 Intel 的 VT-d 和 VT-x 的 ring-1 硬件隔离技术。这种隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击。</li>
<li><strong>可管理性。</strong> Docker 的集中化管理工具还不算成熟。各种虚拟化技术都有成熟的管理工具，例如 VMware vCenter 提供完备的虚拟机管理能力。</li>
<li><strong>高可用和可恢复性。</strong> Docker 对业务的高可用支持是通过快速重新部署实现的。虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制， VMware 可承诺虚拟机 99.999% 高可用，保证业务连续性。</li>
<li><strong>快速创建、删除。</strong> 虚拟化创建是分钟级别的，Docker 容器创建是秒级别的，Docker 的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间</li>
<li><strong>交付、部署。</strong> 虚拟机可以通过镜像实现环境交付的一致性，但镜像分发无法体系化。Docker 在 Dockerfile 中记录了容器构建过程，可在集群中实现快速分发和快速部署。</li>
</ul>
<p>我们可以从下面这张表格很清楚地看到容器相比于传统虚拟机的特性的优势所在：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘使用</td>
<td>一般为MB</td>
<td>一般为GB</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般是几十个</td>
</tr>
</tbody></table></div>

        <h2 id="3-Docker-的三个基本概念"   >
          <a href="#3-Docker-的三个基本概念" class="heading-link"><i class="fas fa-link"></i></a>3 Docker 的三个基本概念</h2>
      <p> 
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/20200520225823352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70"  style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbwpx;"  alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oKDSz5xr-1589985834512)(en-resource://database/4425:1)\]">
      </p>
<p>从上图我们可以看到，Docker 中包括三个基本的概念：</p>
<ul>
<li>Image（镜像）</li>
<li>Container（容器）</li>
<li>Repository（仓库）</li>
</ul>
<p>镜像是 Docker 运行容器的前提，仓库是存放镜像的场所，可见镜像更是 Docker 的核心。</p>

        <h3 id="Image（镜像）"   >
          <a href="#Image（镜像）" class="heading-link"><i class="fas fa-link"></i></a>Image（镜像）</h3>
      <p>那么镜像到底是什么呢？Docker 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。<br>镜像不包含任何动态数据，其内容在构建之后也不会被改变。镜像（Image）就是一堆只读层（read-only layer）的统一视角，也许这个定义有些难以理解，下面的这张图能够帮助读者理解镜像的定义：<br>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/20200520225850737.png"  alt="">
      </p>
<p>从左边我们看到了多个只读层，它们重叠在一起。除了最下面一层，其他层都会有一个指针指向下一层。这些层是 Docker 内部的实现细节，并且能够在主机的文件系统上访问到。<br>统一文件系统（Union File System）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角。<br>这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。我们可以在图片的右边看到这个视角的形式。</p>

        <h3 id="Container（容器）"   >
          <a href="#Container（容器）" class="heading-link"><i class="fas fa-link"></i></a>Container（容器）</h3>
      <p>容器（Container）的定义和镜像（Image）几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。<br>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/20200520225920538.png"  alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Xv9Onl0v-1589985834518)(en-resource://database/4429:1)\]">
      </p>
<p>由于容器的定义并没有提及是否要运行容器，所以实际上，容器 = 镜像 + 读写层。</p>

        <h3 id="Repository（仓库）"   >
          <a href="#Repository（仓库）" class="heading-link"><i class="fas fa-link"></i></a>Repository（仓库）</h3>
      <p>Docker 仓库是集中存放镜像文件的场所。镜像构建完成后，可以很容易的在当前宿主上运行。<br>但是， 如果需要在其他服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry（仓库注册服务器）就是这样的服务。<br>有时候会把仓库（Repository）和仓库注册服务器（Registry）混为一谈，并不严格区分。<br>Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。<br>实际上，一个 Docker Registry 中可以包含多个仓库（Repository），每个仓库可以包含多个标签（Tag），每个标签对应着一个镜像。<br>所以说，镜像仓库是 Docker 用来集中存放镜像文件的地方，类似于我们之前常用的代码仓库。<br>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。<br>我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 Latest 作为默认标签。<br>仓库又可以分为两种形式：</p>
<ul>
<li>Public（公有仓库）</li>
<li>Private（私有仓库）</li>
</ul>
<p>Docker Registry 公有仓库是开放给用户使用、允许用户管理镜像的 Registry 服务。</p>
<p>一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。</p>
<p>当用户创建了自己的镜像之后就可以使用 Push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 Pull 下来就可以了。<br>我们主要把 Docker 的一些常见概念如 Image，Container，Repository 做了详细的阐述，也从传统虚拟化方式的角度阐述了 Docker 的优势。<br>我们从下图可以直观地看到 Docker 的架构：<br>
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/20200520230232301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70"  style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbwpx;"  alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7Hfb1fyX-1589985834520)(en-resource://database/4431:1)\]">
      </p>
<p>Docker 使用 C/S 结构，即客户端/服务器体系结构。Docker 客户端与 Docker 服务器进行交互，Docker服务端负责构建、运行和分发 Docker 镜像。<br>Docker 客户端和服务端可以运行在一台机器上，也可以通过 RESTful 、 Stock 或网络接口与远程 Docker 服务端进行通信。<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CBeE5fqf-1589985834522)(en-resource://database/4433:1)]</p>
<p>这张图展示了 Docker 客户端、服务端和 Docker 仓库（即 Docker Hub 和 Docker Cloud ），默认情况下 Docker 会在 Docker 中央仓库寻找镜像文件。<br>这种利用仓库管理镜像的设计理念类似于 Git ，当然这个仓库是可以通过修改配置来指定的，甚至我们可以创建我们自己的私有仓库。</p>

        <h2 id="4-Docker-的安装和使用"   >
          <a href="#4-Docker-的安装和使用" class="heading-link"><i class="fas fa-link"></i></a>4 Docker 的安装和使用</h2>
      <p>Docker 的安装和使用有一些前提条件，主要体现在体系架构和内核的支持上。对于体系架构，除了 Docker 一开始就支持的 X86-64 ，其他体系架构的支持则一直在不断地完善和推进中。<br>Docker 分为 CE 和 EE 两大版本。CE 即社区版，免费支持周期 7 个月；EE 即企业版，强调安全，付费使用，支持周期 24 个月。<br>我们在安装前可以参看官方文档获取最新的 Docker 支持情况，官方文档在这里：<span class="exturl"><a class="exturl__link"   href="https://docs.docker.com/install/。"  target="_blank" rel="noopener">https://docs.docker.com/install/。</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>Docker 对于内核支持的功能，即内核的配置选项也有一定的要求（比如必须开启 Cgroup 和 Namespace 相关选项，以及其他的网络和存储驱动等）。<br>Docker 源码中提供了一个检测脚本来检测和指导内核的配置，脚本链接在这里：<br><span class="exturl"><a class="exturl__link"   href="https://raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh。"  target="_blank" rel="noopener">https://raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh。</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>在满足前提条件后，安装就变得非常的简单了。<br>Docker CE 的安装请参考官方文档：MacOS：</p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   href="https://docs.docker.com/docker-for-mac/install/Windows：https://docs.docker.com/docker-for-windows/install/Ubuntu：https://docs.docker.com/install/linux/docker-ce/ubuntu/Debian：https://docs.docker.com/install/linux/docker-ce/debian/CentOS：https://docs.docker.com/install/linux/docker-ce/centos/Fedora：https://docs.docker.com/install/linux/docker-ce/fedora/其他"  target="_blank" rel="noopener">https://docs.docker.com/docker-for-mac/install/Windows：https://docs.docker.com/docker-for-windows/install/Ubuntu：https://docs.docker.com/install/linux/docker-ce/ubuntu/Debian：https://docs.docker.com/install/linux/docker-ce/debian/CentOS：https://docs.docker.com/install/linux/docker-ce/centos/Fedora：https://docs.docker.com/install/linux/docker-ce/fedora/其他</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> Linux 发行版：<span class="exturl"><a class="exturl__link"   href="https://docs.docker.com/install/linux/docker-ce/binaries/"  target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/binaries/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>这里我们以 CentOS 7 作为演示。</p>

        <h3 id="环境准备："   >
          <a href="#环境准备：" class="heading-link"><i class="fas fa-link"></i></a>环境准备：</h3>
      <ul>
<li>阿里云服务器（1 核 2G，1M 带宽）</li>
<li>CentOS 7.4 64 位<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、yum 包更新到最新 </span></span><br><span class="line">yum update</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 </span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、 设置yum源</span></span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、 安装docker，出现输入的界面都按 y </span></span><br><span class="line">yum install -y docker-ce</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5、 查看docker版本，验证是否验证成功</span></span><br><span class="line">docker -v</span><br></pre></td></tr></table></div></figure>

</li>
</ul>

        <h3 id="安装-Docker"   >
          <a href="#安装-Docker" class="heading-link"><i class="fas fa-link"></i></a>安装 Docker</h3>
      <p>Docker 软件包已经包括在默认的 CentOS-Extras 软件源里。因此想要安装 Docker，只需要运行下面的 yum 命令：<br>$ sudo yum install docker<br>当然在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装：<br>curl -fsSL get.docker.com -o get-docker.shsh get-docker.sh<br>具体可以参看 docker-install 的脚本：<span class="exturl"><a class="exturl__link"   href="https://github.com/docker/docker-install。"  target="_blank" rel="noopener">https://github.com/docker/docker-install。</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中。<br>安装完成后，运行下面的命令，验证是否安装成功：docker versionordocker info<br>返回 Docker 的版本相关信息，证明 Docker 安装成功：<br>&nbsp;
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFNZkxTODROdlRpYWljekpvQnlNNFRoS0sxalV1WGljR3ZSZG1ScjZhaWNvRUVCR1RzSFU5QXNvcXJ3LzY0MA?x-oss-process=image/format,png"  style=""  alt=".png">
      </p>
<p>启动 Docker-CE：</p>
<blockquote>
<p>$ sudo systemctl enable docker$ sudo systemctl start docker</p>
</blockquote>

        <h3 id="Docker-的简单运用-Hello-World"   >
          <a href="#Docker-的简单运用-Hello-World" class="heading-link"><i class="fas fa-link"></i></a>Docker 的简单运用 Hello World</h3>
      <p>由于服务器日常崩溃了， Docker 出了点问题，所以以下案例的演示是基于 Kali Linux 环境下进行的。<br>我们通过最简单的 Image 文件 Hello World，感受一下 Docker 的魅力吧！<br>我们直接运行下面的命令，将名为 hello-world 的 image 文件从仓库抓取到本地：</p>
<blockquote>
<p>docker pull library/hello-world</p>
</blockquote>
<p>docker pull images 是抓取 image 文件，library/hello-world 是 image 文件在仓库里面的位置，其中 library 是 image 文件所在的组，hello-world 是 image 文件的名字。<br>&nbsp;
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFQZUViUHN0T3BVTXIzWUpqb2x0MndPZGN5czhNNEJkUTk2bkZ3dUwzOEhCZTkxblNlOUpwc1EvNjQw?x-oss-process=image/format,png"  style=""  alt=".png">
      <br>抓取成功以后，就可以在本机看到这个 image 文件了：</p>
<blockquote>
<p>docker images</p>
</blockquote>
<p>我们可以看到如下结果：&nbsp;
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFSeTdFVldydE9xQUhuZFUwR1Jjb1RCOWljSWN1dDJCaG1RVktER0gyMWlhYVVBU25kZ3RPTzhxUS82NDA?x-oss-process=image/format,png"  style=""  alt=".png">
      <br>现在，我们可以运行 hello-world 这个 image 文件：docker run hello-world我们可以看到如下结果：&nbsp;
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVF6cUFpYmR1dDc3dEZIMzdjV0J5WjJUNlp4dVlOaWF0S3dORnN0eGphY052aWFmcTJkanU5NTRVRFEvNjQw?x-oss-process=image/format,png"  style=""  alt=".png">
      </p>
<p>输出这段提示以后，hello world 就会停止运行，容器自动终止。有些容器不会自动终止，因为提供的是服务，比如 MySQL 镜像等。<br>是不是很 Easy 呢？我们从上面可以看出，Docker 的功能是十分强大的，除此之外，我们还可以拉取一些 Ubuntu，Apache 等镜像，在未来的教程中我们将会一一提到。<br>Docker 提供了一套简单实用的命令来创建和更新镜像，我们可以通过网络直接下载一个已经创建好了的应用镜像，并通过 Docker RUN 命令就可以直接使用。<br>当镜像通过 RUN 命令运行成功后，这个运行的镜像就是一个 Docker 容器啦。<br>容器可以理解为一个轻量级的沙箱，Docker 利用容器来运行和隔离应用，容器是可以被启动、停止、删除的，这并不会影响 Docker 镜像。</p>
<p>我们可以看看下面这幅图：&nbsp;
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVF3M0hmTmJCQlVZVVhsZDVtVTZyREVXTDV3dnpvZEhyNW1uYmhDRkhxMXNLUVVQRGszdlVrZUEvNjQw?x-oss-process=image/format,png"  style=""  alt=".png">
      <br>Docker 客户端是 Docker 用户与 Docker 交互的主要方式。当您使用 Docker 命令行运行命令时，Docker 客户端将这些命令发送给服务器端，服务端将执行这些命令。<br>Docker 命令使用 Docker API 。Docker 客户端可以与多个服务端进行通信。</p>
<p>我们将剖析一下 Docker 容器是如何工作的，学习好 Docker 容器工作的原理，我们就可以自己去管理我们的容器了。</p>

        <h2 id="5-Docker-架构"   >
          <a href="#5-Docker-架构" class="heading-link"><i class="fas fa-link"></i></a>5 Docker 架构</h2>
      <p>在上面的学习中，我们简单地讲解了 Docker 的基本架构。了解到了 Docker 使用的是 C/S 结构，即客户端/服务器体系结构。<br>明白了 Docker 客户端与 Docker 服务器进行交互时，Docker 服务端负责构建、运行和分发 Docker 镜像。<br>知道了 Docker 客户端和服务端可以运行在一台机器上，我们可以通过 RESTful、Stock 或网络接口与远程 Docker 服务端进行通信。</p>
<p>我们从下图可以很直观的了解到 Docker 的架构：<br>
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/20200520230554112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70"  style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbwpx;"  alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZIbpYMxU-1589985834530)(en-resource://database/4435:1)\]">
      </p>
<p>Docker 的核心组件包括：</p>
<ul>
<li>Docker Client</li>
<li>Docker Daemon</li>
<li>Docker Image</li>
<li>Docker Registry</li>
<li>Docker Container</li>
</ul>
<p>Docker 采用的是 Client/Server 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。<br>客户端和服务器可以运行在同一个 Host 上，客户端也可以通过 Socket 或 REST API 与远程的服务器通信。</p>

        <h3 id="Docker-Client"   >
          <a href="#Docker-Client" class="heading-link"><i class="fas fa-link"></i></a>Docker Client</h3>
      <p>Docker Client ，也称 Docker 客户端。它其实就是 Docker 提供命令行界面（CLI）工具，是许多 Docker 用户与 Docker 进行交互的主要方式。<br>客户端可以构建，运行和停止应用程序，还可以远程与 Docker_Host 进行交互。<br>最常用的 Docker 客户端就是 Docker 命令，我们可以通过 Docker 命令很方便地在 Host 上构建和运行 Docker 容器。&nbsp;
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFyR0tnckJpYzZSOW5hV1JqcXV2YUtJOU5LYmZmbU95d1lTQ3ZKOVhvNXkxcjFMRThFbmtNbzVnLzY0MA?x-oss-process=image/format,png"  style=""  alt=".png">
      </p>

        <h3 id="Docker-Daemon"   >
          <a href="#Docker-Daemon" class="heading-link"><i class="fas fa-link"></i></a>Docker Daemon</h3>
      <p>Docker Daemon 是服务器组件，以 Linux 后台服务的方式运行，是 Docker 最核心的后台进程，我们也把它称为守护进程。<br>它负责响应来自 Docker Client 的请求，然后将这些请求翻译成系统调用完成容器管理操作。<br>该进程会在后台启动一个 API Server ，负责接收由 Docker Client 发送的请求，接收到的请求将通过 Docker Daemon 内部的一个路由分发调度，由具体的函数来执行请求。&nbsp;
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFiRFhZMUR3OUFCRHRrQWNXUDhBQkJvVnM2YjVXdkphV2ljRzNIZmNRanhtUTBCbHNLYjBRQldRLzY0MA?x-oss-process=image/format,png"  style=""  alt=".png">
      <br>我们大致可以将其分为以下三部分：</p>
<ul>
<li>Docker Server</li>
<li>Engine</li>
<li>Job</li>
</ul>
<p>Docker Daemon 的架构如下所示：<br>&nbsp;
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFJbDk5ODNHenlTTUNoRm1idEJZQzI4TzNxWnFGQnJna1dBU2JrY2ZlSGVrZGhGWnpaemFKb3cvNjQw?x-oss-process=image/format,png"  style=""  alt=".png">
      <br>Docker Daemon 可以认为是通过 Docker Server 模块接受 Docker Client 的请求，并在 Engine 中处理请求，然后根据请求类型，创建出指定的 Job 并运行。<br>Docker Daemon 运行在 Docker Host 上，负责创建、运行、监控容器，构建、存储镜像。<br>运行过程的作用有以下几种可能：</p>
<ul>
<li>向 Docker Registry 获取镜像。</li>
<li>通过 GraphDriver 执行容器镜像的本地化操作。</li>
<li>通过 NetworkDriver 执行容器网络环境的配置。</li>
<li>通过 ExecDriver 执行容器内部运行的执行工作。</li>
</ul>
<p>由于 Docker Daemon 和 Docker Client 的启动都是通过可执行文件 Docker 来完成的，因此两者的启动流程非常相似。<br>Docker 可执行文件运行时，运行代码通过不同的命令行 Flag 参数，区分两者，并最终运行两者各自相应的部分。<br>启动 Docker Daemon 时，一般可以使用以下命令来完成：</p>
<blockquote>
<p>docker –daemon = truedocker –ddocker –d = true</p>
</blockquote>
<p>再由 Docker 的 main() 函数来解析以上命令的相应 Flag 参数，并最终完成 Docker Daemon 的启动。<br>下图可以很直观地看到 Docker Daemon 的启动流程：&nbsp;
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFrNlV3aWI2bHMwVmljcWliS0FSbXdhRkxpYzJQRjdlYk9IR0NNWW9GUVdFUWlhM0dvZnJ3dDN2a0M3Zy82NDA?x-oss-process=image/format,png"  style=""  alt=".png">
      <br>默认配置下，Docker Daemon 只能响应来自本地 Host 的客户端请求。如果要允许远程客户端请求，需要在配置文件中打开 TCP 监听。<br>我们可以照着如下步骤进行配置：</p>
<ol>
<li>编辑配置文件/etc/systemd/system/multi-user.target.wants/docker.service，在环境变量 ExecStart 后面添加 -H tcp://0.0.0.0，允许来自任意 IP 的客户端连接。&nbsp;
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFRVFhiQnBwd0pQcE5pY255SHljUUxqQ0ZZOEJWU0QwdWR2Rm5RTmVxTW9DSVRVU1dGR2gyTm5nLzY0MA?x-oss-process=image/format,png"  style=""  alt=".png">
      </li>
<li>重启 Docker Daemon：<blockquote>
<p>systemctl daemon-reloadsystemctl restart docker.service</p>
</blockquote>
</li>
<li>我们通过以下命令即可实现与远程服务器通信：<blockquote>
<p>docker -H 服务器IP地址 info</p>
</blockquote>
 -H 是用来指定服务器主机，info 子命令用于查看 Docker 服务器的信息。</li>
</ol>

        <h3 id="Docker-Image"   >
          <a href="#Docker-Image" class="heading-link"><i class="fas fa-link"></i></a>Docker Image</h3>
      <p>Docker 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。<br>镜像不包含任何动态数据，其内容在构建之后也不会被改变。我们可将 Docker 镜像看成只读模板，通过它可以创建 Docker 容器。<br>镜像有多种生成方法：</p>
<ul>
<li>从无到有开始创建镜像</li>
<li>下载并使用别人创建好的现成的镜像</li>
<li>在现有镜像上创建新的镜像</li>
</ul>
<p>我们可以将镜像的内容和创建步骤描述在一个文本文件中，这个文件被称作 Dockerfile ，通过执行 docker build命令可以构建出 Docker 镜像。</p>

        <h3 id="Docker-Registry"   >
          <a href="#Docker-Registry" class="heading-link"><i class="fas fa-link"></i></a>Docker Registry</h3>
      <p>Docker Registry 是存储 Docker Image 的仓库，它在 Docker 生态环境中的位置如下图所示：&nbsp;
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFZZTRWN091VmFHdE1RMjZOeldGVjl2V0FaQnhrQ29pYVB6MkVxRW5ROUtXeUdmaEQ4SnVuNGxnLzY0MA?x-oss-process=image/format,png"  style=""  alt=".png">
      <br>运行 docker push、docker pull、docker search 时，实际上是通过 Docker Daemon 与 Docker Registry 通信。</p>

        <h3 id="Docker-Container"   >
          <a href="#Docker-Container" class="heading-link"><i class="fas fa-link"></i></a>Docker Container</h3>
      <p>Docker 容器就是 Docker 镜像的运行实例，是真正运行项目程序、消耗系统资源、提供服务的地方。</p>
<p>Docker Container 提供了系统硬件环境，我们可以使用 Docker Images 这些制作好的系统盘，再加上我们所编写好的项目代码，Run 一下就可以提供服务啦。</p>

        <h2 id="6-Docker-组件是如何协作运行容器"   >
          <a href="#6-Docker-组件是如何协作运行容器" class="heading-link"><i class="fas fa-link"></i></a>6 Docker 组件是如何协作运行容器</h2>
      <p>看到这里，我相信各位读者朋友们应该已经对 Docker 基础架构熟悉的差不多了，我们还记得运行的第一个容器吗？<br>现在我们再通过 hello-world 这个例子来体会一下 Docker 各个组件是如何协作的。<br>容器启动过程如下：</p>
<ul>
<li>Docker 客户端执行 docker run 命令。</li>
<li>Docker Daemon 发现本地没有 hello-world 镜像。</li>
<li>Daemon 从 Docker Hub 下载镜像。</li>
<li>下载完成，镜像 hello-world 被保存到本地。</li>
<li>Docker Daemon 启动容器。</li>
</ul>
<p>具体过程可以看如下这幅演示图：&nbsp;
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFLT1hwaENDZTZYbDVMUnNpYkpxRDE2MDZWaWJXdmFNVmtKd3E5bkZOMHNxVFR1TXJTMlRZbGFOdy82NDA?x-oss-process=image/format,png"  style=""  alt=".png">
      <br>我们可以通过 Docker Images 可以查看到 hello-world 已经下载到本地：&nbsp;
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFXemU2aWFNdWVhczJEZXlmSnh1UmljWXlzSGphTnk4MVpQb2REaWJrYXlBWUV4bW1rMWE5QzhRZmcvNjQw?x-oss-process=image/format,png"  style=""  alt=".png">
      <br>我们可以通过 Docker Ps 或者 Docker Container ls 显示正在运行的容器，我们可以看到，hello-world 在输出提示信息以后就会停止运行，容器自动终止，所以我们在查看的时候没有发现有容器在运行。&nbsp;
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVFqRlRRb1IyTkpoaWJ6QlRhS0FtNHlCeUx6anhkNUNydFNPd3R5SHlIdlZpYjN2NzQzYWp2R05TQS82NDA?x-oss-process=image/format,png"  style=""  alt=".png">
      <br>我们把 Docker 容器的工作流程剖析的十分清楚了，<strong>我们大体可以知道 Docker 组件协作运行容器可以分为以下几个过程：</strong> </p>
<ul>
<li>Docker 客户端执行 docker run 命令。</li>
<li>Docker Daemon 发现本地没有我们需要的镜像。</li>
<li>Daemon 从 Docker Hub 下载镜像。</li>
<li>下载完成后，镜像被保存到本地。</li>
<li>Docker Daemon 启动容器。</li>
</ul>
<p>了解了这些过程以后，我们再来理解这些命令就不会觉得很突兀了，下面我来给大家讲讲 Docker 常用的一些命令操作吧。</p>

        <h2 id="7-Docker-常用命令"   >
          <a href="#7-Docker-常用命令" class="heading-link"><i class="fas fa-link"></i></a>7 Docker 常用命令</h2>
      <p>我们可以通过 docker -h 去查看命令的详细的帮助文档。在这里我只会讲一些日常我们可能会用的比较多的一些命令。&nbsp;
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9BMUhLVlhzZkhOa1pVc05FdnVRcFNrNzFzV2ppYU1YZVEyWnNpY1Z1aWF1Qk82V2dsNHpSMEEyR1JUSzU4Y1ZFNjRNcURSNjMyakpEc2tqVlNHZTl2ZnZOUS82NDA?x-oss-process=image/format,png"  style=""  alt=".png">
      <br><strong>Docker进程相关命令</strong></p>
<ul>
<li>启动docker服务:<br>systemctl start docker<ul>
<li>停止docker服务:<br>systemctl stop docker</li>
</ul>
</li>
<li>重启docker服务:<br>systemctl restart docker</li>
<li>查看docker服务状态:<br>systemctl status docker</li>
<li>设置开机启动docker服务:<br>systemctl enable docker</li>
</ul>
<p><strong>Docker 镜像相关命令</strong></p>
<ul>
<li>查看镜像: 查看本地所有的镜像<blockquote>
<p>docker images<br>docker images –q #  查看所用镜像的id</p>
</blockquote>
<ul>
<li>搜索镜像:从网络中查找需要的镜像<blockquote>
<p>docker search  镜像名称</p>
</blockquote>
</li>
<li>拉取镜像:从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本。<br>如果不知道镜像版本，可以去docker hub 搜索对应镜像查看。<blockquote>
<p>docker pull  镜像名称</p>
</blockquote>
</li>
<li>删除镜像: 删除本地镜像<blockquote>
<p>docker rmi  镜像id #  删除指定本地镜像<br>docker rmi <code>docker images -q</code> #  删除所有本地镜像</p>
</blockquote>
</li>
</ul>
<strong>Docker容器相关命令</strong></li>
<li>查看容器<blockquote>
<p>docker ps #  查看正在运行的容器<br>docker ps –a #  查看所有容器</p>
</blockquote>
<ul>
<li>创建并启动容器<blockquote>
<p>docker run  参数</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>参数说明：</strong><br>• -i：保持容器运行。通常与 -t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。<br>• -t：为容器重新分配一个伪输入终端，通常与 -i 同时使用。<br>• -d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出后，容器不会关闭。<br>• -it 创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器<br>• –name：为创建的容器命名。</p>
<ul>
<li>进入容器<blockquote>
<p>docker exec 数 参数 #  退出容器，容器不会关闭</p>
</blockquote>
</li>
<li>停止容器<blockquote>
<p>docker stop  容器名称</p>
</blockquote>
</li>
<li>启动容器<blockquote>
<p>docker start  容器名称</p>
</blockquote>
</li>
<li>删除容器：如果容器是运行状态则删除失败，需要停止容器才能删除<blockquote>
<p>docker rm  容器名称</p>
</blockquote>
</li>
<li>查看容器信息<blockquote>
<p>docker inspect </p>
</blockquote>
</li>
</ul>
<hr>
<hr>
<p>例如，我们需要拉取一个 Docker 镜像，我们可以用如下命令：</p>
<blockquote>
<p>docker pull</p>
</blockquote>
<p>image_nameimage_name 为镜像的名称，而如果我们想从 Docker Hub 上去下载某个镜像，我们可以使用以下命令：</p>
<blockquote>
<p>docker pull centos:latest</p>
</blockquote>
<p>cento：lastest 是镜像的名称，Docker Daemon 发现本地没有我们需要的镜像，会自动去 Docker Hub 上去下载镜像，下载完成后，该镜像被默认保存到 /var/lib/docker 目录下。<br>接着我们如果想查看主机下存在多少镜像，我们可以用如下命令：</p>
<blockquote>
<p>docker images</p>
</blockquote>
<p>我们要想知道当前有哪些容器在运行，我们可以用如下命令：</p>
<blockquote>
<p>docker ps -a</p>
</blockquote>
<p>-a 是查看当前所有的容器，包括未运行的。我们该如何去对一个容器进行启动，重启和停止呢？<br>我们可以用如下命令：</p>
<blockquote>
<p>docker start container_name/container_id<br>docker restart container_name/container_id<br>docker stop container_name/container_id</p>
</blockquote>
<p>这个时候我们如果想进入到这个容器中，我们可以使用 attach 命令：</p>
<blockquote>
<p>docker attach container_name/container_id</p>
</blockquote>
<p>那如果我们想运行这个容器中的镜像的话，并且调用镜像里面的 bash ，我们可以使用如下命令：</p>
<blockquote>
<p>docker run -t -i container_name/container_id /bin/bash</p>
</blockquote>
<p>那如果这个时候，我们想删除指定镜像的话，由于 Image 被某个 Container 引用（拿来运行），如果不将这个引用的 Container 销毁（删除），那 Image 肯定是不能被删除。<br>我们首先得先去停止这个容器：</p>
<blockquote>
<p>docker ps<br>docker stop container_name/container_id</p>
</blockquote>
<p>然后我们用如下命令去删除这个容器：</p>
<blockquote>
<p>docker rm container_name/container_id</p>
</blockquote>
<p>然后这个时候我们再去删除这个镜像：</p>
<blockquote>
<p>docker rmi image_name</p>
</blockquote>
<p>此时，常用的 Docker 相关的命令就讲到这里为止了，我们在后续的文章中还会反复地提到这些命令。</p>

        <h2 id="Docker容器的数据卷"   >
          <a href="#Docker容器的数据卷" class="heading-link"><i class="fas fa-link"></i></a>Docker容器的数据卷</h2>
      
        <h3 id="概念"   >
          <a href="#概念" class="heading-link"><i class="fas fa-link"></i></a>概念</h3>
      <ul>
<li>数据卷是宿主机中的一个目录或文件</li>
<li>当容器目录和数据卷目录绑定后，对方的修改会立即同步</li>
<li>一个数据卷可以被多个容器同时挂载</li>
<li>一个容器也可以被挂载多个数据卷
        <h3 id="作用"   >
          <a href="#作用" class="heading-link"><i class="fas fa-link"></i></a>作用</h3>
      </li>
<li>容器数据持久化</li>
<li>外部机器和容器间接通信</li>
<li>容器之间数据交换
        <h3 id="配置数据卷"   >
          <a href="#配置数据卷" class="heading-link"><i class="fas fa-link"></i></a>配置数据卷</h3>
      <ul>
<li>创建启动容器时，使用 –v 参数 设置数据卷<br>docker run … –v  宿主机目录( 文件): 容器内目录( 文件) …</li>
</ul>
</li>
<li>注意事项：</li>
</ul>
<ol>
<li>目录必须是绝对路径</li>
<li>如果目录不存在，会自动创建</li>
<li>可以挂载多个数据卷<br>
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/20200520224847506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70"  style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbwpx;"  alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-YWasWMCg-1589985834540)(en-resource://database/4441:1)\]">
      
        <h3 id="数据卷容器"   >
          <a href="#数据卷容器" class="heading-link"><i class="fas fa-link"></i></a>数据卷容器</h3>
      多容器进行数据交换</li>
<li>多个容器挂载同一个数据卷</li>
<li>数据卷容器<br>
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/20200520224841377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70"  style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbwpx;"  alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wA9DAtQY-1589985834541)(en-resource://database/4443:1)\]">
      
        <h3 id="配置数据卷容器"   >
          <a href="#配置数据卷容器" class="heading-link"><i class="fas fa-link"></i></a>配置数据卷容器</h3>
      </li>
<li>创建启动c3数据卷容器，使用 –v 参数 设置数据卷<blockquote>
<p>docker run –it –name=c3 –v /volume centos:7 /bin/bash</p>
</blockquote>
</li>
<li>创建启动 c1 c2 容器，使用 –-volumes-from 参数 设置数据卷<blockquote>
<p>docker run –it –name=c1 –volumes-from c3 centos:7 /bin/bash<br>docker run –it –name=c2 –volumes-from c3 centos:7 /bin/bash</p>
</blockquote>

        <h3 id="数据卷小结"   >
          <a href="#数据卷小结" class="heading-link"><i class="fas fa-link"></i></a>数据卷小结</h3>
      </li>
<li>数据卷概念<ul>
<li>宿主机的一个目录或文件</li>
</ul>
</li>
<li>数据卷作用<ul>
<li>容器数据持久化</li>
<li>客户端和容器数据交换</li>
<li>容器间数据交换</li>
</ul>
</li>
<li>数据卷容器<ul>
<li>创建一个容器，挂载一个目录，让其他容器继承自该容器( –volume-from )。</li>
<li>通过简单方式实现数据卷配置</li>
</ul>
</li>
</ol>

        <h2 id="Docker-应用部署"   >
          <a href="#Docker-应用部署" class="heading-link"><i class="fas fa-link"></i></a>Docker 应用部署</h2>
      
        <h3 id="一、部署MySQL"   >
          <a href="#一、部署MySQL" class="heading-link"><i class="fas fa-link"></i></a>一、部署MySQL</h3>
      <p>
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/20200520224750301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70"  style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbwpx;"  alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-PkehUSZH-1589985834543)(en-resource://database/4445:1)\]">
      </p>
<ol>
<li>搜索mysql镜像</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></div></figure>

<ol start="2">
<li>拉取mysql镜像</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.6</span><br></pre></td></tr></table></div></figure>

<ol start="3">
<li>创建容器，设置端口映射、目录映射</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在/root目录下创建mysql目录用于存储mysql数据信息</span></span><br><span class="line">mkdir ~/mysql</span><br><span class="line">cd ~/mysql</span><br></pre></td></tr></table></div></figure>

<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -id \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">--name=c_mysql \</span><br><span class="line">-v $PWD/conf:/etc/mysql/conf.d \</span><br><span class="line">-v $PWD/logs:/logs \</span><br><span class="line">-v $PWD/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">mysql:5.6</span><br></pre></td></tr></table></div></figure>

<ul>
<li>参数说明：<ul>
<li><strong>-p 3306:3306</strong>：将容器的 3306 端口映射到宿主机的 3306 端口。</li>
<li><strong>-v $PWD/conf:/etc/mysql/conf.d</strong>：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。配置目录</li>
<li><strong>-v $PWD/logs:/logs</strong>：将主机当前目录下的 logs 目录挂载到容器的 /logs。日志目录</li>
<li><strong>-v $PWD/data:/var/lib/mysql</strong> ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。数据目录</li>
<li><strong>-e MYSQL_ROOT_PASSWORD=123456：</strong>初始化 root 用户的密码。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>进入容器，操作mysql</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec –it c_mysql /bin/bash</span><br></pre></td></tr></table></div></figure>

<ol start="5">
<li>使用外部机器连接容器中的mysql</li>
</ol>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/20200520224729202.png"  alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OPR6tavj-1589985834544)(en-resource://database/4447:1)\]">
      </p>

        <h3 id="二、部署Tomcat"   >
          <a href="#二、部署Tomcat" class="heading-link"><i class="fas fa-link"></i></a>二、部署Tomcat</h3>
      <ol>
<li>搜索tomcat镜像</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search tomcat</span><br></pre></td></tr></table></div></figure>

<ol start="2">
<li>拉取tomcat镜像</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat</span><br></pre></td></tr></table></div></figure>

<ol start="3">
<li>创建容器，设置端口映射、目录映射</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在/root目录下创建tomcat目录用于存储tomcat数据信息</span></span><br><span class="line">mkdir ~/tomcat</span><br><span class="line">cd ~/tomcat</span><br></pre></td></tr></table></div></figure>

<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name=c_tomcat \</span><br><span class="line">-p 8080:8080 \</span><br><span class="line">-v $PWD:/usr/local/tomcat/webapps \</span><br><span class="line">tomcat</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>参数说明：</p>
<ul>
<li><p><strong>-p 8080:8080：</strong>将容器的8080端口映射到主机的8080端口</p>
<p><strong>-v $PWD:/usr/local/tomcat/webapps：</strong>将主机中当前目录挂载到容器的webapps</p>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li>使用外部机器访问tomcat</li>
</ol>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/20200520225704275.png"  alt="">
      </p>

        <h3 id="三、部署Nginx"   >
          <a href="#三、部署Nginx" class="heading-link"><i class="fas fa-link"></i></a>三、部署Nginx</h3>
      <ol>
<li>搜索nginx镜像</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search nginx</span><br></pre></td></tr></table></div></figure>

<ol start="2">
<li>拉取nginx镜像</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></div></figure>

<ol start="3">
<li>创建容器，设置端口映射、目录映射</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在/root目录下创建nginx目录用于存储nginx数据信息</span></span><br><span class="line">mkdir ~/nginx</span><br><span class="line">cd ~/nginx</span><br><span class="line">mkdir conf</span><br><span class="line">cd conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在~/nginx/conf/下创建nginx.conf文件,粘贴下面内容</span></span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></div></figure>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">                      '$status $body_bytes_sent "$http_referer" '</span><br><span class="line">                      '"$http_user_agent" "$http_x_forwarded_for"';</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name=c_nginx \</span><br><span class="line">-p 80:80 \</span><br><span class="line">-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v $PWD/logs:/var/log/nginx \</span><br><span class="line">-v $PWD/html:/usr/share/nginx/html \</span><br><span class="line">nginx</span><br></pre></td></tr></table></div></figure>

<ul>
<li>参数说明：<ul>
<li><strong>-p 80:80</strong>：将容器的 80端口映射到宿主机的 80 端口。</li>
<li><strong>-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf</strong>：将主机当前目录下的 /conf/nginx.conf 挂载到容器的 :/etc/nginx/nginx.conf。配置目录</li>
<li><strong>-v $PWD/logs:/var/log/nginx</strong>：将主机当前目录下的 logs 目录挂载到容器的/var/log/nginx。日志目录</li>
</ul>
</li>
</ul>
<ol start="4">
<li>使用外部机器访问nginx<br>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/20200520224702972.png"  alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rJZLH2VX-1589985834545)(en-resource://database/4449:1)\]">
      </li>
</ol>

        <h3 id="四、部署Redis"   >
          <a href="#四、部署Redis" class="heading-link"><i class="fas fa-link"></i></a>四、部署Redis</h3>
      <ol>
<li>搜索redis镜像</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search redis</span><br></pre></td></tr></table></div></figure>

<ol start="2">
<li>拉取redis镜像</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:5.0</span><br></pre></td></tr></table></div></figure>

<ol start="3">
<li>创建容器，设置端口映射</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name=c_redis -p 6379:6379 redis:5.0</span><br></pre></td></tr></table></div></figure>

<ol start="4">
<li>使用外部机器连接redis</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli.exe -h 192.168.149.135 -p 6379</span><br></pre></td></tr></table></div></figure>




        <h2 id="Dockerfile"   >
          <a href="#Dockerfile" class="heading-link"><i class="fas fa-link"></i></a>Dockerfile</h2>
      
        <h3 id="Docker镜像原理"   >
          <a href="#Docker镜像原理" class="heading-link"><i class="fas fa-link"></i></a>Docker镜像原理</h3>
      <p><strong>Linux文件系统由bootfs和rootfs两部分组成</strong></p>
<ul>
<li>bootfs：包含bootloader（引导加载程序）和 kernel（内核）</li>
<li>rootfs： root文件系统，包含的就是典型 Linux 系统中的/dev，/proc，/bin，/etc等标准目录和文件</li>
<li>不同的linux发行版，bootfs基本一样，而rootfs不同，如ubuntu，centos等</li>
</ul>
<hr>
<ul>
<li>Docker镜像是由特殊的文件系统叠加而成</li>
<li>最底端是 bootfs，并使用宿主机的bootfs</li>
<li>第二层是 root文件系统rootfs,称为base image</li>
<li>然后再往上可以叠加其他的镜像文件</li>
<li>统一文件系统（Union File System）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在<br>一个文件系统。</li>
<li>一个镜像可以放在另一个镜像的上面。位于下面的镜像称<br>为父镜像，最底部的镜像成为基础镜像。</li>
<li>当从一个镜像启动容器时，Docker会在最顶层加载一个读<br>写文件系统作为容器</li>
</ul>
<p>
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/20200520224638400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70"  style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbwpx;"  alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-FRtWHHmZ-1589985834545)(en-resource://database/4453:1)\]">
      <br><strong>思考：</strong></p>
<ol>
<li><p>Docker 镜像本质是什么？<br>• 是一个分层文件系统</p>
</li>
<li><p>Docker 中一个centos镜像为什么只有200MB，而一个centos操作系统的iso文件要几个个G？<br>• Centos的iso镜像文件包含bootfs和rootfs，而docker的centos镜像复用操作系统的bootfs，只有rootfs和其他镜像层</p>
</li>
<li><p>Docker 中一个tomcat镜像为什么有500MB，而一个tomcat安装包只有70多MB？<br>• 由于docker中镜像是分层的，tomcat虽然只有70多MB，但他需要依赖于父镜像和基础镜像，所有整个对外暴露的<br>tomcat镜像大小500多MB</p>

        <h3 id="镜像制作"   >
          <a href="#镜像制作" class="heading-link"><i class="fas fa-link"></i></a>镜像制作</h3>
      <p>
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/202005202246215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70"  style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbwpx;"  alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gH7Y7XQ3-1589985834546)(en-resource://database/4455:1)\]">
      </p>
</li>
<li><p>容器转为镜像</p>
<blockquote>
<p>docker commit  容器id  镜像名称: 版本号<br>docker save -o 称 压缩文件名称  镜像名称: 版本号<br>docker load –i  压缩文件名称</p>
</blockquote>
</li>
<li><p>dockerfile</p>
</li>
</ol>

        <h3 id="dockerfile概念"   >
          <a href="#dockerfile概念" class="heading-link"><i class="fas fa-link"></i></a>dockerfile概念</h3>
      <ul>
<li>Dockerfile 是一个文本文件</li>
<li>包含了一条条的指令</li>
<li>每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像</li>
<li>对于开发人员：可以为开发团队提供一个完全一致的开发环境</li>
<li>对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件<br>构建一个新的镜像开始工作了</li>
<li>对于运维人员：在部署时，可以实现应用的无缝移植</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th>关键字</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>指定父镜像</td>
<td>指定dockerfile基于那个image构建</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>作者信息</td>
<td>用来标明这个dockerfile谁写的</td>
</tr>
<tr>
<td>LABEL</td>
<td>标签</td>
<td>用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看</td>
</tr>
<tr>
<td>RUN</td>
<td>执行命令</td>
<td>执行一段命令 默认是/bin/sh 格式: RUN command 或者 RUN [“command” , “param1”,”param2”]</td>
</tr>
<tr>
<td>CMD</td>
<td>容器启动命令</td>
<td>提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD [“command” , “param1”,”param2”]</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>入口</td>
<td>一般在制作一些执行就关闭的容器中会使用</td>
</tr>
<tr>
<td>COPY</td>
<td>复制文件</td>
<td>build的时候复制文件到image中</td>
</tr>
<tr>
<td>ADD</td>
<td>添加文件</td>
<td>build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务</td>
</tr>
<tr>
<td>ENV</td>
<td>环境变量</td>
<td>指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name=value</td>
</tr>
<tr>
<td>ARG</td>
<td>构建参数</td>
<td>构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数</td>
</tr>
<tr>
<td>VOLUME</td>
<td>定义外部可以挂载的数据卷</td>
<td>指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME [“目录”]</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>暴露端口</td>
<td>定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080/udp</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>工作目录</td>
<td>指定容器内部的工作目录 如果没有创建则自动创建 如果指定/ 使用的是绝对地址 如果不是/开头那么是在上一条workdir的路径的相对路径</td>
</tr>
<tr>
<td>USER</td>
<td>指定执行用户</td>
<td>指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户</td>
</tr>
<tr>
<td>HEALTHCHECK</td>
<td>健康检查</td>
<td>指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制</td>
</tr>
<tr>
<td>ONBUILD</td>
<td>触发器</td>
<td>当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大</td>
</tr>
<tr>
<td>STOPSIGNAL</td>
<td>发送信号量到宿主机</td>
<td>该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。</td>
</tr>
<tr>
<td>SHELL</td>
<td>指定执行脚本的shell</td>
<td>指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell</td>
</tr>
<tr>
<td>### dockerfile案例</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>案例：需求</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>自定义centos7镜像。要求：</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1. 默认登录路径为 /usr</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2. 可以使用vim</td>
<td></td>
<td></td>
</tr>
</tbody></table></div>
<p><strong>案例：实现步骤</strong><br>① 定义父镜像：FROM centos:7<br>② 定义作者信息：MAINTAINER itheima <span class="exturl"><a class="exturl__link"   href="mailto:&#x69;&#x74;&#x68;&#101;&#105;&#109;&#97;&#x40;&#x69;&#x74;&#x63;&#97;&#115;&#116;&#x2e;&#99;&#x6e;" >&#x69;&#x74;&#x68;&#101;&#105;&#109;&#97;&#x40;&#x69;&#x74;&#x63;&#97;&#115;&#116;&#x2e;&#99;&#x6e;</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>③ 执行安装vim命令： RUN yum install -y vim<br>④ 定义默认的工作目录：WORKDIR /usr<br>⑤ 定义容器启动执行的命令：CMD /bin/bash<br>⑥ 通过dockerfile构建镜像：docker bulid –f dockerfile文件路径 –t 镜像名称:版本</p>
<hr>
<p><strong>案例：需求</strong><br>定义dockerfile，发布springboot项目<br><strong>案例：实现步骤</strong><br>① 定义父镜像：FROM java:8<br>② 定义作者信息：MAINTAINER itheima <span class="exturl"><a class="exturl__link"   href="mailto:&#x69;&#x74;&#104;&#x65;&#105;&#x6d;&#x61;&#x40;&#105;&#x74;&#99;&#x61;&#x73;&#x74;&#46;&#x63;&#x6e;" >&#x69;&#x74;&#104;&#x65;&#105;&#x6d;&#x61;&#x40;&#105;&#x74;&#99;&#x61;&#x73;&#x74;&#46;&#x63;&#x6e;</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>③ 将jar包添加到容器： ADD springboot.jar app.jar<br>④ 定义容器启动执行的命令：CMD java–jar app.jar<br>⑤ 通过dockerfile构建镜像：docker bulid –f dockerfile文件路径 –t 镜像名称:版本</p>

        <h3 id="Docker服务编排"   >
          <a href="#Docker服务编排" class="heading-link"><i class="fas fa-link"></i></a>Docker服务编排</h3>
      
        <h3 id="概念-1"   >
          <a href="#概念-1" class="heading-link"><i class="fas fa-link"></i></a>概念</h3>
      <p>微服务架构的应用系统中一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，维护的工作量会很大。<br>• 要从Dockerfile build image 或者去dockerhub拉取image<br>• 要创建多个container<br>• 要管理这些container（启动停止删除）<br><strong>服务编排：</strong>  按照一定的业务规则批量管理容器</p>

        <h3 id="Docker-Compose"   >
          <a href="#Docker-Compose" class="heading-link"><i class="fas fa-link"></i></a>Docker Compose</h3>
      <p>Docker Compose是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建，启动和停止。使用步骤：</p>
<ol>
<li>利用 Dockerfile 定义运行环境镜像</li>
<li>使用 docker-compose.yml 定义组成应用的各服务</li>
<li>运行 docker-compose up 启动应用
        <h4 id="一、安装Docker-Compose"   >
          <a href="#一、安装Docker-Compose" class="heading-link"><i class="fas fa-link"></i></a>一、安装Docker Compose</h4>
      </li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Compose目前已经完全支持Linux、Mac OS和Windows，在我们安装Compose之前，需要先安装Docker。下面我 们以编译好的二进制包方式安装在Linux系统中。 </span></span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置文件可执行权限 </span></span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看版本信息 </span></span><br><span class="line">docker-compose -version</span><br></pre></td></tr></table></div></figure>


        <h4 id="二、卸载Docker-Compose"   >
          <a href="#二、卸载Docker-Compose" class="heading-link"><i class="fas fa-link"></i></a>二、卸载Docker Compose</h4>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 二进制包方式安装的，删除二进制文件即可</span></span><br><span class="line">rm /usr/local/bin/docker-compose</span><br></pre></td></tr></table></div></figure>




        <h4 id="三、-使用docker-compose编排nginx-springboot项目"   >
          <a href="#三、-使用docker-compose编排nginx-springboot项目" class="heading-link"><i class="fas fa-link"></i></a>三、 使用docker compose编排nginx+springboot项目</h4>
      <ol>
<li>创建docker-compose目录</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/docker-compose</span><br><span class="line">cd ~/docker-compose</span><br></pre></td></tr></table></div></figure>

<ol start="2">
<li>编写 docker-compose.yml 文件</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: '3'</span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">   image: nginx</span><br><span class="line">   ports:</span><br><span class="line">    - 80:80</span><br><span class="line">   links:</span><br><span class="line">    - app</span><br><span class="line">   volumes:</span><br><span class="line">    - ./nginx/conf.d:/etc/nginx/conf.d</span><br><span class="line">  app:</span><br><span class="line">    image: app</span><br><span class="line">    expose:</span><br><span class="line">      - "8080"</span><br></pre></td></tr></table></div></figure>

<ol start="3">
<li>创建./nginx/conf.d目录</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ./nginx/conf.d</span><br></pre></td></tr></table></div></figure>



<ol start="4">
<li>在./nginx/conf.d目录下 编写itheima.conf文件</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    access_log off;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://app:8080;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ol start="5">
<li>在~/docker-compose 目录下 使用docker-compose 启动容器</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></div></figure>

<ol start="6">
<li>测试访问</li>
</ol>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.149.135/hello</span><br></pre></td></tr></table></div></figure>

        <h2 id="Docker私有仓库"   >
          <a href="#Docker私有仓库" class="heading-link"><i class="fas fa-link"></i></a>Docker私有仓库</h2>
      
        <h3 id="概念-2"   >
          <a href="#概念-2" class="heading-link"><i class="fas fa-link"></i></a>概念</h3>
      <p>Docker官方的Docker hub（<span class="exturl"><a class="exturl__link"   href="https://hub.docker.com）是一个用于管理公共镜像的仓库，我们可以从上面拉取镜像到本地，也可以把我们自己的镜像推送上去。但是，有时候我们的服务器无法访问互联网，或者你不希望将自己的镜像放到公网当中，那么我们就需要搭建自己的私有仓库来存储和管理自己的镜像。"  target="_blank" rel="noopener">https://hub.docker.com）是一个用于管理公共镜像的仓库，我们可以从上面拉取镜像到本地，也可以把我们自己的镜像推送上去。但是，有时候我们的服务器无法访问互联网，或者你不希望将自己的镜像放到公网当中，那么我们就需要搭建自己的私有仓库来存储和管理自己的镜像。</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="搭建私有仓库"   >
          <a href="#搭建私有仓库" class="heading-link"><i class="fas fa-link"></i></a>搭建私有仓库</h3>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、拉取私有仓库镜像 </span></span><br><span class="line">docker pull registry</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、启动私有仓库容器 </span></span><br><span class="line">docker run -id --name=registry -p 5000:5000 registry</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、打开浏览器 输入地址http://私有仓库服务器ip:5000/v2/_catalog，看到&#123;<span class="string">"repositories"</span>:[]&#125; 表示私有仓库 搭建成功</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、修改daemon.json   </span></span><br><span class="line">vim /etc/docker/daemon.json    </span><br><span class="line"><span class="meta">#</span><span class="bash"> 在上述文件中添加一个key，保存退出。此步用于让 docker 信任私有仓库地址；注意将私有仓库服务器ip修改为自己私有仓库服务器真实ip </span></span><br><span class="line">&#123;"insecure-registries":["私有仓库服务器ip:5000"]&#125; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 5、重启docker 服务 </span></span><br><span class="line">systemctl restart docker</span><br><span class="line">docker start registry</span><br></pre></td></tr></table></div></figure>

        <h3 id="上传镜像到私有仓库"   >
          <a href="#上传镜像到私有仓库" class="heading-link"><i class="fas fa-link"></i></a>上传镜像到私有仓库</h3>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、标记镜像为私有仓库的镜像     </span></span><br><span class="line">docker tag centos:7 私有仓库服务器IP:5000/centos:7</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、上传标记的镜像     </span></span><br><span class="line">docker push 私有仓库服务器IP:5000/centos:7</span><br></pre></td></tr></table></div></figure>

        <h3 id="从私有仓库拉取镜像"   >
          <a href="#从私有仓库拉取镜像" class="heading-link"><i class="fas fa-link"></i></a>从私有仓库拉取镜像</h3>
      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">拉取镜像 </span></span><br><span class="line">docker pull 私有仓库服务器ip:5000/centos:7</span><br></pre></td></tr></table></div></figure>

        <h2 id="Docker-容器虚拟化与传统虚拟机比较"   >
          <a href="#Docker-容器虚拟化与传统虚拟机比较" class="heading-link"><i class="fas fa-link"></i></a>Docker 容器虚拟化与传统虚拟机比较</h2>
      <p>容器就是将软件打包成标准化单元，以用于开发、交付和部署。<br>• 容器镜像是轻量的、可执行的独立软件包 ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。<br>• 容器化软件在任何环境中都能够始终如一地运行。<br>• 容器赋予了软件独立性，使其免受外在环境差异的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。<br>
        <img     class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/20200520224511871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70"  style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbwpx;"  alt="在这里插入图片描述">
      <br>相同：<br>    • 容器和虚拟机具有相似的资源隔离和分配优势<br>不同：<br>    • 容器虚拟化的是操作系统，虚拟机虚拟化的是硬件。<br>    • 传统虚拟机可以运行不同的操作系统，容器只能运行同一类型操作系统</p>
<hr>
<p><strong>2020年5月20日更</strong></p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://www.motongxue.cn">Motongxue</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://www.motongxue.cn/posts/4223150074/">https://www.motongxue.cn/posts/4223150074/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://www.motongxue.cn/tags/Docker/">Docker</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://www.motongxue.cn/tags/Linux/">Linux</a></span></div><div class="post-share"><div class="social-share" data-sites="qzone, qq, weibo, wechat, douban, linkedin, facebook, twitter, google">Share to: </div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/posts/2945718842/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">hh</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/posts/625185776/"><span class="paginator-prev__text">Java SSM整合</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Docker-是什么？"><span class="toc-number">1.</span> <span class="toc-text">
          1 Docker 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Docker-的优势"><span class="toc-number">2.</span> <span class="toc-text">
          2 Docker 的优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Docker-的三个基本概念"><span class="toc-number">3.</span> <span class="toc-text">
          3 Docker 的三个基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Image（镜像）"><span class="toc-number">3.1.</span> <span class="toc-text">
          Image（镜像）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Container（容器）"><span class="toc-number">3.2.</span> <span class="toc-text">
          Container（容器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Repository（仓库）"><span class="toc-number">3.3.</span> <span class="toc-text">
          Repository（仓库）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Docker-的安装和使用"><span class="toc-number">4.</span> <span class="toc-text">
          4 Docker 的安装和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#环境准备："><span class="toc-number">4.1.</span> <span class="toc-text">
          环境准备：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安装-Docker"><span class="toc-number">4.2.</span> <span class="toc-text">
          安装 Docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-的简单运用-Hello-World"><span class="toc-number">4.3.</span> <span class="toc-text">
          Docker 的简单运用 Hello World</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Docker-架构"><span class="toc-number">5.</span> <span class="toc-text">
          5 Docker 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-Client"><span class="toc-number">5.1.</span> <span class="toc-text">
          Docker Client</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-Daemon"><span class="toc-number">5.2.</span> <span class="toc-text">
          Docker Daemon</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-Image"><span class="toc-number">5.3.</span> <span class="toc-text">
          Docker Image</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-Registry"><span class="toc-number">5.4.</span> <span class="toc-text">
          Docker Registry</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-Container"><span class="toc-number">5.5.</span> <span class="toc-text">
          Docker Container</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Docker-组件是如何协作运行容器"><span class="toc-number">6.</span> <span class="toc-text">
          6 Docker 组件是如何协作运行容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Docker-常用命令"><span class="toc-number">7.</span> <span class="toc-text">
          7 Docker 常用命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker容器的数据卷"><span class="toc-number">8.</span> <span class="toc-text">
          Docker容器的数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念"><span class="toc-number">8.1.</span> <span class="toc-text">
          概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用"><span class="toc-number">8.2.</span> <span class="toc-text">
          作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置数据卷"><span class="toc-number">8.3.</span> <span class="toc-text">
          配置数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据卷容器"><span class="toc-number">8.4.</span> <span class="toc-text">
          数据卷容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置数据卷容器"><span class="toc-number">8.5.</span> <span class="toc-text">
          配置数据卷容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据卷小结"><span class="toc-number">8.6.</span> <span class="toc-text">
          数据卷小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-应用部署"><span class="toc-number">9.</span> <span class="toc-text">
          Docker 应用部署</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、部署MySQL"><span class="toc-number">9.1.</span> <span class="toc-text">
          一、部署MySQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、部署Tomcat"><span class="toc-number">9.2.</span> <span class="toc-text">
          二、部署Tomcat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、部署Nginx"><span class="toc-number">9.3.</span> <span class="toc-text">
          三、部署Nginx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、部署Redis"><span class="toc-number">9.4.</span> <span class="toc-text">
          四、部署Redis</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dockerfile"><span class="toc-number">10.</span> <span class="toc-text">
          Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker镜像原理"><span class="toc-number">10.1.</span> <span class="toc-text">
          Docker镜像原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#镜像制作"><span class="toc-number">10.2.</span> <span class="toc-text">
          镜像制作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dockerfile概念"><span class="toc-number">10.3.</span> <span class="toc-text">
          dockerfile概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker服务编排"><span class="toc-number">10.4.</span> <span class="toc-text">
          Docker服务编排</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#概念-1"><span class="toc-number">10.5.</span> <span class="toc-text">
          概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-Compose"><span class="toc-number">10.6.</span> <span class="toc-text">
          Docker Compose</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、安装Docker-Compose"><span class="toc-number">10.6.1.</span> <span class="toc-text">
          一、安装Docker Compose</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、卸载Docker-Compose"><span class="toc-number">10.6.2.</span> <span class="toc-text">
          二、卸载Docker Compose</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、-使用docker-compose编排nginx-springboot项目"><span class="toc-number">10.6.3.</span> <span class="toc-text">
          三、 使用docker compose编排nginx+springboot项目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker私有仓库"><span class="toc-number">11.</span> <span class="toc-text">
          Docker私有仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念-2"><span class="toc-number">11.1.</span> <span class="toc-text">
          概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#搭建私有仓库"><span class="toc-number">11.2.</span> <span class="toc-text">
          搭建私有仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#上传镜像到私有仓库"><span class="toc-number">11.3.</span> <span class="toc-text">
          上传镜像到私有仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从私有仓库拉取镜像"><span class="toc-number">11.4.</span> <span class="toc-text">
          从私有仓库拉取镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-容器虚拟化与传统虚拟机比较"><span class="toc-number">12.</span> <span class="toc-text">
          Docker 容器虚拟化与传统虚拟机比较</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/Motongxue.png" alt="avatar"></div><p class="sidebar-ov-author__text">欢迎访问：motongxue.cn</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://blog.csdn.net/CrazyMooo" target="_blank" rel="noopener" data-popover="social.csdn" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">csdn</span></a><a class="sidebar-ov-social-item" href="http://wpa.qq.com/msgrd?v=3&amp;uin=393888412&amp;site=qq&amp;menu=yes" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-feed"><span class="sidebar-ov-feed-email"><a class="sidebar-ov-feed-email__link" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=393888412@qq.com" target="_blank" rel="noopener"><span class="sidebar-ov-feed-email__icon"><i class="fas fa-envelope"></i></span><span>Email 发送邮件</span></a></span></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">18</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">36</div><div class="sidebar-ov-state-item__name">标签</div></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Motongxue</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div><div>我抓不住世间的美好，只好装作万事顺遂的样子</div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);</script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.0.0-rc.0"></script><script src="/js/stun-boot.js?v=2.0.0-rc.0"></script><script src="/js/scroll.js?v=2.0.0-rc.0"></script><script src="/js/header.js?v=2.0.0-rc.0"></script><script src="/js/sidebar.js?v=2.0.0-rc.0"></script></body></html>