[{"title":"分治 平面上的最近点对","url":"/posts/1406529906/","content":"\n**分治 平面上的最近点对**\n**题目描述**\n给定平面上n个点，找出其中的一对点的距离，使得在这n个点的所有点对中，该距离为所有点对中最小的。\n<!-- more -->\n**输入格式：**\n多行输入\n第一行：n；2≤n≤200000\n接下来n行：每行两个实数：x y，表示一个点的行坐标和列坐标，中间用一个空格隔开。\n\n**输出格式：**\n仅一行，一个实数，表示最短距离，精确到小数点后面4位。\n\n**输入输出样例\n输入样例#1：**\n```\n10\n1 1\n1 5\n3 1\n5 1\n5 6\n6 7\n7 3\n8 1\n10 3\n9 9\n3\n1 1\n1 2\n2 2\n2\n1 1\n2 2\n```\n**输出样例#1：**\n```\n1.0000\n1.4142\n1.4142\n```\n**说明**\n0<=x,y<=10^9\n\n**题目分析**\n先把点坐标x从小到大排序，然后从中间分开，最短距离有以下两种情况：\n1. 最短距离两点都在同一侧：\n对于这种来说递归的终止时只需计算2-3点的距离，设计这两种情况的递归终止条件即可。\n2. 最短距离两点分别在两侧：\n\t1. 由于我们先递归求得左右两侧的最短距离`minDistance1`和`minDistance2`\n\t2. 求出左右两侧的较短距离`minDistance = min{minDistance1,minDistance2}`;\n\t3. 现在只需要比距离d小的点，这时我们以中间的坐标x为准，对[x-d,x+d]之间的点暴力进行判断，找出最小值就可以得到答案了\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200429230140439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n\n\n\n\n**代码详解**\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstruct node{//定义每个坐标\n\tdouble x,y;\n}a[200010];\nint c[200010];\ndouble cmpy(int t1,int t2)  \n{  \n  return a[t1].y<a[t2].y;  \n}  \nbool cmp(node t1,node t2)\n{\n\treturn t1.x<t2.x;\n}\ndouble dis(node t1,node t2)//计算两点间的距离\n{\n\treturn sqrt((t1.x-t2.x)*(t1.x-t2.x)+(t1.y-t2.y)*(t1.y-t2.y));\n}\ndouble min(double t1,double t2)//返回较小数值\n{\n\treturn t1<t2?t1:t2;\n}\ndouble find(int left,int right)\n{\n\tif(left+1==right)//如果只有两个点，则直接返回两点距离\n\t\treturn dis(a[left],a[right]);\n\tif(left+2==right)//如果只有三个点，则求这三个点相距的最小距离\n\t\treturn min(dis(a[left],a[right]),min(dis(a[left],a[left+1]),dis(a[left+1],a[right])));\n\tint mid=(left+right)>>1;//求中点\n\tdouble ans=min(find(left,mid),find(mid+1,right));  //将平面一分为二\n    int i,j,cnt=0;  \n    //------------------------核心代码-------------\n    //有可能最小值的点位于分界直线两边，计算位于分界直线两边的点\n    for(i=left;i<=right;i++)//将点坐标 x 到中间点坐标 a[mid] 的距离小于ans的值保存进数组c\n\t\tif(abs(a[mid].x-a[i].x)<ans)  \n\t\t\tc[cnt++]=i;  \n\tsort(c,c+cnt,cmpy);//将点坐标按 y 从小到大排序 \n    for(i=0;i<cnt;i++) //比较数组c内两点距离找最小值（暴力，因为此时数据范围很小）\n\t\tfor(j=i+1;j<cnt;j++)  \n\t\t{  \n            //y坐标升序排列，有j>i所以差值肯定为正，故不需要绝对值\n\t\t\tif(a[c[j]].y-a[c[i]].y>ans)//如果y相差已经大于ans，则算上x肯定大于ans\n\t\t\t\tbreak;  \n\t\t\tans=min(ans,dis(a[c[i]],a[c[j]]));//求出最小值了\n\t\t}\n    return ans;\n}\nint main()\n{\n\tint n,i;\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\twhile(cin>>n)\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t\tcin>>a[i].x>>a[i].y;\n\t\tstd::sort(a,a+n,cmp);\n\t\tprintf(\"%.4lf\\n\",find(0,n-1));\n\t}\n\treturn 0;\n}\n```\n---\n代码思路，编辑格式不易，大家觉得还可以可以**点赞**、**收藏**、**关注**一下吧！","tags":["算法","分治"],"categories":["MyTech","算法","分治"]},{"title":"我捏住了月亮","url":"/posts/3145517177/","content":"\n## 我捏住了月亮\n\n\n\n临近太阳下山，朋友们提议去渔港吹着海风看日落，<!-- more -->道路上也能听到蚊虫肆意飞行的声音，一只两只三只，它们好像都有着自己的目标，瞄准着我们几个，只只直击身体。\n\n如同伴所说，开着小电动，路上的蚊虫如雨点般洒落。~~实话说，作为一个本地人，却也是我第一次去本地的渔港。~~\n\n到了海边时，太阳已经落下山了，我望着天边，不知道哪边才是太阳落下的方向。可能我们已经离开了世间喧嚣，来到这片桃花源，迷失了方向。我望着海边，海风吹向我。\n\n![](http://q9w6aimkr.bkt.clouddn.com/IMG_20200503_192236.jpg)\n\n伙伴们跟我介绍，这里就是海港的码头。海的另一边就是市区。一片片霓虹灯光闪耀在海平线上，泛起的涟漪散发出诱人的灯光，不禁让人迷失了方向，沉浸在它的世界里。\n\n忽而，近处传来渔船轰鸣的声音。一只小渔船，打算趁着夜色去捕捞鱼。\n\n远处也有一只大点的渔船闪着灯光。有时，灯光从远方照来，不觉刺眼，反而感受到平淡生命的朝气。\n\n![](http://q9w6aimkr.bkt.clouddn.com/IMG_20200503_191157.jpg)\n\n伙伴说如果说我们再早一点的话还可以看到鱼儿在水里游来游去。尽管夜色已晚，但海水不断地涌来，打在了堤坝上，就像是他们之间的游戏，仍能听见水声在旁边哗啦作响。\n\n我想，虽然没能看到落日。这不影响我们来到这里满是激动的心情，因为和朋友们相聚本身就是一件愉快的事情，虽然有人由于工作的原因早早去了深圳，没能有更多团聚的时光。\n\n![](http://q9w6aimkr.bkt.clouddn.com/20200507131342.jpg)\n\n忽然抬头望向远方，发现月亮在头顶闪闪发光。就像我为了太阳来，却意外收获了月亮。\n\n我试着把手伸向远方，我捏住了月亮。 \n\n![](http://q9w6aimkr.bkt.clouddn.com/IMG_20200503_192624.jpg)\n\n---\n\n**靓仔照片：**\n\n![](http://q9w6aimkr.bkt.clouddn.com/20200507131226.jpg)\n\n![](http://q9w6aimkr.bkt.clouddn.com/mmexport1588810189461.jpg)","tags":["生活"],"categories":["MyLife","随笔"]},{"title":"算法 卡特兰数","url":"/posts/3025807771/","content":"## 卡特兰数\n\n### 卡特兰数简介\n[卡特兰数推荐博文](https://blog.csdn.net/qq_30115697/article/details/88906534)\n<!-- more -->\n卡特兰数是组合数学中的一种著名数列，通常用如下通项式表示(为了不与组合数C冲突，本文用f表示卡特兰数)：\nf(n)=C(n、2n)/(n+1)\n当然，卡特兰数也是有递推式的：\nf(n)=∑(n−1、i=0)f(i)×f(n−i−1)\n但在实际应用中，最常用的却是第一个通项式的变形：\nf(n)=C(n、2n)−C(n−1、2n)\n\n1. **给定节点组成二叉搜索树**\n\n   给定N个节点，能构成多少种不同的二叉搜索树？(f(n)种)\n\n2. **扩号化**\n\n   矩阵连乘： P=a1×a2×a3×……×an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？(f(n)种)\n\n3. **出栈次序**\n\n   一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列?(f(n)种)\n\n4. **凸多边形三角划分**\n\n   在一个凸多边形中，通过若干条互不相交的对角线，把这个多边形划分成了若干个三角形。任务是键盘上输入凸多边形的边数n，求不同划分的方案数f（n）。\n\n5. **n对括号正确匹配数目**\n\n   给定n对括号，求括号正确配对的字符串数\n\n6. **霍比特人和兽人排队买票问题** （下文矩阵II问题）\n\n### 栈\n\n**题目描述** \n\n![](http://q9w6aimkr.bkt.clouddn.com/20200507125702.png)\n\n宁宁考虑的是这样一个问题：一个操作数序列，1,2,…,n（图示为 1 到 3 的情况），栈 A 的深度大于 n。\n\n现在可以进行两种操作，\n\n1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）\n2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）\n\n使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 `1 2 3` 生成序列 `2 3 1` 的过程。\n\n![](http://q9w6aimkr.bkt.clouddn.com/20200507125731.png)\n\n（原始状态如上图所示）\n\n你的程序将对给定的 n，计算并输出由操作数序列 1,2,…,n 经过操作可能得到的输出序列的总数。\n\n**输入格式**\n\n输入文件只含一个整数 n（1≤n≤18）。\n\n**输出格式**\n\n输出文件只有一行，即可能输出序列的总数目。\n\n**输入 #1**\n\n```\n3\n\n```\n\n**输出 #1** \n\n```\n5\n\n```\n\n```c++\n#include<iostream>\nusing namespace std;\nint main(){\n    int a[110]={1},n,t,i,j;\n    cin>>n;\n    for(i=1;i<=n;i++){\n        for(j=0;j<i;j++){\n            a[i] += a[j] * a[i-j-1];\n        }\n    }\n    cout<<a[n];    \n    return 0;\n}\n```\n\n### 矩阵II\n\n**Problem**\n\n众所周知，在中国古代算筹中，红为正，黑为负……\n\n给定一个1*(2n)的矩阵（usqwedf：这不是一个2n的队列么），现让你自由地放入红色算筹和黑色算筹，使矩阵平衡[即对于所有的i(1<=i<=2n)，**使第1~i格中红色算筹个数大于等于黑色算筹]**\n\n问有多少种方案满足矩阵平衡。\n\n**输入 #1** \n\n```\n2 1<=n<=100\n\n```\n\n**输出 #1**\n\n```\n2  方案数t对100取模\n\n```\n\n```c++\nint main(){\n    int a[110]={1},n,t,i,j;\n    cin>>n;\n    for(i=1;i<=n;i++){\n        for(j=0;j<i;j++){\n            a[i] += a[j] * a[i-j-1];\n            a[i] %= 100；\n        }\n    }\n    cout<<a[n];    \n    return 0;\n}\n```\n\n### 鸡蛋饼\n\n**题目描述** \n\n最近小 x 又发现了一个关于圆的有趣的问题：在圆上有 2N 个不同的点，小 x 想用 N 条线段把这些点连接起来（每个点只能连一条线段）， 使所有的线段都不相交，他想知道这样的连接方案有多少种？\n\n**输入格式** \n\n有且仅有一个正整数 N 。 （N≤2999）\n\n**输出格式**\n\n要求的方案数（结果 mod100000007）。\n\n**输入 #1** \n\n```\n24\n\n```\n\n**输出 #1** \n\n```\n4057031\n\n```\n\n```c++\n/*那么假如我们在圆上画了2n个点，顺时针编号为1,2,3,4……，你便会发现，如果一个奇数点和另一个奇数点相连，一定会造成将剩下所没有连线的点分在两边的都是奇数个，而后两边必定有一个点没线连或穿越其中的一条线，那么就不可能完成了。那么我们可以把奇数点看成左括号，偶数点看成右括号，然后把圆切开，就变成了一个括号匹配的方案数问题。为什么圆可以切开呢？因为A连B和B连A是同一种切法。\n在这里可以用h(n)=C(2n,n)/(n+1),用扩展欧几里德求逆元。\n*/\nint main(){\n    int a[3100]={1},n,t,i,j;\n    for(i=1;i<=n;i++){\n        for(j=0;j<i;j++){\n            a[i] += a[j] * a[i-j-1];\n            a[i] %= 100000007；\n        }\n    }\n    cout<<a[n];    \n    return 0;\n}\n```\n\n### 树屋阶梯\n\n**题目描述：**\n\n暑假期间，小龙报名了一个模拟野外生存作战训练班来锻炼体魄，训练的第一个晚上，教官就给他们出了个难题。由于地上露营湿气重，必须选择在高处的树屋露营。小龙分配的树屋建立在一颗高度为N+1尺（N为正整数）的大树上，正当他发愁怎么爬上去的时候，发现旁边堆满了一些空心四方钢材（如图1.1），经过观察和测量，这些钢材截面的宽和高大小不一，但都是1尺的整数倍，教官命令队员们每人选取N个空心钢材来搭建一个总高度为N尺的阶梯来进入树屋，该阶梯每一步台阶的高度为1尺，宽度也为1尺。如果这些钢材有各种尺寸，且每种尺寸数量充足，那么小龙可以有多少种搭建方法？（注：为了避免夜里踏空，钢材空心的一面绝对不可以向上。）\n\n**输入格式：**\n\n一个正整数 N(1≤N≤500)，表示阶梯的高度\n\n**输出格式：** \n\n一个正整数，表示搭建方法的个数。（注：搭建方法个数可能很大。）\n\n**输入样例：**\n\n3\n\n**输出样例：**\n\n5\n\n![](http://q9w6aimkr.bkt.clouddn.com/20200507125816.png)\n\n**思路：** \n\n这里有 N 个拐角，而题目只允许我们放 N 个矩形，也就是说，**每个矩形恰好覆盖一个拐角**。从而分为上和右两个问题，从而递归解决\n\n```python\n# 卡特兰数递推公式： h(n)= (2n)! / ((n+1)!⋅n!)\n#引用math库\nimport math\n#定义组合数函数\ndef C(n,m):\n    return math.factorial(n)//math.factorial(m)//math.factorial(n-m)\n    #引用阶乘求组合数 //为地板除 返回int 向下取整\n    #而如果用/则会返回float导致其他问题\nn=int(input())\nprint(C(2*n,n)-C(2*n,n-1))\n```","tags":["算法","数论","卡特兰数"],"categories":["MyTech","算法","数论"]},{"title":"并查集 月亮之眼","url":"/posts/3732306655/","content":"**月亮之眼**\n<!-- more -->\n**描述**\n吉儿是一家古董店的老板娘，由于她经营有道，小店开得红红火火。昨天，吉儿无意之中得到了散落民间几百年的珍宝—月亮之眼。吉儿深知“月亮之眼”价值连城：它是由许多珍珠相连而成的，工匠们用金线连接珍珠，每根金线连接两个珍珠；同时又对每根金线染上两种颜色，一半染成银白色，一半染成黛黑色。由于吉儿自小熟读古籍，所以还晓得“月亮之眼”的神秘传说：“月亮之眼”原是一个古代寺庙的宝物，原本是挂在佛堂的一根顶梁柱上的，整个宝物垂直悬挂，所有珍珠排成一线，且都镶嵌在柱子里，而每一根金线又都是绷紧的，并且金线的银白色一端始终在黛黑色一端的上方；然而，在一个月圆之夜，“月亮之眼”突然从柱里飞出，掉落下来，宝物本身完好无损，只是僧侣们再也无法以原样把“月亮之眼”嵌入柱子中了。吉儿望着这个神秘的宝物，回忆着童年读到的传说，顿时萌发出恢复“月亮之眼”的冲动，但是摆弄了几天依旧没有成功。\n\n现在，要麻烦您来帮助吉儿完成这项使命。\n\n您要设计一个程序，对于给定的“月亮之眼”进行周密分析，然后给出这串宝物几百年前嵌在佛堂顶梁柱上的排列模样。给定的“月亮之眼”有N个珍珠和P根金线，所有珍珠按一定顺序有了一个序号：1、2…、N。\n\n**格式**\n**输入格式**\n输入数据包含一个“月亮之眼”的特征描述：\n文件第一行有两个整数N和P，其中N表示宝物中的珍珠个数，P表示宝物中的金线根数；\n以下P行描述珍珠连接情况：\n文件第I+1行有三个整数，Ri1,Ri2,Li。其中Ri1表示第I根金线的银白色一端连接的珍珠序号；Ri2表示第I根金线的黛黑色一端连接的珍珠序号；Li表示第I根金线的长度。\n\n**输出格式**\n由于珍珠尺寸很小，所以几个珍珠可以同时镶嵌在一个位置上。\n\n您的输出数据描述的是“月亮之眼”各个珍珠在顶梁柱上的位置，输出文件共N行：\n第I行，一个整数S，它表示标号为I的珍珠在顶梁柱上距离最高位置珍珠的距离。\n\n注意：若无解则输出仅一行，包含一个整数“-1”。\n\n**样例1\n样例输入1**\n```\n9 9\n1 2 3\n2 3 5\n2 7 1\n4 5 4\n5 6 1\n5 9 1\n6 7 1\n7 8 3\n9 8 4\n```\n**样例输出1**\n```\n2\n5\n10\n0\n4\n5\n6\n9\n5\n```\n```cpp\n#include <iostream>\n#include <cstdio>\n#define maxn 505\nusing namespace std;\nint p[maxn], v[maxn], N, M;//v表示距离根节点的距离，p表示父节点是谁\nint find(int x)\n{\n    int t = p[x];\n    if (t == x)\n        return x;\n    v[x] += v[t];//递推出与根节点的距离\n    return p[x] = find(t);\n}\nint merg(int x, int y, int l)\n{\n    /* 对于两个不同集合的合并，由于在找集合的过程中使用了find函数，\n    所以相关节点一定直接和集合树的根节点连接。设现在要连接的节点是a、b，\n    它们的根节点分别是roota和rootb, a与b的距离为c, a在b的上面。\n    集合的合并是集合根节点之间的连接，所以需要计算出根节点之间的距离P，\n    b到roota的距离应为d[a]+c, b到rootb的距离为d[b] ,假设rootb成为roota的孩子，\n    着P+d[b]=d[a]+c => P=d[a]+c-d[b].若P为负，则roota应成为rootb的孩子，\n    距离为P的绝对值。 */\n    int fx = find(x), fy = find(y), d;\n    d = v[x] + l - v[y];\n    if (fx != fy)\n    {\n        if (d >= 0)//判断roota、rootb那个应该是父节点\n            p[fy] = fx, v[fy] = d;//rootb成为roota的孩子\n        else\n            p[fx] = fy, v[fx] = -d;//roota成为rootb的孩子\n    }\n    else if (v[x] + l != v[y])//因为绳子是紧绷的，所以应该相加相等\n        return -1;\n    return 1;\n}\nint main()\n{\n    int a, b, c, tmp;\n    for (int i = 0; i <= maxn - 2; i++)\n        v[i] = 0, p[i] = i;\n    scanf(\"%d%d\", &M, &N);\n    for (int i = 0; i < N; i++)\n    {\n        scanf(\"%d%d%d\", &a, &b, &c);\n        if (merg(a, b, c) == -1)\n        {\n            printf(\"-1\\n\");\n            return 0;\n        }\n    }\n    for (int i = 1; i <= M; i++)find(i);//重新计算他们的根\n    for (int i = 1; i <= M; i++)\n        printf(\"%d\\n\", v[i]);\n    return 0;\n}\n```","tags":["算法","并查集"],"categories":["MyTech","算法","图论"]},{"title":"SpringBoot基础","url":"/posts/2835215864/","content":"@[toc]\n# SpringBoot基础\n## 学习目标：\n<!-- more -->\n1. 能够理解Spring的优缺点\n2. 能够理解SpringBoot的特点\n3. 能够理解SpringBoot的核心功能\n4. 能够搭建SpringBoot的环境\n5. 能够完成application.properties配置文件的配置\n6. 能够完成application.yml配置文件的配置\n7. 能够使用SpringBoot集成Mybatis\n8. 能够使用SpringBoot集成Junit\n9. 能够使用SpringBoot集成SpringData JPA\n\n# 一、SpringBoot简介\n\n## 1.1  原有Spring优缺点分析\n\n### 1.1.1 Spring的优点分析\n\nSpring是Java企业版（Java Enterprise Edition，JEE，也称J2EE）的轻量级代替品。无需开发重量级的Enterprise JavaBean（EJB），Spring为企业级Java开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的Java对象（Plain Old Java Object，POJO）实现了EJB的功能。\n\n### 1.1.2 Spring的缺点分析\n\n虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring用XML配置，而且是很多XML配置。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。\n\n所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进行思维切换，所以编写配置挤占了编写应用程序逻辑的时间。和所有框架一样，Spring实用，但与此同时它要求的回报也不少。\n\n除此之外，项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。\n\n## 1.2 SpringBoot的概述\n\n### 1.2.1 SpringBoot解决上述Spring的缺点\n\nSpringBoot对上述Spring的缺点进行的改善和优化，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。\n\n### 1.2.2 SpringBoot的特点\n\n- 为基于Spring的开发提供更快的入门体验\n- 开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求\n- 提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等\n- SpringBoot不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式\n\n### 1.2.3 SpringBoot的核心功能\n\n- 起步依赖\n\n  起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。\n\n  简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。\n\n- 自动配置\n\n  Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的。\n\n\n\n\n​\t注意：起步依赖和自动配置的原理剖析会在第三章《SpringBoot原理分析》进行详细讲解\n\n# 二、SpringBoot快速入门\n\n## 2.1 代码实现\n\n### 2.1.1 创建Maven工程\n\n使用idea工具创建一个maven工程，该工程为普通的java工程即可\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217130441967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217130448135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217130452299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217130459802.png)\n### 2.1.2 添加SpringBoot的起步依赖\n\nSpringBoot要求，项目要继承SpringBoot的起步依赖spring-boot-starter-parent\n\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.0.1.RELEASE</version>\n</parent>\n```\n\nSpringBoot要集成SpringMVC进行Controller的开发，所以项目要导入web的启动依赖\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n```\n\n\n\n### 2.1.3 编写SpringBoot引导类\n\n要通过SpringBoot提供的引导类起步SpringBoot才可以进行访问\n\n```java\npackage com.itheima;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class MySpringBootApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MySpringBootApplication.class);\n    }\n\n}\n```\n\n### 2.1.4 编写Controller\n\n在引导类MySpringBootApplication同级包或者子级包中创建QuickStartController\n\n```java\npackage com.itheima.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@Controller\npublic class QuickStartController {\n    \n    @RequestMapping(\"/quick\")\n    @ResponseBody\n    public String quick(){\n        return \"springboot 访问成功!\";\n    }\n    \n}\n```\n\n### 2.1.5 测试\n\n执行SpringBoot起步类的主方法，控制台打印日志如下：\n\n```\n.   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v2.0.1.RELEASE)\n\n2018-05-08 14:29:59.714  INFO 5672 --- [           main] com.itheima.MySpringBootApplication      : Starting MySpringBootApplication on DESKTOP-RRUNFUH with PID 5672 (C:\\Users\\muzimoo\\IdeaProjects\\IdeaTest\\springboot_quick\\target\\classes started by muzimoo in C:\\Users\\muzimoo\\IdeaProjects\\IdeaTest)\n... ... ...\no.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]\n2018-05-08 14:30:03.126  INFO 5672 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup\n2018-05-08 14:30:03.196  INFO 5672 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''\n2018-05-08 14:30:03.206  INFO 5672 --- [           main] com.itheima.MySpringBootApplication      : Started MySpringBootApplication in 4.252 seconds (JVM running for 5.583)\n```\n\n通过日志发现，Tomcat started on port(s): 8080 (http) with context path ''\n\ntomcat已经起步，端口监听8080，web应用的虚拟工程名称为空\n\n打开浏览器访问url地址为：http://localhost:8080/quick\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020021713054226.png)\n## 2.2 快速入门解析\n\n### 2.2.2 SpringBoot代码解析\n\n- @SpringBootApplication：标注SpringBoot的启动类，该注解具备多种功能（后面详细剖析）\n- SpringApplication.run(MySpringBootApplication.class) 代表运行SpringBoot的启动类，参数为SpringBoot启动类的字节码对象\n\n### 2.2.3 SpringBoot工程热部署\n\n我们在开发中反复修改类、页面等资源，每次修改后都是需要重新启动才生效，这样每次启动都很麻烦，浪费了大量的时间，我们可以在修改代码后不重启就能生效，在 pom.xml 中添加如下配置就可以实现这样的功能，我们称之为热部署。\n\n```xml\n<!--热部署配置-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n</dependency>\n```\n\n注意：IDEA进行SpringBoot热部署失败原因\n\n出现这种情况，并不是热部署配置问题，其根本原因是因为Intellij IEDA默认情况下不会自动编译，需要对IDEA进行自动编译的设置，如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217130700892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n然后 Shift+Ctrl+Alt+/，选择Registry\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217130710797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n\n### 2.2.4 使用idea快速创建SpringBoot项目\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217130831336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217130838581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217130850758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217130856104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217130900951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n\n\n\n通过idea快速创建的SpringBoot项目的pom.xml中已经导入了我们选择的web的起步依赖的坐标\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\n\t<groupId>com.itheima</groupId>\n\t<artifactId>springboot_quick2</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<packaging>jar</packaging>\n\n\t<name>springboot_quick2</name>\n\t<description>Demo project for Spring Boot</description>\n\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\n\t\t<version>2.0.1.RELEASE</version>\n\t\t<relativePath/> <!-- lookup parent from repository -->\n\t</parent>\n\n\t<properties>\n\t\t<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n\t\t<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n\t\t<java.version>9</java.version>\n\t</properties>\n\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t</dependencies>\n\n\t<build>\n\t\t<plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\n\n</project>\n\n```\n\n可以使用快速入门的方式创建Controller进行访问，此处不再赘述\n\n\n\n# 三、SpringBoot原理分析\n\n## 3.1 起步依赖原理分析\n\n### 3.1.1 分析spring-boot-starter-parent\n\n按住Ctrl点击pom.xml中的spring-boot-starter-parent，跳转到了spring-boot-starter-parent的pom.xml，xml配置如下（只摘抄了部分重点配置）：\n\n```xml\n<parent>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-dependencies</artifactId>\n  <version>2.0.1.RELEASE</version>\n  <relativePath>../../spring-boot-dependencies</relativePath>\n</parent>\n```\n\n按住Ctrl点击pom.xml中的spring-boot-starter-dependencies，跳转到了spring-boot-starter-dependencies的pom.xml，xml配置如下（只摘抄了部分重点配置）：\n\n```xml\n<properties>\n  \t<activemq.version>5.15.3</activemq.version>\n  \t<antlr2.version>2.7.7</antlr2.version>\n  \t<appengine-sdk.version>1.9.63</appengine-sdk.version>\n  \t<artemis.version>2.4.0</artemis.version>\n  \t<aspectj.version>1.8.13</aspectj.version>\n  \t<assertj.version>3.9.1</assertj.version>\n  \t<atomikos.version>4.0.6</atomikos.version>\n  \t<bitronix.version>2.1.4</bitronix.version>\n  \t<build-helper-maven-plugin.version>3.0.0</build-helper-maven-plugin.version>\n  \t<byte-buddy.version>1.7.11</byte-buddy.version>\n  \t... ... ...\n</properties>\n<dependencyManagement>\n  \t<dependencies>\n      \t<dependency>\n        \t<groupId>org.springframework.boot</groupId>\n        \t<artifactId>spring-boot</artifactId>\n        \t<version>2.0.1.RELEASE</version>\n      \t</dependency>\n      \t<dependency>\n        \t<groupId>org.springframework.boot</groupId>\n        \t<artifactId>spring-boot-test</artifactId>\n        \t<version>2.0.1.RELEASE</version>\n      \t</dependency>\n      \t... ... ...\n\t</dependencies>\n</dependencyManagement>\n<build>\n  \t<pluginManagement>\n    \t<plugins>\n      \t\t<plugin>\n        \t\t<groupId>org.jetbrains.kotlin</groupId>\n        \t\t<artifactId>kotlin-maven-plugin</artifactId>\n        \t\t<version>${kotlin.version}</version>\n      \t\t</plugin>\n      \t\t<plugin>\n        \t\t<groupId>org.jooq</groupId>\n        \t\t<artifactId>jooq-codegen-maven</artifactId>\n        \t\t<version>${jooq.version}</version>\n      \t\t</plugin>\n      \t\t<plugin>\n        \t\t<groupId>org.springframework.boot</groupId>\n        \t\t<artifactId>spring-boot-maven-plugin</artifactId>\n        \t\t<version>2.0.1.RELEASE</version>\n      \t\t</plugin>\n          \t... ... ...\n    \t</plugins>\n  \t</pluginManagement>\n</build>\n```\n\n从上面的spring-boot-starter-dependencies的pom.xml中我们可以发现，一部分坐标的版本、依赖管理、插件管理已经定义好，所以我们的SpringBoot工程继承spring-boot-starter-parent后已经具备版本锁定等配置了。所以起步依赖的作用就是进行依赖的传递。\n\n### 3.1.2 分析spring-boot-starter-web\n\n按住Ctrl点击pom.xml中的spring-boot-starter-web，跳转到了spring-boot-starter-web的pom.xml，xml配置如下（只摘抄了部分重点配置）：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  \t<modelVersion>4.0.0</modelVersion>\n  \t<parent>\n    \t<groupId>org.springframework.boot</groupId>\n    \t<artifactId>spring-boot-starters</artifactId>\n    \t<version>2.0.1.RELEASE</version>\n  \t</parent>\n  \t<groupId>org.springframework.boot</groupId>\n  \t<artifactId>spring-boot-starter-web</artifactId>\n  \t<version>2.0.1.RELEASE</version>\n  \t<name>Spring Boot Web Starter</name>\n  \n  \t<dependencies>\n    \t<dependency>\n      \t\t<groupId>org.springframework.boot</groupId>\n      \t\t<artifactId>spring-boot-starter</artifactId>\n      \t\t<version>2.0.1.RELEASE</version>\n      \t\t<scope>compile</scope>\n    \t</dependency>\n    \t<dependency>\n      \t\t<groupId>org.springframework.boot</groupId>\n      \t\t<artifactId>spring-boot-starter-json</artifactId>\n      \t\t<version>2.0.1.RELEASE</version>\n      \t\t<scope>compile</scope>\n    \t</dependency>\n    \t<dependency>\n      \t\t<groupId>org.springframework.boot</groupId>\n      \t\t<artifactId>spring-boot-starter-tomcat</artifactId>\n      \t\t<version>2.0.1.RELEASE</version>\n      \t\t<scope>compile</scope>\n    \t</dependency>\n    \t<dependency>\n      \t\t<groupId>org.hibernate.validator</groupId>\n      \t\t<artifactId>hibernate-validator</artifactId>\n      \t\t<version>6.0.9.Final</version>\n      \t\t<scope>compile</scope>\n    \t</dependency>\n    \t<dependency>\n      \t\t<groupId>org.springframework</groupId>\n      \t\t<artifactId>spring-web</artifactId>\n      \t\t<version>5.0.5.RELEASE</version>\n      \t\t<scope>compile</scope>\n    \t</dependency>\n    \t<dependency>\n      \t\t<groupId>org.springframework</groupId>\n      \t\t<artifactId>spring-webmvc</artifactId>\n      \t\t<version>5.0.5.RELEASE</version>\n      \t\t<scope>compile</scope>\n    \t</dependency>\n  \t</dependencies>\n</project>\n\n```\n\n从上面的spring-boot-starter-web的pom.xml中我们可以发现，spring-boot-starter-web就是将web开发要使用的spring-web、spring-webmvc等坐标进行了“打包”，这样我们的工程只要引入spring-boot-starter-web起步依赖的坐标就可以进行web开发了，同样体现了依赖传递的作用。\n\n\n\n## 3.2 自动配置原理解析\n\n按住Ctrl点击查看启动类MySpringBootApplication上的注解@SpringBootApplication\n\n```java\n@SpringBootApplication\npublic class MySpringBootApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MySpringBootApplication.class);\n    }\n}\n```\n\n注解@SpringBootApplication的源码\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = {\n\t\t@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n\n\t/**\n\t * Exclude specific auto-configuration classes such that they will never be applied.\n\t * @return the classes to exclude\n\t */\n\t@AliasFor(annotation = EnableAutoConfiguration.class)\n\tClass<?>[] exclude() default {};\n\n\t... ... ...\n\n}\n```\n\n其中，\n\n@SpringBootConfiguration：等同与@Configuration，既标注该类是Spring的一个配置类\n\n@EnableAutoConfiguration：SpringBoot自动配置功能开启\n\n按住Ctrl点击查看注解@EnableAutoConfiguration\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(AutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n\t... ... ...\n}\n```\n\n其中，@Import(AutoConfigurationImportSelector.class) 导入了AutoConfigurationImportSelector类\n\n按住Ctrl点击查看AutoConfigurationImportSelector源码\n\n```java\npublic String[] selectImports(AnnotationMetadata annotationMetadata) {\n        ... ... ...\n        List<String> configurations = getCandidateConfigurations(annotationMetadata,\n                                                                   attributes);\n        configurations = removeDuplicates(configurations);\n        Set<String> exclusions = getExclusions(annotationMetadata, attributes);\n        checkExcludedClasses(configurations, exclusions);\n        configurations.removeAll(exclusions);\n        configurations = filter(configurations, autoConfigurationMetadata);\n        fireAutoConfigurationImportEvents(configurations, exclusions);\n        return StringUtils.toStringArray(configurations);\n}\n\n\nprotected List<String> getCandidateConfigurations(AnnotationMetadata metadata,\n\t\t\tAnnotationAttributes attributes) {\n\t\tList<String> configurations = SpringFactoriesLoader.loadFactoryNames(\n\t\t\t\tgetSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());\n\t\t\n\t\treturn configurations;\n}\n\n```\n\n其中，SpringFactoriesLoader.loadFactoryNames 方法的作用就是从META-INF/spring.factories文件中读取指定类对应的类名称列表 \n\n![](https://img-blog.csdnimg.cn/20200217131004745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\nspring.factories 文件中有关自动配置的配置信息如下：\n\n```\n... ... ...\n\norg.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\\n\n... ... ...\n```\n\n上面配置文件存在大量的以Configuration为结尾的类名称，这些类就是存有自动配置信息的类，而SpringApplication在获取这些类名后再加载\n\n我们以ServletWebServerFactoryAutoConfiguration为例来分析源码：\n\n```java\n@Configuration\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)\n@ConditionalOnClass(ServletRequest.class)\n@ConditionalOnWebApplication(type = Type.SERVLET)\n@EnableConfigurationProperties(ServerProperties.class)\n@Import({ ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,\n\t\tServletWebServerFactoryConfiguration.EmbeddedTomcat.class,\n\t\tServletWebServerFactoryConfiguration.EmbeddedJetty.class,\n\t\tServletWebServerFactoryConfiguration.EmbeddedUndertow.class })\npublic class ServletWebServerFactoryAutoConfiguration {\n\t... ... ...\n}\n\n```\n\n其中，\n\n@EnableConfigurationProperties(ServerProperties.class) 代表加载ServerProperties服务器配置属性类\n\n进入ServerProperties.class源码如下：\n\n```java\n@ConfigurationProperties(prefix = \"server\", ignoreUnknownFields = true)\npublic class ServerProperties {\n\n\t/**\n\t * Server HTTP port.\n\t */\n\tprivate Integer port;\n\n\t/**\n\t * Network address to which the server should bind.\n\t */\n\tprivate InetAddress address;\n  \n  \t... ... ...\n  \n}\n```\n\n其中，\n\nprefix = \"server\" 表示SpringBoot配置文件中的前缀，SpringBoot会将配置文件中以server开始的属性映射到该类的字段中。映射关系如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217131033435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n\n# 四、SpringBoot的配置文件\n\n## 4.1 SpringBoot配置文件类型\n\n### 4.1.1 SpringBoot配置文件类型和作用\n\nSpringBoot是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用application.properties或者application.yml（application.yaml）进行配置。\n\nSpringBoot默认会从Resources目录下加载application.properties或application.yml（application.yaml）文件\n\n其中，application.properties文件是键值对类型的文件，之前一直在使用，所以此处不在对properties文件的格式进行阐述。除了properties文件外，SpringBoot还可以使用yml文件进行配置，下面对yml文件进行讲解。\n\n### 4.1.2 application.yml配置文件\n\n#### 4.1.2.1 yml配置文件简介\n\nYML文件格式是YAML (YAML Aint Markup Language)编写的文件格式，YAML是一种直观的能够被电脑识别的的数据数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，比如： C/C++, Ruby, Python, Java, Perl, C#, PHP等。YML文件是以数据为核心的，比传统的xml方式更加简洁。\n\nYML文件的扩展名可以使用.yml或者.yaml。\n\n#### 4.1.2.2 yml配置文件的语法\n\n##### 4.1.2.2.1 配置普通数据\n\n- 语法： key: value\n\n- 示例代码：\n\n- ```yaml\n  name: haohao\n  ```\n\n- 注意：value之前有一个空格\n\n##### 4.1.2.2.2 配置对象数据\n\n- 语法： \n\n  ​\tkey: \n\n  ​\t\tkey1: value1\n\n  ​\t\tkey2: value2\n\n  ​\t或者：\n\n  ​\tkey: {key1: value1,key2: value2}\n\n- 示例代码：\n\n- ```yaml\n  person:\n    name: haohao\n    age: 31\n    addr: beijing\n\n  #或者\n\n  person: {name: haohao,age: 31,addr: beijing}\n  ```\n\n- 注意：key1前面的空格个数不限定，在yml语法中，相同缩进代表同一个级别\n\n##### 4.1.2.2.2 配置Map数据 \n\n同上面的对象写法\n\n##### 4.1.2.2.3 配置数组（List、Set）数据\n\n- 语法： \n\n  ​\tkey: \n\n  ​\t\t- value1\n\n  ​\t\t- value2\n\n  或者：\n\n  ​\tkey: [value1,value2]\n\n- 示例代码：\n\n- ```yaml\n  city:\n    - beijing\n    - tianjin\n    - shanghai\n    - chongqing\n    \n  #或者\n\n  city: [beijing,tianjin,shanghai,chongqing]\n\n  #集合中的元素是对象形式\n  student:\n    - name: zhangsan\n      age: 18\n      score: 100\n    - name: lisi\n      age: 28\n      score: 88\n    - name: wangwu\n      age: 38\n      score: 90\n  ```\n\n- **注意：value1与之间的 - 之间存在一个空格**\n\n### 4.1.3 SpringBoot配置信息的查询\n\n上面提及过，SpringBoot的配置文件，主要的目的就是对配置信息进行修改的，但在配置时的key从哪里去查询呢？我们可以查阅SpringBoot的官方文档\n\n文档URL：https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#common-application-properties\n\n常用的配置摘抄如下：\n\n```properties\n# QUARTZ SCHEDULER (QuartzProperties)\nspring.quartz.jdbc.initialize-schema=embedded # Database schema initialization mode.\nspring.quartz.jdbc.schema=classpath:org/quartz/impl/jdbcjobstore/tables_@@platform@@.sql # Path to the SQL file to use to initialize the database schema.\nspring.quartz.job-store-type=memory # Quartz job store type.\nspring.quartz.properties.*= # Additional Quartz Scheduler properties.\n\n# ----------------------------------------\n# WEB PROPERTIES\n# ----------------------------------------\n\n# EMBEDDED SERVER CONFIGURATION (ServerProperties)\nserver.port=8080 # Server HTTP port.\nserver.servlet.context-path= # Context path of the application.\nserver.servlet.path=/ # Path of the main dispatcher servlet.\n\n# HTTP encoding (HttpEncodingProperties)\nspring.http.encoding.charset=UTF-8 # Charset of HTTP requests and responses. Added to the \"Content-Type\" header if not set explicitly.\n\n# JACKSON (JacksonProperties)\nspring.jackson.date-format= # Date format string or a fully-qualified date format class name. For instance, `yyyy-MM-dd HH:mm:ss`.\n\n# SPRING MVC (WebMvcProperties)\nspring.mvc.servlet.load-on-startup=-1 # Load on startup priority of the dispatcher servlet.\nspring.mvc.static-path-pattern=/** # Path pattern used for static resources.\nspring.mvc.view.prefix= # Spring MVC view prefix.\nspring.mvc.view.suffix= # Spring MVC view suffix.\n\n# DATASOURCE (DataSourceAutoConfiguration & DataSourceProperties)\nspring.datasource.driver-class-name= # Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.\nspring.datasource.password= # Login password of the database.\nspring.datasource.url= # JDBC URL of the database.\nspring.datasource.username= # Login username of the database.\n\n# JEST (Elasticsearch HTTP client) (JestProperties)\nspring.elasticsearch.jest.password= # Login password.\nspring.elasticsearch.jest.proxy.host= # Proxy host the HTTP client should use.\nspring.elasticsearch.jest.proxy.port= # Proxy port the HTTP client should use.\nspring.elasticsearch.jest.read-timeout=3s # Read timeout.\nspring.elasticsearch.jest.username= # Login username.\n\n```\n\n我们可以通过配置application.poperties 或者 application.yml 来修改SpringBoot的默认配置\n\n例如：\n\napplication.properties文件\n\n```properties\nserver.port=8888\nserver.servlet.context-path=demo\n```\n\napplication.yml文件\n\n```yaml\nserver:\n  port: 8888\n  servlet:\n    context-path: /demo\n```\n\n\n\n## 4.2 配置文件与配置类的属性映射方式\n\n### 4.2.1 使用注解@Value映射\n\n我们可以通过@Value注解将配置文件中的值映射到一个Spring管理的Bean的字段上\n\n例如：\n\napplication.properties配置如下：\n\n```properties\nperson:\n  name: zhangsan\n  age: 18\n```\n\n或者，application.yml配置如下：\n\n```yaml\nperson:\n  name: zhangsan\n  age: 18\n```\n\n实体Bean代码如下：\n\n```java\n@Controller\npublic class QuickStartController {\n\n    @Value(\"${person.name}\")\n    private String name;\n    @Value(\"${person.age}\")\n    private Integer age;\n\n\n    @RequestMapping(\"/quick\")\n    @ResponseBody\n    public String quick(){\n        return \"springboot 访问成功! name=\"+name+\",age=\"+age;\n    }\n\n}\n```\n\n浏览器访问地址：http://localhost:8080/quick 结果如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217131112756.png)\n\n\n### 4.2.2 使用注解@ConfigurationProperties映射\n\n通过注解@ConfigurationProperties(prefix=\"配置文件中的key的前缀\")可以将配置文件中的配置自动与实体进行映射\n\napplication.properties配置如下：\n\n```properties\nperson:\n  name: zhangsan\n  age: 18\n```\n\n或者，application.yml配置如下：\n\n```yaml\nperson:\n  name: zhangsan\n  age: 18\n```\n\n实体Bean代码如下：\n\n```java\n@Controller\n@ConfigurationProperties(prefix = \"person\")\npublic class QuickStartController {\n\n    private String name;\n    private Integer age;\n\n    @RequestMapping(\"/quick\")\n    @ResponseBody\n    public String quick(){\n        return \"springboot 访问成功! name=\"+name+\",age=\"+age;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n}\n```\n\n浏览器访问地址：http://localhost:8080/quick 结果如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217131119731.png)\n注意：使用@ConfigurationProperties方式可以进行配置文件与实体字段的自动映射，但需要字段必须提供set方法才可以，而使用@Value注解修饰的字段不需要提供set方法\n\n\n\n# 五、SpringBoot与整合其他技术\n\n## 5.1 SpringBoot整合Mybatis\n\n### 5.1.1 添加Mybatis的起步依赖\n\n```xml\n<!--mybatis起步依赖-->\n<dependency>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>1.1.1</version>\n</dependency>\n```\n\n### 5.1.2 添加数据库驱动坐标\n\n```xml\n<!-- MySQL连接驱动 -->\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n</dependency>\n```\n\n### 5.1.3 添加数据库连接信息\n\n在application.properties中添加数据量的连接信息\n\n```properties\n#DB Configuration:\nspring.datasource.driverClassName=com.mysql.jdbc.Driver\nspring.datasource.url=jdbc:mysql://127.0.0.1:3306/testuseUnicode=true&characterEncoding=utf8\nspring.datasource.username=root\nspring.datasource.password=root\n```\n\n### 5.1.4 创建user表\n\n在test数据库中创建user表\n\n```sql\n-- ----------------------------\n-- Table structure for `user`\n-- ----------------------------\nDROP TABLE IF EXISTS `user`;\nCREATE TABLE `user` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(50) DEFAULT NULL,\n  `password` varchar(50) DEFAULT NULL,\n  `name` varchar(50) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;\n\n-- ----------------------------\n-- Records of user\n-- ----------------------------\nINSERT INTO `user` VALUES ('1', 'zhangsan', '123', '张三');\nINSERT INTO `user` VALUES ('2', 'lisi', '123', '李四');\n```\n\n### 5.1.5 创建实体Bean\n\n```java\npublic class User {\n    // 主键\n    private Long id;\n    // 用户名\n    private String username;\n    // 密码\n    private String password;\n    // 姓名\n    private String name;\n  \n    //此处省略getter和setter方法 .. ..\n    \n}\n```\n\n### 5.1.6 编写Mapper\n\n```java\n@Mapper\npublic interface UserMapper {\n\tpublic List<User> queryUserList();\n}\n```\n\n注意：@Mapper标记该类是一个mybatis的mapper接口，可以被spring boot自动扫描到spring上下文中\n\n### 5.1.7 配置Mapper映射文件\n\n在src\\main\\resources\\mapper路径下加入UserMapper.xml配置文件\"\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.itheima.mapper.UserMapper\">\n    <select id=\"queryUserList\" resultType=\"user\">\n        select * from user\n    </select>\n</mapper>\n```\n\n### 5.1.8 在application.properties中添加mybatis的信息\n\n```properties\n#spring集成Mybatis环境\n#pojo别名扫描包\nmybatis.type-aliases-package=com.itheima.domain\n#加载Mybatis映射文件\nmybatis.mapper-locations=classpath:mapper/*Mapper.xml\n```\n\n### 5.1.9 编写测试Controller\n\n```java\n@Controller\npublic class MapperController {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @RequestMapping(\"/queryUser\")\n    @ResponseBody\n    public List<User> queryUser(){\n        List<User> users = userMapper.queryUserList();\n        return users;\n    }\n\n}\n```\n\n### 5.1.10 测试\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217131128548.png)\n\n## 5.2 SpringBoot整合Junit\n\n### 5.2.1 添加Junit的起步依赖\n\n```xml\n<!--测试的起步依赖-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-test</artifactId>\n    <scope>test</scope>\n</dependency>\n```\n\n### 5.2.2 编写测试类\n\n```java\npackage com.itheima.test;\n\nimport com.itheima.MySpringBootApplication;\nimport com.itheima.domain.User;\nimport com.itheima.mapper.UserMapper;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\n\nimport java.util.List;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = MySpringBootApplication.class)\npublic class MapperTest {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Test\n    public void test() {\n        List<User> users = userMapper.queryUserList();\n        System.out.println(users);\n    }\n\n}\n```\n\n其中，\n\nSpringRunner继承自SpringJUnit4ClassRunner，使用哪一个Spring提供的测试测试引擎都可以\n\n```java\npublic final class SpringRunner extends SpringJUnit4ClassRunner \n```\n\n@SpringBootTest的属性指定的是引导类的字节码对象\n\n\n\n### 5.2.3 控制台打印信息\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217131137297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n\n\n\n## 5.3 SpringBoot整合Spring Data JPA\n\n### 5.3.1 添加Spring Data JPA的起步依赖\n\n```xml\n<!-- springBoot JPA的起步依赖 -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n```\n\n### 5.3.2 添加数据库驱动依赖\n\n```xml\n<!-- MySQL连接驱动 -->\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n</dependency>\n```\n\n### 5.3.3 在application.properties中配置数据库和jpa的相关属性\n\n```properties\n#DB Configuration:\nspring.datasource.driverClassName=com.mysql.jdbc.Driver\nspring.datasource.url=jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&characterEncoding=utf8\nspring.datasource.username=root\nspring.datasource.password=root\n\n#JPA Configuration:\nspring.jpa.database=MySQL\nspring.jpa.show-sql=true\nspring.jpa.generate-ddl=true\nspring.jpa.hibernate.ddl-auto=update\nspring.jpa.hibernate.naming_strategy=org.hibernate.cfg.ImprovedNamingStrategy\n```\n\n### 5.3.4 创建实体配置实体\n\n```java\n@Entity\npublic class User {\n    // 主键\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    // 用户名\n    private String username;\n    // 密码\n    private String password;\n    // 姓名\n    private String name;\n \n    //此处省略setter和getter方法... ...\n}\n```\n\n### 5.3.5 编写UserRepository\n\n```java\npublic interface UserRepository extends JpaRepository<User,Long>{\n    // JpaRepository<User,Long>，Long为主键类型\n    public List<User> findAll();\n}\n```\n\n### 5.3.6 编写测试类\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes=MySpringBootApplication.class)\npublic class JpaTest {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Test\n    public void test(){\n        List<User> users = userRepository.findAll();\n        System.out.println(users);\n    }\n\n}\n```\n\n### 5.3.7 控制台打印信息\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217131142872.png)\n\n注意：如果是jdk9，执行报错如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217131202862.png)\n\n**原因：jdk缺少相应的jar**\n\n解决方案：手动导入对应的maven坐标，如下：\n\n```xml\n<!--jdk9需要导入如下坐标-->\n<dependency>\n    <groupId>javax.xml.bind</groupId>\n    <artifactId>jaxb-api</artifactId>\n    <version>2.3.0</version>\n</dependency>\n```\n\n\n\n## 5.4 SpringBoot整合Redis\n\n### 5.4.1 添加redis的起步依赖\n\n```xml\n<!-- 配置使用redis启动器 -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n\n### 5.4.2 配置redis的连接信息\n\n```properties\n#Redis\nspring.redis.host=127.0.0.1\nspring.redis.port=6379\n```\n\n### 5.4.3 注入RedisTemplate测试redis操作\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = SpringbootJpaApplication.class)\npublic class RedisTest {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Autowired\n    private RedisTemplate<String, String> redisTemplate;\n\n    @Test\n    public void test() throws JsonProcessingException {\n        //从redis缓存中获得指定的数据\n        String userListData = redisTemplate.boundValueOps(\"user.findAll\").get();\n        //如果redis中没有数据的话\n        if(null==userListData){\n            //查询数据库获得数据\n            List<User> all = userRepository.findAll();\n            //转换成json格式字符串\n            ObjectMapper om = new ObjectMapper();\n            userListData = om.writeValueAsString(all);\n            //将数据存储到redis中，下次在查询直接从redis中获得数据，不用在查询数据库\n            redisTemplate.boundValueOps(\"user.findAll\").set(userListData);\n            System.out.println(\"===============从数据库获得数据===============\");\n        }else{\n            System.out.println(\"===============从redis缓存中获得数据===============\");\n        }\n\n        System.out.println(userListData);\n\n    }\n\n}\n```\n\n","tags":["Java","SpringBoot"],"categories":["MyTech","Java"]},{"title":"SpringBoot经典学习笔记","url":"/posts/4277508012/","content":"@[toc]\n# 导读：课程概览\n\n## 1. Spring Boot是什么\n<!-- more -->\n我们知道，从 2002 年开始，Spring 一直在飞速的发展，如今已经成为了在Java EE（Java Enterprise Edition）开发中真正意义上的标准，但是随着技术的发展，Java EE使用 Spring 逐渐变得笨重起来，大量的 XML 文件存在于项目之中。**繁琐的配置，整合第三方框架的配置问题，导致了开发和部署效率的降低**。  \n\n2012 年 10 月，Mike Youngstrom 在 Spring jira 中创建了一个功能请求，要求**在 Spring 框架中支持无容器 Web 应用程序体系结构**。他谈到了在主容器引导 spring 容器内配置 Web 容器服务。这是 jira 请求的摘录：\n\n> 我认为 Spring 的 Web 应用体系结构可以大大简化，如果它提供了从上到下利用 Spring 组件和配置模型的工具和参考体系结构。在简单的 `main()`方法引导的 Spring 容器内嵌入和统一这些常用Web 容器服务的配置。 \n\n这一要求促使了 2013 年初开始的 Spring Boot 项目的研发，到今天，Spring Boot 的版本已经到了 2.0.3 RELEASE。Spring Boot 并不是用来替代 Spring 的解决方案，而**是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具**。\n\n它集成了大量常用的第三方库配置，Spring Boot应用中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），大部分的 Spring Boot 应用都只需要非常少量的配置代码（基于 Java 的配置），开发者能够更加专注于业务逻辑。   \n\n## 2. 为什么学习Spring Boot\n\n### 2.1 从Spring官方来看\n\n我们打开 Spring 的[官方网站](http://spring.io/)，可以看到下图：  \n\n![Spring官网首图](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi85OGZkYTdmMC04NjU2LTExZTgtODY3NS01NTM3YTcwMWFlN2Q?x-oss-process=image/format,png)\n\n我们可以看到图中官方对 Spring Boot 的定位：*Build Anything*， Build任何东西。Spring Boot旨在尽可能快地启动和运行，并且只需最少的 Spring 前期配置。  同时我们也来看一下官方对后面两个的定位：  \n\nSpringCloud：*Coordinate Anything*，协调任何事情；\nSpringCloud Data Flow：*Connect everything*，连接任何东西。\n\n仔细品味一下，Spring 官网对 Spring Boot、SpringCloud 和 SpringCloud Data Flow三者定位的措辞非常有味道，同时也可以看出，Spring 官方对这三个技术非常重视，是现在以及今后学习的重点（SpringCloud 相关达人课课程届时也会上线）。\n\n### 2.2 从Spring Boot的优点来看\n\nSpring Boot 有哪些优点？主要给我们解决了哪些问题呢？我们以下图来说明：\n\n![Spring Boot的优点](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi9lMTdiOGM0MC04NjU2LTExZTgtOGE5MS1kNzBiYzJkODQ3YzU?x-oss-process=image/format,png)\n\n#### 2.2.1 良好的基因\n\nSpring Boot 是伴随着 Spring 4.0 诞生的，从字面理解，Boot是引导的意思，因此 Spring Boot 旨在帮助开发者快速搭建 Spring 框架。Spring Boot 继承了原有 Spring 框架的优秀基因，使 Spring 在使用中更加方便快捷。\n\n![Spring Boot与Spring](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi8wMDA3ODY1MC04NjU3LTExZTgtODdkZS1kOTEwYTNlZTA4N2U?x-oss-process=image/format,png)\n\n#### 2.2.2 简化编码\n\n举个例子，比如我们要创建一个 web 项目，使用 Spring 的朋友都知道，在使用 Spring 的时候，需要在 pom 文件中添加多个依赖，而 Spring Boot 则会帮助开发着快速启动一个 web 容器，在 Spring Boot 中，我们只需要在 pom 文件中添加如下一个 starter-web 依赖即可。\n\n```xml\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n我们点击进入该依赖后可以看到，Spring Boot 这个 starter-web 已经包含了多个依赖，包括之前在 Spring 工程中需要导入的依赖，我们看一下其中的一部分，如下：\n\n```xml\n<!-- .....省略其他依赖 -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-web</artifactId>\n    <version>5.0.7.RELEASE</version>\n    <scope>compile</scope>\n</dependency>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.0.7.RELEASE</version>\n    <scope>compile</scope>\n</dependency>\n```\n由此可以看出，Spring Boot 大大简化了我们的编码，我们不用一个个导入依赖，直接一个依赖即可。\n\n#### 2.2.3 简化配置\n\nSpring 虽然使Java EE轻量级框架，但由于其繁琐的配置，一度被人认为是“配置地狱”。各种XML、Annotation配置会让人眼花缭乱，而且配置多的话，如果出错了也很难找出原因。Spring Boot更多的是采用 Java Config 的方式，对 Spring 进行配置。举个例子：\n\n我新建一个类，但是我不用 `@Service`注解，也就是说，它是个普通的类，那么我们如何使它也成为一个 Bean 让 Spring 去管理呢？只需要`@Configuration` 和`@Bean`两个注解即可，如下：\n```java\npublic class TestService {\n    public String sayHello () {\n        return \"Hello Spring Boot!\";\n    }\n}\n```\n```java\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class JavaConfig {\n    @Bean\n    public TestService getTestService() {\n        return new TestService();\n    }\n}\n```\n`@Configuration`表示该类是个配置类，`@Bean`表示该方法返回一个 Bean。这样就把`TestService`作为 Bean 让 Spring 去管理了，在其他地方，我们如果需要使用该 Bean，和原来一样，直接使用`@Resource`注解注入进来即可使用，非常方便。\n```java\n@Resource\nprivate TestService testService;\n```\n\n另外，部署配置方面，原来 Spring 有多个 xml 和 properties配置，在 Spring Boot 中只需要个 application.yml即可。\n\n#### 2.2.4 简化部署\n\n在使用 Spring 时，项目部署时需要我们在服务器上部署 tomcat，然后把项目打成 war 包扔到 tomcat里，在使用 Spring Boot 后，我们不需要在服务器上去部署 tomcat，因为 Spring Boot 内嵌了 tomcat，我们只需要将项目打成 jar 包，使用 `java -jar xxx.jar`一键式启动项目。\n\n另外，也降低对运行环境的基本要求，环境变量中有JDK即可。\n\n#### 2.2.5 简化监控\n\n我们可以引入 spring-boot-start-actuator 依赖，直接使用 REST 方式来获取进程的运行期性能参数，从而达到监控的目的，比较方便。但是 Spring Boot 只是个微框架，没有提供相应的服务发现与注册的配套功能，没有外围监控集成方案，没有外围安全管理方案，所以在微服务架构中，还需要 Spring Cloud 来配合一起使用。\n\n### 2.3 从未来发展的趋势来看\n\n微服务是未来发展的趋势，项目会从传统架构慢慢转向微服务架构，因为微服务可以使不同的团队专注于更小范围的工作职责、使用独立的技术、更安全更频繁地部署。而 继承了 Spring 的优良特性，与 Spring 一脉相承，而且 支持各种REST API 的实现方式。Spring Boot 也是官方大力推荐的技术，可以看出，Spring Boot 是未来发展的一个大趋势。\n\n## 3. 本课程能学到什么\n\n本课程使用目前 Spring Boot 最新版本2.0.3 RELEASE，课程文章均为作者在实际项目中剥离出来的场景和demo，目标是带领学习者快速上手 Spring Boot，将 Spring Boot 相关技术点快速运用在微服务项目中。全篇分为两部分：基础篇和进阶篇。  \n\n基础篇（01—10课）主要介绍 Spring Boot 在项目中最常使用的一些功能点，旨在带领学习者快速掌握 Spring Boot 在开发时需要的知识点，能够把 Spring Boot 相关技术运用到实际项目架构中去。该部分以 Spring Boot 框架为主线，内容包括Json数据封装、日志记录、属性配置、MVC支持、在线文档、模板引擎、异常处理、AOP 处理、持久层集成等等。  \n\n进阶篇（11—17课）主要是介绍 Spring Boot 在项目中拔高一些的技术点，包括集成的一些组件，旨在带领学习者在项目中遇到具体的场景时能够快速集成，完成对应的功能。该部分以 Spring Boot 框架为主线，内容包括拦截器、监听器、缓存、安全认证、分词插件、消息队列等等。  \n\n认真读完该系列文章之后，学习者会快速了解并掌握 Spring Boot 在项目中最常用的技术点，作者课程的最后，会基于课程内容搭建一个 Spring Boot 项目的空架构，该架构也是从实际项目中剥离出来，学习者可以运用该架构于实际项目中，具备使用 Spring Boot 进行实际项目开发的能力。  \n\n课程所有源码提供免费下载：[下载地址](https://gitee.com/eson15/springboot_study)。\n\n\n\n\n\n## 4. 适合阅读的人群\n\n本课程适合以下人群阅读：\n* 有一定的Java语言基础，了解Spring、Maven的在校学生或自学者\n* 有传统项目经验，想往微服务方向发展的工作人员\n* 热衷于新技术并对 Spring Boot 感兴趣的人员\n* 希望了解 Spring Boot 2.0.3 的研究人员\n## 5. 本课程开发环境和插件\n\n本课程的开发环境：\n* 开发工具：IDEA 2017\n* JDK版本： JDK 1.8\n* Spring Boot版本：2.0.3 RELEASE\n* Maven版本：3.5.2\n\n涉及到的插件：\n* FastJson\n* Swagger2\n* Thymeleaf\n* MyBatis\n* Redis\n* ActiveMQ\n* Shiro\n* Lucence\n\n\n## 6. 课程目录\n\n* 导读：课程概览\n* 第01课：Spring Boot开发环境搭建和项目启动\n* 第02课：Spring Boot返回Json数据及数据封装\n* 第03课：Spring Boot使用slf4j进行日志记录\n* 第04课：Spring Boot中的项目属性配置\n* 第05课：Spring Boot中的MVC支持\n* 第06课：Spring Boot集成Swagger2展现在线接口文档\n* 第07课：Spring Boot集成Thymeleaf模板引擎\n* 第08课：Spring Boot中的全局异常处理\n* 第09课：Spring Boot中的切面AOP处理\n* 第10课：Spring Boot中集成MyBatis\n* 第11课：Spring Boot事务配置管理\n* 第12课：Spring Boot中使用监听器\n* 第13课：Spring Boot中使用拦截器\n* 第14课：Spring Boot中集成Redis\n* 第15课：Spring Boot中集成ActiveMQ\n* 第16课：Spring Boot中集成Shiro\n* 第17课：Spring Boot中结成Lucence\n* 第18课：Spring Boot搭建实际项目开发中的架构\n\n>欢迎关注我的为微信公众号：武哥聊编程\n\n\n\n# 第01课：Spring Boot开发环境搭建和项目启动\n\n上一节对 SpringBoot 的特性做了一个介绍，本节主要对 **jdk 的配置、Spring Boot工程的构建和项目的启动、Spring Boot 项目工程的结构做一下讲解和分析**。\n\n## 1. jdk 的配置\n\n本课程是使用 IDEA 进行开发，在IDEA 中配置 jdk 的方式很简单，打开`File->Project Structure`，如下图所：\n\n![IDEA中配置jdk](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi85YmVmZGU4MC04NjU5LTExZTgtOWIwZC05NWRlNDQ5ZGMxMDc?x-oss-process=image/format,png)\n\n1. 选择 SDKs\n2. 在 JDK home path 中选择本地 jdk 的安装目录\n3. 在 Name 中为 jdk 自定义名字\n\n通过以上三步骤，即可导入本地安装的 jdk。如果是使用 STS 或者 eclipse 的朋友，可以通过两步骤添加：\n* `window->preference->java->Instralled JRES`来添加本地 jdk。\n* `window-->preference-->java-->Compiler`选择 jre，和 jdk 保持一致。\n\n## 2. Spring Boot 工程的构建\n\n### 2.1 IDEA 快速构建\n\nIDEA 中可以通过`File->New->Project`来快速构建 Spring Boot 工程。如下，选择 Spring Initializr，在 Project SDK 中选择刚刚我们导入的 jdk，点击 Next，到了项目的配置信息。\n\n* Group：填企业域名，本课程使用com.itcodai\n* Artifact：填项目名称，本课程中每一课的工程名以`course+课号`命令，这里使用 course01\n* Dependencies：可以添加我们项目中所需要的依赖信息，根据实际情况来添加，本课程只需要选择 Web 即可。\n\n### 2.2 官方构建\n\n第二种方式可以通过官方构建，步骤如下：\n* 访问 http://start.spring.io/。\n* 在页面上输入相应的 Spring Boot 版本、Group 和 Artifact 信息以及项目依赖，然后创建项目。\n* ![创建Spring Boot工程](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi8wMTRhMWJhMC04NjViLTExZTgtOTU2ZS1mNTI4MTE0YjI4YmQ?x-oss-process=image/format,png)\n* 解压后，使用 IDEA 导入该 maven 工程：`File->New->Model from Existing Source`，然后选择解压后的项目文件夹即可。如果是使用 eclipse 的朋友，可以通过`Import->Existing Maven Projects->Next`，然后选择解压后的项目文件夹即可。\n\n### 2.3 maven配置\n\n创建了 Spring Boot 项目之后，需要进行 maven 配置。打开`File->settings`，搜索 maven，配置一下本地的 maven 信息。如下：\n\n![maven配置](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi8yZmY3YjkzMC04NjViLTExZTgtODY3NS01NTM3YTcwMWFlN2Q?x-oss-process=image/format,png)\n\n在 Maven home directory 中选择本地 Maven 的安装路径；在 User settings file 中选择本地 Maven 的配置文件所在路径。在配置文件中，我们配置一下国内阿里的镜像，这样在下载 maven 依赖时，速度很快。\n```xml\n<mirror>\n\t<id>nexus-aliyun</id>\n\t<mirrorOf>*</mirrorOf>\n\t<name>Nexus aliyun</name>\n\t<url>http://maven.aliyun.com/nexus/content/groups/public</url>\n</mirror>\n```\n如果是使用 eclipse 的朋友，可以通过`window-->preference-->Maven-->User Settings`来配置，配置方式和上面一致。\n\n### 2.4 编码配置\n\n同样地，新建项目后，我们一般都需要配置编码，这点非常重要，很多初学者都会忘记这一步，所以要养成良好的习惯。\n\nIDEA 中，仍然是打开`File->settings`，搜索 encoding，配置一下本地的编码信息。如下：\n\n![编码配置](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi81NzU2NGU2MC04NjViLTExZTgtOGE5MS1kNzBiYzJkODQ3YzU?x-oss-process=image/format,png)\n\n如果是使用 eclipse 的朋友，有两个地方需要设置一下编码：\n* window--> perferences-->General-->Workspace，将Text file encoding改成utf-8\n* window-->perferences-->General-->content types，选中Text，将Default encoding填入utf-8\n\nOK，编码设置完成即可启动项目工程了。\n\n## 3. Spring Boot 项目工程结构\n\nSpring Boot 项目总共有三个模块，如下图所示：\n\n![Spring Boot项目工程结构](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi84YjMyZmE4MC04NjViLTExZTgtOWQxMy0wM2VhNGI0ZDg1MDQ?x-oss-process=image/format,png)\n\n* src/main/java路径：主要编写业务程序\n* src/main/resources路径：存放静态文件和配置文件\n* src/test/java路径：主要编写测试程序\n\n默认情况下，如上图所示会创建一个启动类 Course01Application，该类上面有个`@SpringBootApplication`注解，该启动类中有个 main 方法，没错，Spring Boot 启动只要运行该 main 方法即可，非常方便。另外，Spring Boot 内部集成了 tomcat，不需要我们人为手动去配置 tomcat，开发者只需要关注具体的业务逻辑即可。\n\n到此为止，Spring Boot 就启动成功了，为了比较清楚的看到效果，我们写一个 Controller 来测试一下，如下：\n```java\npackage com.itcodai.course01.controller;\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/start\")\npublic class StartController {\n\n    @RequestMapping(\"/springboot\")\n    public String startSpringBoot() {\n        return \"Welcome to the world of Spring Boot!\";\n    }\n}\n```\n重新运行 main 方法启动项目，在浏览器中输入 `localhost:8080/start/springboot`，如果看到 `“Welcome to the world of Spring Boot!”`，那么恭喜你项目启动成功！Spring Boot 就是这么简单方便！端口号默认是8080，如果想要修改，可以在 application.yml 文件中使用 `server.port` 来人为指定端口，如8001端口：\n```xml\nserver:\n  port: 8001\n```\n\n## 4. 总结\n\n本节我们快速学习了如何在 IDEA 中导入 jdk，以及使用 IDEA 如何配置 maven 和编码，如何快速的创建和启动 Spring Boot 工程。IDEA 对 Spring Boot 的支持非常友好，建议大家使用 IDEA 进行 Spring Boot 的开发，从下一课开始，我们真正进入 Spring Boot 的学习中。\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n\n\n\n# 第02课：Spring Boot返回Json数据及数据封装\n\n在项目开发中，接口与接口之间，前后端之间数据的传输都使用 Json 格式，在 Spring Boot 中，接口返回 Json 格式的数据很简单，在 Controller 中使用`@RestController`注解即可返回 Json 格式的数据，`@RestController`也是 Spring Boot 新增的一个注解，我们点进去看一下该注解都包含了哪些东西。\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Controller\n@ResponseBody\npublic @interface RestController {\n    String value() default \"\";\n}\n```\n可以看出， `@RestController` 注解包含了原来的 `@Controller` 和 `@ResponseBody` 注解，使用过 Spring 的朋友对 `@Controller` 注解已经非常了解了，这里不再赘述， `@ResponseBody` 注解是将返回的数据结构转换为 Json 格式。所以在默认情况下，使用了 `@RestController` 注解即可将返回的数据结构转换成 Json 格式，Spring Boot 中默认使用的 Json 解析技术框架是 jackson。我们点开 pom.xml 中的 `spring-boot-starter-web` 依赖，可以看到一个 `spring-boot-starter-json` 依赖：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-json</artifactId>\n    <version>2.0.3.RELEASE</version>\n    <scope>compile</scope>\n</dependency>\n```\nSpring Boot 中对依赖都做了很好的封装，可以看到很多 `spring-boot-starter-xxx` 系列的依赖，这是 Spring Boot 的特点之一，不需要人为去引入很多相关的依赖了，starter-xxx 系列直接都包含了所必要的依赖，所以我们再次点进去上面这个 `spring-boot-starter-json` 依赖，可以看到：\n```xml\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.9.6</version>\n    <scope>compile</scope>\n</dependency>\n<dependency>\n    <groupId>com.fasterxml.jackson.datatype</groupId>\n    <artifactId>jackson-datatype-jdk8</artifactId>\n    <version>2.9.6</version>\n    <scope>compile</scope>\n</dependency>\n<dependency>\n    <groupId>com.fasterxml.jackson.datatype</groupId>\n    <artifactId>jackson-datatype-jsr310</artifactId>\n    <version>2.9.6</version>\n    <scope>compile</scope>\n</dependency>\n<dependency>\n    <groupId>com.fasterxml.jackson.module</groupId>\n    <artifactId>jackson-module-parameter-names</artifactId>\n    <version>2.9.6</version>\n    <scope>compile</scope>\n</dependency>\n```\n到此为止，我们知道了 Spring Boot 中默认使用的 json 解析框架是 jackson。下面我们看一下默认的 jackson 框架对常用数据类型的转 Json 处理。\n\n## 1. Spring Boot 默认对Json的处理\n\n在实际项目中，常用的数据结构无非有类对象、List对象、Map对象，我们看一下默认的 jackson 框架对这三个常用的数据结构转成 json 后的格式如何。\n\n### 1.1 创建 User 实体类\n\n为了测试，我们需要创建一个实体类，这里我们就用 User 来演示。\n```java\npublic class User {\n    private Long id;\n    private String username;\n    private String password;\n\t/* 省略get、set和带参构造方法 */\n}\n```\n### 1.2 创建Controller类\n\n然后我们创建一个 Controller，分别返回 `User`对象、`List<User>` 和 `Map<String, Object>`。\n```java\nimport com.itcodai.course02.entity.User;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@RestController\n@RequestMapping(\"/json\")\npublic class JsonController {\n\n    @RequestMapping(\"/user\")\n    public User getUser() {\n        return new User(1, \"倪升武\", \"123456\");\n    }\n\n    @RequestMapping(\"/list\")\n    public List<User> getUserList() {\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(1, \"倪升武\", \"123456\");\n        User user2 = new User(2, \"达人课\", \"123456\");\n        userList.add(user1);\n        userList.add(user2);\n        return userList;\n    }\n\n    @RequestMapping(\"/map\")\n    public Map<String, Object> getMap() {\n        Map<String, Object> map = new HashMap<>(3);\n        User user = new User(1, \"倪升武\", \"123456\");\n        map.put(\"作者信息\", user);\n        map.put(\"博客地址\", \"http://blog.itcodai.com\");\n        map.put(\"CSDN地址\", \"http://blog.csdn.net/eson_15\");\n        map.put(\"粉丝数量\", 4153);\n        return map;\n    }\n}\n```\n### 1.3 测试不同数据类型返回的json\n\nOK，写好了接口，分别返回了一个 User 对象、一个 List 集合和一个 Map 集合，其中 Map 集合中的 value 存的是不同的数据类型。接下来我们依次来测试一下效果。\n\n在浏览器中输入：`localhost:8080/json/user` 返回 json 如下：\n```json\n{\"id\":1,\"username\":\"倪升武\",\"password\":\"123456\"}\n```\n在浏览器中输入：`localhost:8080/json/list` 返回 json 如下：\n```json\n[{\"id\":1,\"username\":\"倪升武\",\"password\":\"123456\"},{\"id\":2,\"username\":\"达人课\",\"password\":\"123456\"}]\n```\n在浏览器中输入：`localhost:8080/json/map` 返回 json 如下：\n```json\n{\"作者信息\":{\"id\":1,\"username\":\"倪升武\",\"password\":\"123456\"},\"CSDN地址\":\"http://blog.csdn.net/eson_15\",\"粉丝数量\":4153,\"博客地址\":\"http://blog.itcodai.com\"}\n```\n可以看出，map 中不管是什么数据类型，都可以转成相应的 json 格式，这样就非常方便。\n\n### 1.4 jackson 中对null的处理\n\n在实际项目中，我们难免会遇到一些 null 值出现，我们转 json 时，是不希望有这些 null 出现的，比如我们期望所有的 null 在转 json 时都变成 \"\" 这种空字符串，那怎么做呢？在 Spring Boot 中，我们做一下配置即可，新建一个 jackson 的配置类：\n```java\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.JsonSerializer;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializerProvider;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;\n\nimport java.io.IOException;\n\n@Configuration\npublic class JacksonConfig {\n    @Bean\n    @Primary\n    @ConditionalOnMissingBean(ObjectMapper.class)\n    public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {\n        ObjectMapper objectMapper = builder.createXmlMapper(false).build();\n        objectMapper.getSerializerProvider().setNullValueSerializer(new JsonSerializer<Object>() {\n            @Override\n            public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {\n                jsonGenerator.writeString(\"\");\n            }\n        });\n        return objectMapper;\n    }\n}\n```\n\n然后我们修改一下上面返回 map 的接口，将几个值改成 null 测试一下：\n```java\n@RequestMapping(\"/map\")\npublic Map<String, Object> getMap() {\n    Map<String, Object> map = new HashMap<>(3);\n    User user = new User(1, \"倪升武\", null);\n    map.put(\"作者信息\", user);\n    map.put(\"博客地址\", \"http://blog.itcodai.com\");\n    map.put(\"CSDN地址\", null);\n    map.put(\"粉丝数量\", 4153);\n    return map;\n}\n```\n重启项目，再次输入：`localhost:8080/json/map`，可以看到 jackson 已经将所有 null 字段转成了空字符串了。\n```json\n{\"作者信息\":{\"id\":1,\"username\":\"倪升武\",\"password\":\"\"},\"CSDN地址\":\"\",\"粉丝数量\":4153,\"博客地址\":\"http://blog.itcodai.com\"}\n```\n\n\n## 2. 使用阿里巴巴FastJson的设置\n\n### 2.1 jackson 和 fastJson 的对比\n\n有很多朋友习惯于使用阿里巴巴的 fastJson 来做项目中 json 转换的相关工作，目前我们项目中使用的就是阿里的 fastJson，那么 jackson 和 fastJson 有哪些区别呢？根据网上公开的资料比较得到下表。\n| 选项 | fastJson | jackson |\n| :-: | :-: | :-: |\n| 上手难易程度 | 容易 | 中等 |\n| 高级特性支持 | 中等 | 丰富 |\n| 官方文档、Example支持 | 中文 | 英文 |\n| 处理json速度 | 略快 | 快 |\n\n关于 fastJson 和 jackson 的对比，网上有很多资料可以查看，主要是根据自己实际项目情况来选择合适的框架。从扩展上来看，fastJson 没有 jackson 灵活，从速度或者上手难度来看，fastJson 可以考虑，我们项目中目前使用的是阿里的 fastJson，挺方便的。\n\n### 2.2 fastJson依赖导入\n\n使用 fastJson 需要导入依赖，本课程使用 1.2.35 版本，依赖如下：\n```xml\n<dependency>\n\t<groupId>com.alibaba</groupId>\n\t<artifactId>fastjson</artifactId>\n\t<version>1.2.35</version>\n</dependency>\n```\n\n### 2.2 使用 fastJson 处理 null\n\n使用 fastJson 时，对 null 的处理和 jackson 有些不同，需要继承  `WebMvcConfigurationSupport` 类，然后覆盖 `configureMessageConverters` 方法，在方法中，我们可以选择对要实现 null 转换的场景，配置好即可。如下：\n\n\n```java\nimport com.alibaba.fastjson.serializer.SerializerFeature;\nimport com.alibaba.fastjson.support.config.FastJsonConfig;\nimport com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.converter.HttpMessageConverter;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Configuration\npublic class fastJsonConfig extends WebMvcConfigurationSupport {\n\n    /**\n     * 使用阿里 FastJson 作为JSON MessageConverter\n     * @param converters\n     */\n    @Override\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter();\n        FastJsonConfig config = new FastJsonConfig();\n        config.setSerializerFeatures(\n                // 保留map空的字段\n                SerializerFeature.WriteMapNullValue,\n                // 将String类型的null转成\"\"\n                SerializerFeature.WriteNullStringAsEmpty,\n                // 将Number类型的null转成0\n                SerializerFeature.WriteNullNumberAsZero,\n                // 将List类型的null转成[]\n                SerializerFeature.WriteNullListAsEmpty,\n                // 将Boolean类型的null转成false\n                SerializerFeature.WriteNullBooleanAsFalse,\n                // 避免循环引用\n                SerializerFeature.DisableCircularReferenceDetect);\n\n        converter.setFastJsonConfig(config);\n        converter.setDefaultCharset(Charset.forName(\"UTF-8\"));\n        List<MediaType> mediaTypeList = new ArrayList<>();\n        // 解决中文乱码问题，相当于在Controller上的@RequestMapping中加了个属性produces = \"application/json\"\n        mediaTypeList.add(MediaType.APPLICATION_JSON);\n        converter.setSupportedMediaTypes(mediaTypeList);\n        converters.add(converter);\n    }\n}\n```\n\n## 3. 封装统一返回的数据结构\n\n以上是 Spring Boot 返回 json 的几个代表的例子，但是在实际项目中，除了要封装数据之外，我们往往需要在返回的 json 中添加一些其他信息，比如返回一些状态码 code ，返回一些 msg 给调用者，这样调用者可以根据 code 或者 msg 做一些逻辑判断。所以在实际项目中，我们需要封装一个统一的 json 返回结构存储返回信息。 \n\n### 3.1 定义统一的 json 结构\n\n由于封装的 json 数据的类型不确定，所以在定义统一的 json 结构时，我们需要用到泛型。统一的 json 结构中属性包括数据、状态码、提示信息即可，构造方法可以根据实际业务需求做相应的添加即可，一般来说，应该有默认的返回结构，也应该有用户指定的返回结构。如下：\n```java\npublic class JsonResult<T> {\n\n    private T data;\n    private String code;\n    private String msg;\n\n    /**\n     * 若没有数据返回，默认状态码为0，提示信息为：操作成功！\n     */\n    public JsonResult() {\n        this.code = \"0\";\n        this.msg = \"操作成功！\";\n    }\n\n    /**\n     * 若没有数据返回，可以人为指定状态码和提示信息\n     * @param code\n     * @param msg\n     */\n    public JsonResult(String code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\n    /**\n     * 有数据返回时，状态码为0，默认提示信息为：操作成功！\n     * @param data\n     */\n    public JsonResult(T data) {\n        this.data = data;\n        this.code = \"0\";\n        this.msg = \"操作成功！\";\n    }\n\n    /**\n     * 有数据返回，状态码为0，人为指定提示信息\n     * @param data\n     * @param msg\n     */\n    public JsonResult(T data, String msg) {\n        this.data = data;\n        this.code = \"0\";\n        this.msg = msg;\n    }\n    // 省略get和set方法\n}\n```\n\n### 3.2 修改 Controller 中的返回值类型及测试\n\n由于 JsonResult 使用了泛型，所以所有的返回值类型都可以使用该统一结构，在具体的场景将泛型替换成具体的数据类型即可，非常方便，也便于维护。在实际项目中，还可以继续封装，比如状态码和提示信息可以定义一个枚举类型，以后我们只需要维护这个枚举类型中的数据即可（在本课程中就不展开了）。根据以上的 JsonResult，我们改写一下 Controller，如下：\n```java\n@RestController\n@RequestMapping(\"/jsonresult\")\npublic class JsonResultController {\n\n    @RequestMapping(\"/user\")\n    public JsonResult<User> getUser() {\n        User user = new User(1, \"倪升武\", \"123456\");\n        return new JsonResult<>(user);\n    }\n\n    @RequestMapping(\"/list\")\n    public JsonResult<List> getUserList() {\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(1, \"倪升武\", \"123456\");\n        User user2 = new User(2, \"达人课\", \"123456\");\n        userList.add(user1);\n        userList.add(user2);\n        return new JsonResult<>(userList, \"获取用户列表成功\");\n    }\n\n    @RequestMapping(\"/map\")\n    public JsonResult<Map> getMap() {\n        Map<String, Object> map = new HashMap<>(3);\n        User user = new User(1, \"倪升武\", null);\n        map.put(\"作者信息\", user);\n        map.put(\"博客地址\", \"http://blog.itcodai.com\");\n        map.put(\"CSDN地址\", null);\n        map.put(\"粉丝数量\", 4153);\n        return new JsonResult<>(map);\n    }\n}\n```\n我们重新在浏览器中输入：`localhost:8080/jsonresult/user` 返回 json 如下：\n```json\n{\"code\":\"0\",\"data\":{\"id\":1,\"password\":\"123456\",\"username\":\"倪升武\"},\"msg\":\"操作成功！\"}\n```\n输入：`localhost:8080/jsonresult/list`，返回 json 如下：\n```json\n{\"code\":\"0\",\"data\":[{\"id\":1,\"password\":\"123456\",\"username\":\"倪升武\"},{\"id\":2,\"password\":\"123456\",\"username\":\"达人课\"}],\"msg\":\"获取用户列表成功\"}\n```\n输入：`localhost:8080/jsonresult/map`，返回 json 如下：\n```json\n{\"code\":\"0\",\"data\":{\"作者信息\":{\"id\":1,\"password\":\"\",\"username\":\"倪升武\"},\"CSDN地址\":null,\"粉丝数量\":4153,\"博客地址\":\"http://blog.itcodai.com\"},\"msg\":\"操作成功！\"}\n```\n通过封装，我们不但将数据通过 json 传给前端或者其他接口，还带上了状态码和提示信息，这在实际项目场景中应用非常广泛。\n\n## 4. 总结\n\n本节主要对 Spring Boot 中 json 数据的返回做了详细的分析，从 Spring Boot 默认的 jackson 框架到阿里巴巴的 fastJson 框架，分别对它们的配置做了相应的讲解。另外，结合实际项目情况，总结了实际项目中使用的 json 封装结构体，加入了状态码和提示信息，使得返回的 json 数据信息更加完整。\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n\n\n# 第03课：Spring Boot使用slf4j进行日志记录\n\n在开发中，我们经常使用 `System.out.println()` 来打印一些信息，但是这样不好，因为大量的使用 `System.out` 会增加资源的消耗。我们实际项目中使用的是 slf4j 的 logback 来输出日志，效率挺高的，Spring Boot 提供了一套日志系统，logback 是最优的选择。\n\n## 1. slf4j 介绍\n\n引用百度百科里的一段话：\n> SLF4J，即简单日志门面（Simple Logging Facade for Java），不是具体的日志解决方案，它只服务于各种各样的日志系统。按照官方的说法，SLF4J是一个用于日志系统的简单Facade，允许最终用户在部署其应用时使用其所希望的日志系统。\n\n这段的大概意思是：你只需要按统一的方式写记录日志的代码，而无需关心日志是通过哪个日志系统，以什么风格输出的。因为它们取决于部署项目时绑定的日志系统。例如，在项目中使用了 slf4j 记录日志，并且绑定了 log4j（即导入相应的依赖），则日志会以 log4j 的风格输出；后期需要改为以 logback 的风格输出日志，只需要将 log4j 替换成 logback 即可，不用修改项目中的代码。这对于第三方组件的引入的不同日志系统来说几乎零学习成本，况且它的优点不仅仅这一个而已，还有简洁的占位符的使用和日志级别的判断。\n\n正因为 sfl4j 有如此多的优点，阿里巴巴已经将 slf4j 作为他们的日志框架了。在《阿里巴巴Java开发手册(正式版)》中，日志规约一项第一条就强制要求使用 slf4j：\n> 1.【强制】应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。\n\n“强制”两个字体现出了 slf4j 的优势，所以建议在实际项目中，使用 slf4j 作为自己的日志框架。使用 slf4j 记录日志非常简单，直接使用  LoggerFactory 创建即可。\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class Test {\n    private static final Logger logger = LoggerFactory.getLogger(Test.class);\n    // ……\n}\n```\n\n## 2. application.yml 中对日志的配置\n\nSpring Boot 对 slf4j 支持的很好，内部已经集成了 slf4j，一般我们在使用的时候，会对slf4j 做一下配置。`application.yml` 文件是 Spring Boot 中唯一一个需要配置的文件，一开始创建工程的时候是 `application.properties` 文件，个人比较细化用 yml 文件，因为 yml 文件的层次感特别好，看起来更直观，但是 yml 文件对格式要求比较高，比如英文冒号后面必须要有个空格，否则项目估计无法启动，而且也不报错。用 properties 还是 yml 视个人习惯而定，都可以。本课程使用 yml。\n\n我们看一下 application.yml 文件中对日志的配置：\n```xml\nlogging:\n  config: logback.xml\n  level:\n    com.itcodai.course03.dao: trace\n```\n`logging.config` 是用来指定项目启动的时候，读取哪个配置文件，这里指定的是日志配置文件是根路径下的 `logback.xml` 文件，关于日志的相关配置信息，都放在 `logback.xml` 文件中了。`logging.level` 是用来指定具体的 mapper 中日志的输出级别，上面的配置表示 `com.itcodai.course03.dao` 包下的所有 mapper 日志输出级别为 trace，会将操作数据库的 sql 打印出来，开发时设置成 trace 方便定位问题，在生产环境上，将这个日志级别再设置成 error 级别即可（本节课不讨论 mapper 层，在后面 Spring Boot 集成 MyBatis 时再详细讨论）。\n\n常用的日志级别按照从高到低依次为：ERROR、WARN、INFO、DEBUG。\n\n## 3. logback.xml 配置文件解析\n\n在上面 `application.yml` 文件中，我们指定了日志配置文件 `logback.xml`，`logback.xml` 文件中主要用来做日志的相关配置。在 `logback.xml` 中，我们可以定义日志输出的格式、路径、控制台输出格式、文件大小、保存时长等等。下面来分析一下：\n\n### 3.1 定义日志输出格式和存储路径\n\n```xml\n<configuration>\n\t<property name=\"LOG_PATTERN\" value=\"%date{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\" />\n\t<property name=\"FILE_PATH\" value=\"D:/logs/course03/demo.%d{yyyy-MM-dd}.%i.log\" />\n</configuration>\n```\n我们来看一下这个定义的含义：首先定义一个格式，命名为 “LOG_PATTERN”，该格式中 `%date` 表示日期，`%thread` 表示线程名，`%-5level` 表示级别从左显示5个字符宽度，`%logger{36}`  表示 logger 名字最长36个字符，`%msg` 表示日志消息，`%n` 是换行符。\n\n然后再定义一下名为 “FILE_PATH” 文件路径，日志都会存储在该路径下。`%i` 表示第 i 个文件，当日志文件达到指定大小时，会将日志生成到新的文件里，这里的 i 就是文件索引，日志文件允许的大小可以设置，下面会讲解。这里需要注意的是，不管是 windows 系统还是 Linux 系统，日志存储的路径必须要是绝对路径。\n\n### 3.2 定义控制台输出\n\n```xml\n<configuration>\n\t<appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\">\n\t\t<encoder>\n            <!-- 按照上面配置的LOG_PATTERN来打印日志 -->\n\t\t\t<pattern>${LOG_PATTERN}</pattern>\n\t\t</encoder>\n\t</appender>\n</configuration>\n```\n使用 `<appender>` 节点设置个控制台输出（`class=\"ch.qos.logback.core.ConsoleAppender\"`）的配置，定义为 “CONSOLE”。使用上面定义好的输出格式（LOG_PATTERN）来输出，使用 `${}` 引用进来即可。\n\n### 3.3 定义日志文件的相关参数\n\n```xml\n<configuration>\n\t<appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n\t\t<rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n\t\t\t<!-- 按照上面配置的FILE_PATH路径来保存日志 -->\n\t\t\t<fileNamePattern>${FILE_PATH}</fileNamePattern>\n\t\t\t<!-- 日志保存15天 -->\n\t\t\t<maxHistory>15</maxHistory>\n\t\t\t<timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\">\n\t\t\t\t<!-- 单个日志文件的最大，超过则新建日志文件存储 -->\n\t\t\t\t<maxFileSize>10MB</maxFileSize>\n\t\t\t</timeBasedFileNamingAndTriggeringPolicy>\n\t\t</rollingPolicy>\n\n\t\t<encoder>\n\t\t\t<!-- 按照上面配置的LOG_PATTERN来打印日志 -->\n\t\t\t<pattern>${LOG_PATTERN}</pattern>\n\t\t</encoder>\n\t</appender>\n</configuration>\n```\n使用 `<appender>` 定义一个名为 “FILE” 的文件配置，主要是配置日志文件保存的时间、单个日志文件存储的大小、以及文件保存的路径和日志的输出格式。\n\n### 3.4 定义日志输出级别\n\n```xml\n<configuration>\n\t<logger name=\"com.itcodai.course03\" level=\"INFO\" />\n\t<root level=\"INFO\">\n\t\t<appender-ref ref=\"CONSOLE\" />\n\t\t<appender-ref ref=\"FILE\" />\n\t</root>\n</configuration>\n```\n有了上面那些定义后，最后我们使用 `<logger>` 来定义一下项目中默认的日志输出级别，这里定义级别为 INFO，然后针对 INFO 级别的日志，使用 `<root>` 引用上面定义好的控制台日志输出和日志文件的参数。这样 logback.xml 文件中的配置就设置完了。\n\n## 4. 使用Logger在项目中打印日志\n\n在代码中，我们一般使用 Logger 对象来打印出一些 log 信息，可以指定打印出的日志级别，也支持占位符，很方便。\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/test\")\npublic class TestController {\n\n    private final static Logger logger = LoggerFactory.getLogger(TestController.class);\n\n    @RequestMapping(\"/log\")\n    public String testLog() {\n        logger.debug(\"=====测试日志debug级别打印====\");\n        logger.info(\"======测试日志info级别打印=====\");\n        logger.error(\"=====测试日志error级别打印====\");\n        logger.warn(\"======测试日志warn级别打印=====\");\n\n        // 可以使用占位符打印出一些参数信息\n        String str1 = \"blog.itcodai.com\";\n        String str2 = \"blog.csdn.net/eson_15\";\n        logger.info(\"======倪升武的个人博客：{}；倪升武的CSDN博客：{}\", str1, str2);\n\n        return \"success\";\n    }\n}\n```\n启动该项目，在浏览器中输入 `localhost:8080/test/log` 后可以看到控制台的日志记录：\n> ======测试日志info级别打印=====\n> =====测试日志error级别打印====\n> ======测试日志warn级别打印=====\n> ======倪升武的个人博客：blog.itcodai.com；倪升武的CSDN博客：blog.csdn.net/eson_15\n\n因为 INFO 级别比 DEBUG 级别高，所以 debug 这条没有打印出来，如果将 logback.xml 中的日志级别设置成 DEBUG，那么四条语句都会打印出来，这个大家自己去测试了。同时可以打开 D:\\logs\\course03\\ 目录，里面有刚刚项目启动，以后后面生成的所有日志记录。在项目部署后，我们大部分都是通过查看日志文件来定位问题。\n\n## 5. 总结\n\n本节课主要对 slf4j 做了一个简单的介绍，并且对 Spring Boot 中如何使用 slf4j 输出日志做了详细的说明，着重分析了 `logback.xml` 文件中对日志相关信息的配置，包括日志的不同级别。最后针对这些配置，在代码中使用 Logger 打印出一些进行测试。在实际项目中，这些日志都是排查问题的过程中非常重要的资料。\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n\n\n\n# 第04课：Spring Boot中的项目属性配置\n\n我们知道，在项目中，很多时候需要用到一些配置的信息，这些信息可能在测试环境和生产环境下会有不同的配置，后面根据实际业务情况有可能还会做修改，针对这种情况，我们不能将这些配置在代码中写死，最好就是写到配置文件中。比如可以把这些信息写到 `application.yml` 文件中。   \n\n## 1. 少量配置信息的情形\n\n举个例子，在微服务架构中，最常见的就是某个服务需要调用其他服务来获取其提供的相关信息，那么在该服务的配置文件中需要配置被调用的服务地址，比如在当前服务里，我们需要调用订单微服务获取订单相关的信息，假设 订单服务的端口号是 8002，那我们可以做如下配置：\n```xml\nserver:\n  port: 8001\n\n# 配置微服务的地址\nurl:\n  # 订单微服务的地址\n  orderUrl: http://localhost:8002\n```\n然后在业务代码中如何获取到这个配置的订单服务地址呢？我们可以使用 `@Value` 注解来解决。在对应的类中加上一个属性，在属性上使用 `@Value` 注解即可获取到配置文件中的配置信息，如下：\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/test\")\npublic class ConfigController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(ConfigController.class);\n\n    @Value(\"${url.orderUrl}\")\n    private String orderUrl;\n    \n    @RequestMapping(\"/config\")\n    public String testConfig() {\n        LOGGER.info(\"=====获取的订单服务地址为：{}\", orderUrl);\n        return \"success\";\n    }\n}\n```\n`@Value` 注解上通过 `${key}` 即可获取配置文件中和 key 对应的 value 值。我们启动一下项目，在浏览器中输入 `localhost:8080/test/config` 请求服务后，可以看到控制台会打印出订单服务的地址：\n\n```\n=====获取的订单服务地址为：http://localhost:8002\n```\n\n说明我们成功获取到了配置文件中的订单微服务地址，在实际项目中也是这么用的，后面如果因为服务器部署的原因，需要修改某个服务的地址，那么只要在配置文件中修改即可。  \n\n## 2. 多个配置信息的情形\n\n这里再引申一个问题，随着业务复杂度的增加，一个项目中可能会有越来越多的微服务，某个模块可能需要调用多个微服务获取不同的信息，那么就需要在配置文件中配置多个微服务的地址。可是，在需要调用这些微服务的代码中，如果这样一个个去使用 `@Value` 注解引入相应的微服务地址的话，太过于繁琐，也不科学。\n\n所以，在实际项目中，业务繁琐，逻辑复杂的情况下，需要考虑封装一个或多个配置类。举个例子：假如在当前服务中，某个业务需要同时调用订单微服务、用户微服务和购物车微服务，分别获取订单、用户和购物车相关信息，然后对这些信息做一定的逻辑处理。那么在配置文件中，我们需要将这些微服务的地址都配置好：\n```xml\n# 配置多个微服务的地址\nurl:\n  # 订单微服务的地址\n  orderUrl: http://localhost:8002\n  # 用户微服务的地址\n  userUrl: http://localhost:8003\n  # 购物车微服务的地址\n  shoppingUrl: http://localhost:8004\n```\n也许实际业务中，远远不止这三个微服务，甚至十几个都有可能。对于这种情况，我们可以先定义一个 `MicroServiceUrl` 类来专门保存微服务的 url，如下：\n\n```java\n@Component\n@ConfigurationProperties(prefix = \"url\")\npublic class MicroServiceUrl {\n\n    private String orderUrl;\n    private String userUrl;\n    private String shoppingUrl;\n    // 省去get和set方法\n}\n```\n细心的朋友应该可以看到，使用 `@ConfigurationProperties` 注解并且使用 prefix 来指定一个前缀，然后该类中的属性名就是配置中去掉前缀后的名字，一一对应即可。即：前缀名 + 属性名就是配置文件中定义的 key。同时，该类上面需要加上 `@Component` 注解，把该类作为组件放到Spring容器中，让 Spring 去管理，我们使用的时候直接注入即可。\n\n需要注意的是，使用 `@ConfigurationProperties` 注解需要导入它的依赖：\n```xml\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-configuration-processor</artifactId>\n\t<optional>true</optional>\n</dependency>\n```\n\nOK，到此为止，我们将配置写好了，接下来写个 Controller 来测试一下。此时，不需要在代码中一个个引入这些微服务的 url 了，直接通过 `@Resource` 注解将刚刚写好配置类注入进来即可使用了，非常方便。如下：\n```java\n@RestController\n@RequestMapping(\"/test\")\npublic class TestController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);\n\n    @Resource\n    private MicroServiceUrl microServiceUrl;\n    \n    @RequestMapping(\"/config\")\n    public String testConfig() {\n        LOGGER.info(\"=====获取的订单服务地址为：{}\", microServiceUrl.getOrderUrl());\n        LOGGER.info(\"=====获取的用户服务地址为：{}\", microServiceUrl.getUserUrl());\n        LOGGER.info(\"=====获取的购物车服务地址为：{}\", microServiceUrl.getShoppingUrl());\n\n        return \"success\";\n    }\n}\n```\n\n再次启动项目，请求一下可以看到，控制台打印出如下信息，说明配置文件生效，同时正确获取配置文件内容：\n```\n=====获取的订单服务地址为：http://localhost:8002\n=====获取的订单服务地址为：http://localhost:8002\n=====获取的用户服务地址为：http://localhost:8003\n=====获取的购物车服务地址为：http://localhost:8004\n```\n\n## 3. 指定项目配置文件\n\n我们知道，在实际项目中，一般有两个环境：开发环境和生产环境。开发环境中的配置和生产环境中的配置往往不同，比如：环境、端口、数据库、相关地址等等。我们不可能在开发环境调试好之后，部署到生产环境后，又要将配置信息全部修改成生产环境上的配置，这样太麻烦，也不科学。\n\n最好的解决方法就是开发环境和生产环境都有一套对用的配置信息，然后当我们在开发时，指定读取开发环境的配置，当我们将项目部署到服务器上之后，再指定去读取生产环境的配置。\n\n我们新建两个配置文件： `application-dev.yml` 和 `application-pro.yml`，分别用来对开发环境和生产环境进行相关配置。这里为了方便，我们分别设置两个访问端口号，开发环境用 8001，生产环境用 8002.\n```xml\n# 开发环境配置文件\nserver:\n  port: 8001\n```\n```xml\n# 开发环境配置文件\nserver:\n  port: 8002\n```\n然后在 `application.yml` 文件中指定读取哪个配置文件即可。比如我们在开发环境下，指定读取 `applicationn-dev.yml` 文件，如下：\n```xml\nspring:\n  profiles:\n    active:\n    - dev\n```\n这样就可以在开发的时候，指定读取  `application-dev.yml` 文件，访问的时候使用 8001 端口，部署到服务器后，只需要将 `application.yml` 中指定的文件改成 `application-pro.yml` 即可，然后使用 8002 端口访问，非常方便。\n\n## 4. 总结\n\n本节课主要讲解了 Spring Boot 中如何在业务代码中读取相关配置，包括单一配置和多个配置项，在微服务中，这种情况非常常见，往往会有很多其他微服务需要调用，所以封装一个配置类来接收这些配置是个很好的处理方式。除此之外，例如数据库相关的连接参数等等，也可以放到一个配置类中，其他遇到类似的场景，都可以这么处理。最后介绍了开发环境和生产环境配置的快速切换方式，省去了项目部署时，诸多配置信息的修改。\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n\n\n\n# 第05课：Spring Boot中的MVC支持\n\nSpring Boot 的 MVC 支持主要来介绍实际项目中最常用的几个注解，包括 `@RestController`、 `@RequestMapping`、`@PathVariable`、`@RequestParam` 以及 `@RequestBody`。主要介绍这几个注解常用的使用方式和特点。  \n\n## 1. @RestController\n\n`@RestController` 是 Spring Boot 新增的一个注解，我们看一下该注解都包含了哪些东西。\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Controller\n@ResponseBody\npublic @interface RestController {\n    String value() default \"\";\n}\n```\n可以看出， `@RestController` 注解包含了原来的 `@Controller` 和 `@ResponseBody` 注解，使用过 Spring 的朋友对 `@Controller` 注解已经非常了解了，这里不再赘述， `@ResponseBody` 注解是将返回的数据结构转换为 Json 格式。所以 `@RestController` 可以看作是 `@Controller` 和 `@ResponseBody` 的结合体，相当于偷个懒，我们使用 `@RestController` 之后就不用再使用 `@Controller` 了。但是需要注意一个问题：如果是前后端分离，不用模板渲染的话，比如 Thymeleaf，这种情况下是可以直接使用`@RestController` 将数据以 json 格式传给前端，前端拿到之后解析；但如果不是前后端分离，需要使用模板来渲染的话，一般 Controller 中都会返回到具体的页面，那么此时就不能使用`@RestController`了，比如：\n```java\npublic String getUser() {\n\treturn \"user\";\n}\n```\n其实是需要返回到 user.html 页面的，如果使用 `@RestController` 的话，会将 user 作为字符串返回的，所以这时候我们需要使用 `@Controller` 注解。这在下一节 Spring Boot 集成 Thymeleaf 模板引擎中会再说明。\n\n\n## 2. @RequestMapping\n\n`@RequestMapping` 是一个用来处理请求地址映射的注解，它可以用于类上，也可以用于方法上。在类的级别上的注解会将一个特定请求或者请求模式映射到一个控制器之上，表示类中的所有响应请求的方法都是以该地址作为父路径；在方法的级别表示进一步指定到处理方法的映射关系。\n\n该注解有6个属性，一般在项目中比较常用的有三个属性：value、method 和 produces。\n* value 属性：指定请求的实际地址，value 可以省略不写\n* method 属性：指定请求的类型，主要有 GET、PUT、POST、DELETE，默认为 GET\n* produces属性：指定返回内容类型，如 produces = \"application/json; charset=UTF-8\"\n\n`@RequestMapping` 注解比较简单，举个例子：\n```java\n@RestController\n@RequestMapping(value = \"/test\", produces = \"application/json; charset=UTF-8\")\npublic class TestController {\n\n    @RequestMapping(value = \"/get\", method = RequestMethod.GET)\n    public String testGet() {\n        return \"success\";\n    }\n}\n```\n这个很简单，启动项目在浏览器中输入 `localhost:8080/test/get` 测试一下即可。\n\n针对四种不同的请求方式，是有相应注解的，不用每次在 `@RequestMapping` 注解中加 method 属性来指定，上面的 GET 方式请求可以直接使用 `@GetMapping(\"/get\")` 注解，效果一样。相应地，PUT 方式、POST 方式和 DELETE 方式对应的注解分别为 `@PutMapping`、`@PostMapping` 和 `DeleteMapping`。\n\n## 3. @PathVariable\n\n`@PathVariable` 注解主要是用来获取 url 参数，Spring Boot 支持 restfull 风格的 url，比如一个 GET 请求携带一个参数 id 过来，我们将 id 作为参数接收，可以使用 `@PathVariable` 注解。如下：\n```java\n@GetMapping(\"/user/{id}\")\npublic String testPathVariable(@PathVariable Integer id) {\n\tSystem.out.println(\"获取到的id为：\" + id);\n\treturn \"success\";\n}\n```\n这里需要注意一个问题，如果想要 url 中占位符中的 id 值直接赋值到参数 id 中，需要保证 url 中的参数和方法接收参数一致，否则就无法接收。如果不一致的话，其实也可以解决，需要用 `@PathVariable` 中的 value 属性来指定对应关系。如下：\n```java\n@RequestMapping(\"/user/{idd}\")\npublic String testPathVariable(@PathVariable(value = \"idd\") Integer id) {\n\tSystem.out.println(\"获取到的id为：\" + id);\n\treturn \"success\";\n}\n```\n对于访问的 url，占位符的位置可以在任何位置，不一定非要在最后，比如这样也行：`/xxx/{id}/user`。另外，url 也支持多个占位符，方法参数使用同样数量的参数来接收，原理和一个参数是一样的，例如：\n```java\n@GetMapping(\"/user/{idd}/{name}\")\n    public String testPathVariable(@PathVariable(value = \"idd\") Integer id, @PathVariable String name) {\n        System.out.println(\"获取到的id为：\" + id);\n        System.out.println(\"获取到的name为：\" + name);\n        return \"success\";\n    }\n```\n运行项目，在浏览器中请求 `localhost:8080/test/user/2/zhangsan` 可以看到控制台输出如下信息：\n```\n获取到的id为：2\n获取到的name为：zhangsan\n```\n所以支持多个参数的接收。同样地，如果 url 中的参数和方法中的参数名称不同的话，也需要使用 value 属性来绑定两个参数。\n\n\n## 4. @RequestParam\n\n`@RequestParam` 注解顾名思义，也是获取请求参数的，上面我们介绍了 `@PathValiable` 注解也是获取请求参数的，那么 `@RequestParam` 和 `@PathVariable` 有什么不同呢？主要区别在于： `@PathValiable` 是从 url 模板中获取参数值， 即这种风格的 url：`http://localhost:8080/user/{id}` ；而 `@RequestParam` 是从 request 里面获取参数值，即这种风格的 url：`http://localhost:8080/user?id=1`  。我们使用该 url 带上参数 id 来测试一下如下代码：\n```java\n@GetMapping(\"/user\")\npublic String testRequestParam(@RequestParam Integer id) {\n\tSystem.out.println(\"获取到的id为：\" + id);\n\treturn \"success\";\n}\n```\n可以正常从控制台打印出 id 信息。同样地，url 上面的参数和方法的参数需要一致，如果不一致，也需要使用 value 属性来说明，比如 url 为：`http://localhost:8080/user?idd=1`\n```java\n@RequestMapping(\"/user\")\npublic String testRequestParam(@RequestParam(value = \"idd\", required = false) Integer id) {\n\tSystem.out.println(\"获取到的id为：\" + id);\n\treturn \"success\";\n}\n```\n除了 value 属性外，还有个两个属性比较常用：\n* required 属性：true 表示该参数必须要传，否则就会报 404 错误，false 表示可有可无。\n* defaultValue 属性：默认值，表示如果请求中没有同名参数时的默认值。\n\n从 url 中可以看出，`@RequestParam` 注解用于 GET 请求上时，接收拼接在 url 中的参数。除此之外，该注解还可以用于 POST 请求，接收前端表单提交的参数，假如前端通过表单提交 username 和 password 两个参数，那我们可以使用 `@RequestParam` 来接收，用法和上面一样。\n```java\n@PostMapping(\"/form1\")\n    public String testForm(@RequestParam String username, @RequestParam String password) {\n        System.out.println(\"获取到的username为：\" + username);\n        System.out.println(\"获取到的password为：\" + password);\n        return \"success\";\n    }\n```\n我们使用 postman 来模拟一下表单提交，测试一下接口：\n\n![使用postman测试表单提交](https://img-blog.csdnimg.cn/20200215043749282.png)\n\n那么问题来了，如果表单数据很多，我们不可能在后台方法中写上很多参数，每个参数还要 `@RequestParam` 注解。针对这种情况，我们需要封装一个实体类来接收这些参数，实体中的属性名和表单中的参数名一致即可。\n```java\npublic class User {\n\tprivate String username;\n\tprivate String password;\n\t// set get\n}\n```\n使用实体接收的话，我们不能在前面加 `@RequestParam` 注解了，直接使用即可。\n```java\n@PostMapping(\"/form2\")\n    public String testForm(User user) {\n        System.out.println(\"获取到的username为：\" + user.getUsername());\n        System.out.println(\"获取到的password为：\" + user.getPassword());\n        return \"success\";\n    }\n```\n使用 postman 再次测试一下表单提交，观察一下返回值和控制台打印出的日志即可。在实际项目中，一般都是封装一个实体类来接收表单数据，因为实际项目中表单数据一般都很多。\n\n\n## 5. @RequestBody\n\n`@RequestBody` 注解用于接收前端传来的实体，接收参数也是对应的实体，比如前端通过 json 提交传来两个参数 username 和 password，此时我们需要在后端封装一个实体来接收。在传递的参数比较多的情况下，使用 `@RequestBody` 接收会非常方便。例如：\n```java\npublic class User {\n\tprivate String username;\n\tprivate String password;\n\t// set get\n}\n```\n```java\n@PostMapping(\"/user\")\npublic String testRequestBody(@RequestBody User user) {\n\tSystem.out.println(\"获取到的username为：\" + user.getUsername());\n\tSystem.out.println(\"获取到的password为：\" + user.getPassword());\n\treturn \"success\";\n}\n```\n我们使用 postman 工具来测试一下效果，打开 postman，然后输入请求地址和参数，参数我们用 json 来模拟，如下图所有，调用之后返回 success。\n\n![使用Postman测试requestBody](https://img-blog.csdnimg.cn/20200215043853532.png)\n\n同时看一下后台控制台输出的日志：\n```\n获取到的username为：倪升武\n获取到的password为：123456\n```\n可以看出，`@RequestBody` 注解用于 POST 请求上，接收 json 实体参数。它和上面我们介绍的表单提交有点类似，只不过参数的格式不同，一个是 json 实体，一个是表单提交。在实际项目中根据具体场景和需要使用对应的注解即可。\n\n## 6. 总结\n\n本节课主要讲解了 Spring Boot 中对 MVC 的支持，分析了 `@RestController`、 `@RequestMapping`、`@PathVariable`、 `@RequestParam` 和 `@RequestBody` 四个注解的使用方式，由于 `@RestController` 中集成了 `@ResponseBody` 所以对返回 json 的注解不再赘述。以上四个注解是使用频率很高的注解，在所有的实际项目中基本都会遇到，要熟练掌握。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n\n\n\n# 第06课：Spring Boot集成 Swagger2 展现在线接口文档\n\n## 1. Swagger 简介\n\n### 1.1 解决的问题\n随着互联网技术的发展，现在的网站架构基本都由原来的后端渲染，变成了前后端分离的形态，而且前端技术和后端技术在各自的道路上越走越远。前端和后端的唯一联系，变成了 API 接口，所以 API 文档变成了前后端开发人员联系的纽带，变得越来越重要。\n\n那么问题来了，随着代码的不断更新，开发人员在开发新的接口或者更新旧的接口后，由于开发任务的繁重，往往文档很难持续跟着更新，Swagger 就是用来解决该问题的一款重要的工具，对使用接口的人来说，开发人员不需要给他们提供文档，只要告诉他们一个 Swagger 地址，即可展示在线的 API 接口文档，除此之外，调用接口的人员还可以在线测试接口数据，同样地，开发人员在开发接口时，同样也可以利用 Swagger 在线接口文档测试接口数据，这给开发人员提供了便利。\n\n### 1.2 Swagger 官方\n\n我们打开 [Swagger 官网](https://swagger.io/)，官方对 Swagger 的定义为：\n> The Best APIs are Built with Swagger Tools \n\n翻译成中文是：“最好的 API 是使用 Swagger 工具构建的”。由此可见，Swagger 官方对其功能和所处的地位非常自信，由于其非常好用，所以官方对其定位也合情合理。如下图所示：\n\n![官方对swagger的定位](https://img-blog.csdnimg.cn/20200215043936444.png)\n\n本文主要讲解在 Spring Boot 中如何导入 Swagger2 工具来展现项目中的接口文档。本节课使用的 Swagger 版本为 2.2.2。下面开始进入 Swagger2 之旅。\n\n\n## 2. Swagger2 的 maven 依赖\n\n使用 Swagger2 工具，必须要导入 maven 依赖，当前官方最高版本是 2.8.0，我尝试了一下，个人感觉页面展示的效果不太好，而且不够紧凑，不利于操作。另外，最新版本并不一定是最稳定版本，当前我们实际项目中使用的是 2.2.2 版本，该版本稳定，界面友好，所以本节课主要围绕着 2.2.2 版本来展开，依赖如下：\n```xml\n<dependency>\n\t<groupId>io.springfox</groupId>\n\t<artifactId>springfox-swagger2</artifactId>\n\t<version>2.2.2</version>\n</dependency>\n<dependency>\n\t<groupId>io.springfox</groupId>\n\t<artifactId>springfox-swagger-ui</artifactId>\n\t<version>2.2.2</version>\n</dependency>\n```\n## 3. Swagger2 的配置\n\n使用 Swagger2 需要进行配置，Spring Boot 中对 Swagger2 的配置非常方便，新建一个配置类，Swagger2 的配置类上除了添加必要的 `@Configuration` 注解外，还需要添加 `@EnableSwagger2` 注解。\n```java\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport springfox.documentation.builders.ApiInfoBuilder;\nimport springfox.documentation.builders.PathSelectors;\nimport springfox.documentation.builders.RequestHandlerSelectors;\nimport springfox.documentation.service.ApiInfo;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\n/**\n * @author shengwu ni\n */\n@Configuration\n@EnableSwagger2\npublic class SwaggerConfig {\n\n    @Bean\n    public Docket createRestApi() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                // 指定构建api文档的详细信息的方法：apiInfo()\n                .apiInfo(apiInfo())\n                .select()\n                // 指定要生成api接口的包路径，这里把controller作为包路径，生成controller中的所有接口\n                .apis(RequestHandlerSelectors.basePackage(\"com.itcodai.course06.controller\"))\n                .paths(PathSelectors.any())\n                .build();\n    }\n\n    /**\n     * 构建api文档的详细信息\n     * @return\n     */\n    private ApiInfo apiInfo() {\n        return new ApiInfoBuilder()\n                // 设置页面标题\n                .title(\"Spring Boot集成Swagger2接口总览\")\n                // 设置接口描述\n                .description(\"跟武哥一起学Spring Boot第06课\")\n                // 设置联系方式\n                .contact(\"倪升武，\" + \"CSDN：http://blog.csdn.net/eson_15\")\n                // 设置版本\n                .version(\"1.0\")\n                // 构建\n                .build();\n    }\n}\n```\n在该配置类中，已经使用注释详细解释了每个方法的作用了，在此不再赘述。到此为止，我们已经配置好了 Swagger2 了。现在我们可以测试一下配置有没有生效，启动项目，在浏览器中输入 `localhost:8080/swagger-ui.html`，即可看到 swagger2 的接口页面，如下图所示，说明Swagger2 集成成功。\n\n![swagger2页面](https://img-blog.csdnimg.cn/20200215044013383.png)\n\n结合该图，对照上面的 Swagger2 配置文件中的配置，可以很明确的知道配置类中每个方法的作用。这样就很容易理解和掌握 Swagger2 中的配置了，也可以看出，其实 Swagger2 配置很简单。\n\n【友情提示】可能有很多朋友在配置 Swagger 的时候会遇到下面的情况，而且还关不掉的，这是因为浏览器缓存引起的，清空一下浏览器缓存即可解决问题。\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-k3UNsYXM-1581914323088)(http://p99jlm9k5.bkt.clouddn.com/blog/images/1/error.png)]\n\n## 4. Swagger2 的使用\n\n上面我们已经配置好了 Swagger2，并且也启动测试了一下，功能正常，下面我们开始使用 Swagger2，主要来介绍 Swagger2 中的几个常用的注解，分别在实体类上、 Controller 类上以及 Controller 中的方法上，最后我们看一下 Swagger2 是如何在页面上呈现在线接口文档的，并且结合 Controller 中的方法在接口中测试一下数据。\n\n### 4.1 实体类注解\n\n本节我们建一个 User 实体类，主要介绍一下 Swagger2 中的 `@ApiModel` 和 `@ApiModelProperty` 注解，同时为后面的测试做准备。\n```java\nimport io.swagger.annotations.ApiModel;\nimport io.swagger.annotations.ApiModelProperty;\n\n@ApiModel(value = \"用户实体类\")\npublic class User {\n\n    @ApiModelProperty(value = \"用户唯一标识\")\n    private Long id;\n\n    @ApiModelProperty(value = \"用户姓名\")\n    private String username;\n\n    @ApiModelProperty(value = \"用户密码\")\n    private String password;\n\n\t// 省略set和get方法\n}\n```\n解释下 `@ApiModel` 和 `@ApiModelProperty` 注解：\n> `@ApiModel` 注解用于实体类，表示对类进行说明，用于参数用实体类接收。\n> `@ApiModelProperty` 注解用于类中属性，表示对 model 属性的说明或者数据操作更改。\n\n该注解在在线 API 文档中的具体效果在下文说明。\n\n### 4.2 Controller 类中相关注解\n\n我们写一个 TestController，再写几个接口，然后学习一下 Controller 中和 Swagger2 相关的注解。\n```java\nimport com.itcodai.course06.entiy.JsonResult;\nimport com.itcodai.course06.entiy.User;\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiOperation;\nimport io.swagger.annotations.ApiParam;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/swagger\")\n@Api(value = \"Swagger2 在线接口文档\")\npublic class TestController {\n\n    @GetMapping(\"/get/{id}\")\n    @ApiOperation(value = \"根据用户唯一标识获取用户信息\")\n    public JsonResult<User> getUserInfo(@PathVariable @ApiParam(value = \"用户唯一标识\") Long id) {\n        // 模拟数据库中根据id获取User信息\n        User user = new User(id, \"倪升武\", \"123456\");\n        return new JsonResult(user);\n    }\n}\n```\n我们来学习一下 `@Api` 、 `@ApiOperation` 和 `@ApiParam` 注解。\n> `@Api` 注解用于类上，表示标识这个类是 swagger 的资源。\n> `@ApiOperation` 注解用于方法，表示一个 http 请求的操作。\n> `@ApiParam` 注解用于参数上，用来标明参数信息。\n\n这里返回的是 JsonResult，是第02课中学习返回 json 数据时封装的实体。以上是 Swagger 中最常用的 5 个注解，接下来运行一下项目工程，在浏览器中输入 `localhost:8080/swagger-ui.html` 看一下 Swagger 页面的接口状态。\n\n![swagger接口展示](https://img-blog.csdnimg.cn/20200215044156305.png)\n\n可以看出，Swagger 页面对该接口的信息展示的非常全面，每个注解的作用以及展示的地方在上图中已经标明，通过页面即可知道该接口的所有信息，那么我们直接在线测试一下该接口返回的信息，输入id为1，看一下返回数据：\n\n![返回数据测试](https://img-blog.csdnimg.cn/20200215044226292.png)\n\n可以看出，直接在页面返回了 json 格式的数据，开发人员可以直接使用该在线接口来测试数据的正确与否，非常方便。上面是对于单个参数的输入，如果输入参数为某个对象这种情况，Swagger 是什么样子呢？我们再写一个接口。\n```java\n@PostMapping(\"/insert\")\n    @ApiOperation(value = \"添加用户信息\")\n    public JsonResult<Void> insertUser(@RequestBody @ApiParam(value = \"用户信息\") User user) {\n        // 处理添加逻辑\n        return new JsonResult<>();\n    }\n```\n重启项目，在浏览器中输入 `localhost:8080/swagger-ui.html` 看一下效果：\n\n![swagger接口展示](https://img-blog.csdnimg.cn/20200215044256579.png)\n\n## 5. 总结\n\nOK，本节课详细分析了 Swagger 的优点，以及 Spring Boot 如何集成 Swagger2，包括配置，相关注解的讲解，涉及到了实体类和接口类，以及如何使用。最后通过页面测试，体验了 Swagger 的强大之处，基本上是每个项目组中必备的工具之一，所以要掌握该工具的使用，也不难。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n\n\n\n# 第07课：Spring Boot集成Thymeleaf模板引擎\n\n## 1. Thymeleaf 介绍\n\n> Thymeleaf 是适用于 Web 和独立环境的现代服务器端 Java 模板引擎。  \n> Thymeleaf 的主要目标是为您的开发工作流程带来优雅的自然模板 - 可以在浏览器中正确显示的HTML，也可以用作静态原型，从而在开发团队中实现更强大的协作。  \n\n以上翻译自 Thymeleaf 官方网站。传统的 JSP+JSTL 组合是已经过去了，Thymeleaf 是现代服务端的模板引擎，与传统的 JSP 不同，Thymeleaf 可以使用浏览器直接打开，因为可以忽略掉拓展属性，相当于打开原生页面，给前端人员也带来一定的便利。   \n\n什么意思呢？就是说在本地环境或者有网络的环境下，Thymeleaf 均可运行。由于 thymeleaf 支持 html 原型，也支持在 html 标签里增加额外的属性来达到 “模板+数据” 的展示方式，所以美工可以直接在浏览器中查看页面效果，当服务启动后，也可以让后台开发人员查看带数据的动态页面效果。比如：\n```html\n<div class=\"ui right aligned basic segment\">\n      <div class=\"ui orange basic label\" th:text=\"${blog.flag}\">静态原创信息</div>\n</div>\n<h2 class=\"ui center aligned header\" th:text=\"${blog.title}\">这是静态标题</h2>\n```\n类似与上面这样，在静态页面时，会展示静态信息，当服务启动后，动态获取数据库中的数据后，就可以展示动态数据，`th:text` 标签是用来动态替换文本的，这会在下文说明。该例子说明浏览器解释 html 时会忽略 html 中未定义的标签属性（比如 `th:text`），所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示数据。 \n\n## 2. 依赖导入\n\n在 Spring Boot 中使用 thymeleaf 模板需要引入依赖，可以在创建项目工程时勾选 Thymeleaf，也可以创建之后再手动导入，如下：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n```\n另外，在 html 页面上如果要使用 thymeleaf 模板，需要在页面标签中引入：\n```html\n<html xmlns:th=\"http://www.thymeleaf.org\">\n```\n\n## 3. Thymeleaf相关配置\n\n因为 Thymeleaf 中已经有默认的配置了，我们不需要再对其做过多的配置，有一个需要注意一下，Thymeleaf 默认是开启页面缓存的，所以在开发的时候，需要关闭这个页面缓存，配置如下。\n\n```yml\nspring:\n  thymeleaf:\n    cache: false #关闭缓存\n```\n否则会有缓存，导致页面没法及时看到更新后的效果。 比如你修改了一个文件，已经 update 到 tomcat 了，但刷新页面还是之前的页面，就是因为缓存引起的。\n\n## 4. Thymeleaf 的使用\n\n### 4.1 访问静态页面\n\n这个和 Thymeleaf 没啥关系，应该说是通用的，我把它一并写到这里的原因是一般我们做网站的时候，都会做一个 404 页面和 500 页面，为了出错时给用户一个友好的展示，而不至于一堆异常信息抛出来。Spring Boot 中会自动识别模板目录（templates/）下的 404.html 和 500.html 文件。我们在 templates/ 目录下新建一个 error 文件夹，专门放置错误的 html 页面，然后分别打印些信息。以 404.html 为例：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    这是404页面\n</body>\n</html>\n```\n我们再写一个 controller 来测试一下 404 和 500 页面：\n```java\n@Controller\n@RequestMapping(\"/thymeleaf\")\npublic class ThymeleafController {\n\n    @RequestMapping(\"/test404\")\n    public String test404() {\n        return \"index\";\n    }\n\n    @RequestMapping(\"/test500\")\n    public String test500() {\n        int i = 1 / 0;\n        return \"index\";\n    }\n}\n```\n> 当我们在浏览器中输入 `localhost:8080/thymeleaf/test400` 时，故意输入错误，找不到对应的方法，就会跳转到 404.html 显示。   \n> 当我们在浏览器中输入 `localhost:8088/thymeleaf/test505` 时，会抛出异常，然后会自动跳转到 500.html 显示。\n\n【注】这里有个问题需要注意一下，前面的课程中我们说了微服务中会走向前后端分离，我们在 Controller 层上都是使用的 `@RestController` 注解，自动会把返回的数据转成 json 格式。但是在使用模板引擎时，Controller 层就不能用 `@RestController` 注解了，因为在使用 thymeleaf 模板时，返回的是视图文件名，比如上面的 Controller 中是返回到 index.html 页面，如果使用 `@RestController` 的话，会把 index 当作 String 解析了，直接返回到页面了，而不是去找 index.html 页面，大家可以试一下。所以在使用模板时要用 `@Controller` 注解。\n\n### 4.2 Thymeleaf 中处理对象\n\n我们来看一下 thymeleaf 模板中如何处理对象信息，假如我们在做个人博客的时候，需要给前端传博主相关信息来展示，那么我们会封装成一个博主对象，比如：\n```java\npublic class Blogger {\n    private Long id;\n    private String name;\n    private String pass;\n\t// 省去set和get\n}\n```\n然后在controller层中初始化一下：\n```java\n@GetMapping(\"/getBlogger\")\npublic String getBlogger(Model model) {\n\tBlogger blogger = new Blogger(1L, \"倪升武\", \"123456\");\n\tmodel.addAttribute(\"blogger\", blogger);\n\treturn \"blogger\";\n}\n```\n我们先初始化一个 Blogger 对象，然后将该对象放到 Model 中，然后返回到 blogger.html 页面去渲染。接下来我们再写一个 blogger.html 来渲染 blogger 信息：\n```html\n<!DOCTYPE html>\n<html xmlns:th=\"http://www.thymeleaf.org\">\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>博主信息</title>\n</head>\n<body>\n<form action=\"\" th:object=\"${blogger}\" >\n    用户编号：<input name=\"id\" th:value=\"${blogger.id}\"/><br>\n    用户姓名：<input type=\"text\" name=\"username\" th:value=\"${blogger.getName()}\" /><br>\n    登陆密码：<input type=\"text\" name=\"password\" th:value=\"*{pass}\" />\n</form>\n</body>\n</html>\n```\n可以看出，在 thymeleaf 模板中，使用 `th:object=\"${}\"` 来获取对象信息，然后在表单里面可以有三种方式来获取对象属性。如下：\n\n> 使用 `th:value=\"*{属性名}\"`\n> 使用 `th:value=\"${对象.属性名}\"`，对象指的是上面使用 `th:object` 获取的对象\n> 使用 `th:value=\"${对象.get方法}\"`，对象指的是上面使用 `th:object` 获取的对象\n\n可以看出，在 Thymeleaf 中可以像写 java 一样写代码，很方便。我们在浏览器中输入 `localhost:8080/thymeleaf/getBlogger` 来测试一下数据：\n\n![thymeleaf中处理对象](https://img-blog.csdnimg.cn/20200215044353803.jpg)\n\n### 4.3 Thymeleaf 中处理 List\n处理 List 的话，和处理上面介绍的对象差不多，但是需要在 thymeleaf 中进行遍历。我们先在 Controller 中模拟一个 List。\n```java\n@GetMapping(\"/getList\")\npublic String getList(Model model) {\n    Blogger blogger1 = new Blogger(1L, \"倪升武\", \"123456\");\n    Blogger blogger2 = new Blogger(2L, \"达人课\", \"123456\");\n    List<Blogger> list = new ArrayList<>();\n    list.add(blogger1);\n    list.add(blogger2);\n    model.addAttribute(\"list\", list);\n    return \"list\";\n}\n```\n接下来我们写一个 list.html 来获取该 list 信息，然后在 list.html 中遍历这个list。如下：\n\n```html\n<!DOCTYPE html>\n<html xmlns:th=\"http://www.thymeleaf.org\">\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>博主信息</title>\n</head>\n<body>\n<form action=\"\" th:each=\"blogger : ${list}\" >\n    用户编号：<input name=\"id\" th:value=\"${blogger.id}\"/><br>\n    用户姓名：<input type=\"text\" name=\"password\" th:value=\"${blogger.name}\"/><br>\n    登录密码：<input type=\"text\" name=\"username\" th:value=\"${blogger.getPass()}\"/>\n</form>\n</body>\n</html>\n```\n可以看出，其实和处理单个对象信息差不多，Thymeleaf 使用 `th:each` 进行遍历，`${}` 取 model 中传过来的参数，然后自定义 list 中取出来的每个对象，这里定义为 blogger。表单里面可以直接使用 `${对象.属性名}` 来获取 list 中对象的属性值，也可以使用 `${对象.get方法}` 来获取，这点和上面处理对象信息是一样的，但是不能使用 `*{属性名}` 来获取对象中的属性，thymeleaf 模板获取不到。    \n\n### 4.4 其他常用 thymeleaf 操作\n\n我们来总结一下 thymeleaf 中的一些常用的标签操作，如下：\n\n|   标签   |   功能   |   例子   |\n| ---- | ---- | ---- |\n|   `th:value`   |   给属性赋值   |   `<input th:value=\"${blog.name}\" /> `  |\n|   `th:style`   |   设置样式   |   `th:style=\"'display:'+@{(${sitrue}?'none':'inline-block')} + ''\"`   |\n|   `th:onclick`   |   点击事件   |   `th:onclick=\"'getInfo()'\"`   |\n|   `th:if`  | 条件判断 | `<a th:if=\"${userId == collect.userId}\" >` |\n|`th:href`|超链接|`<a th:href=\"@{/blogger/login}\">Login</a> />`|\n|`th:unless`|条件判断和`th:if`相反|`<a th:href=\"@{/blogger/login}\" th:unless=${session.user != null}>Login</a>`|\n|`th:switch`|配合`th:case`|`<div th:switch=\"${user.role}\">`|\n|`th:case`|配合`th:switch`|`<p th:case=\"'admin'\">administator</p>`|\n|`th:src`|地址引入|`<img alt=\"csdn logo\" th:src=\"@{/img/logo.png}\" />`|\n|`th:action`|表单提交的地址|`<form th:action=\"@{/blogger/update}\">`|\n\nThymeleaf 还有很多其他用法，这里就不总结了，具体的可以参考Thymeleaf的[官方文档（v3.0）](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html)。主要要学会如何在 Spring Boot 中去使用 thymeleaf，遇到对应的标签或者方法，查阅官方文档即可。\n\n## 5. 总结\n\nThymeleaf 在 Spring Boot 中使用非常广泛，本节课主要分析了 thymeleaf 的优点，以及如何在 Spring Boot 中集成并使用 thymeleaf 模板，包括依赖、配置，相关数据的获取、以及一些注意事项等等。最后列举了一些 thymeleaf 中常用的标签，在实际项目中多使用，多查阅就能熟练掌握，thymeleaf 中的一些标签或者方法不用死记硬背，用到什么去查阅什么，关键是要会在 Spring Boot 中集成，用的多了就熟能生巧。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n\n\n\n# 第08课：Spring Boot中的全局异常处理\n\n\n在项目开发过程中，不管是对底层数据库的操作过程，还是业务层的处理过程，还是控制层的处理过程，都不可避免会遇到各种可预知的、不可预知的异常需要处理。如果对每个过程都单独作异常处理，那系统的代码耦合度会变得很高，此外，开发工作量也会加大而且不好统一，这也增加了代码的维护成本。   \n针对这种实际情况，我们需要将所有类型的异常处理从各处理过程解耦出来，这样既保证了相关处理过程的功能单一，也实现了异常信息的统一处理和维护。同时，我们也不希望直接把异常抛给用户，应该对异常进行处理，对错误信息进行封装，然后返回一个友好的信息给用户。这节主要总结一下项目中如何使用 Spring Boot 如何拦截并处理全局的异常。\n\n## 1. 定义返回的统一 json 结构\n\n前端或者其他服务请求本服务的接口时，该接口需要返回对应的 json 数据，一般该服务只需要返回请求着需要的参数即可，但是在实际项目中，我们需要封装更多的信息，比如状态码 code、相关信息 msg 等等，这一方面是在项目中可以有个统一的返回结构，整个项目组都适用，另一方面是方便结合全局异常处理信息，因为异常处理信息中一般我们需要把状态码和异常内容反馈给调用方。   \n这个统一的 json 结构这可以参考[第02课：Spring Boot 返回 JSON 数据及数据封装](https://gitbook.cn/gitchat/column/5b3c9f35a3442272491a176a)中封装的统一 json 结构，本节内容我们简化一下，只保留状态码 code 和异常信息 msg即可。如下：\n```java\npublic class JsonResult {\n    /**\n     * 异常码\n     */\n    protected String code;\n\n    /**\n     * 异常信息\n     */\n    protected String msg;\n\t\n    public JsonResult() {\n        this.code = \"200\";\n        this.msg = \"操作成功\";\n    }\n    \n    public JsonResult(String code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\t// get set\n}\n```\n\n## 2. 处理系统异常\n\n新建一个 GlobalExceptionHandler 全局异常处理类，然后加上 `@ControllerAdvice` 注解即可拦截项目中抛出的异常，如下：\n```java\n@ControllerAdvice\n@ResponseBody\npublic class GlobalExceptionHandler {\n\t// 打印log\n    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n    // ……\n}\n```\n我们点开 `@ControllerAdvice` 注解可以看到，`@ControllerAdvice` 注解包含了 `@Component` 注解，说明在 Spring Boot 启动时，也会把该类作为组件交给 Spring 来管理。除此之外，该注解还有个 `basePackages` 属性，该属性是用来拦截哪个包中的异常信息，一般我们不指定这个属性，我们拦截项目工程中的所有异常。`@ResponseBody` 注解是为了异常处理完之后给调用方输出一个 json 格式的封装数据。  \n在项目中如何使用呢？Spring Boot 中很简单，在方法上通过 `@ExceptionHandler` 注解来指定具体的异常，然后在方法中处理该异常信息，最后将结果通过统一的 json 结构体返回给调用者。下面我们举几个例子来说明如何来使用。\n\n### 2.1 处理参数缺失异常\n\n在前后端分离的架构中，前端请求后台的接口都是通过 rest 风格来调用，有时候，比如 POST 请求 需要携带一些参数，但是往往有时候参数会漏掉。另外，在微服务架构中，涉及到多个微服务之间的接口调用时，也可能出现这种情况，此时我们需要定义一个处理参数缺失异常的方法，来给前端或者调用方提示一个友好信息。  \n\n参数缺失的时候，会抛出 `HttpMessageNotReadableException`，我们可以拦截该异常，做一个友好处理，如下：\n```java\n/**\n* 缺少请求参数异常\n* @param ex HttpMessageNotReadableException\n* @return\n*/\n@ExceptionHandler(MissingServletRequestParameterException.class)\n@ResponseStatus(value = HttpStatus.BAD_REQUEST)\npublic JsonResult handleHttpMessageNotReadableException(\n    MissingServletRequestParameterException ex) {\n    logger.error(\"缺少请求参数，{}\", ex.getMessage());\n    return new JsonResult(\"400\", \"缺少必要的请求参数\");\n}\n```\n\n我们来写个简单的 Controller 测试一下该异常，通过 POST 请求方式接收两个参数：姓名和密码。\n```java\n@RestController\n@RequestMapping(\"/exception\")\npublic class ExceptionController {\n\n    private static final Logger logger = LoggerFactory.getLogger(ExceptionController.class);\n\n    @PostMapping(\"/test\")\n    public JsonResult test(@RequestParam(\"name\") String name,\n                           @RequestParam(\"pass\") String pass) {\n        logger.info(\"name：{}\", name);\n        logger.info(\"pass：{}\", pass);\n        return new JsonResult();\n    }\n}\n```\n然后使用 Postman 来调用一下该接口，调用的时候，只传姓名，不传密码，就会抛缺少参数异常，该异常被捕获之后，就会进入我们写好的逻辑，给调用方返回一个友好信息，如下：\n\n![缺失参数异常](https://img-blog.csdnimg.cn/2020021504443480.png)\n\n\n### 2.2 处理空指针异常\n\n空指针异常是开发中司空见惯的东西了，一般发生的地方有哪些呢？  \n先来聊一聊一些注意的地方，比如在微服务中，经常会调用其他服务获取数据，这个数据主要是 json 格式的，但是在解析 json 的过程中，可能会有空出现，所以我们在获取某个 jsonObject 时，再通过该 jsonObject 去获取相关信息时，应该要先做非空判断。  \n还有一个很常见的地方就是从数据库中查询的数据，不管是查询一条记录封装在某个对象中，还是查询多条记录封装在一个 List 中，我们接下来都要去处理数据，那么就有可能出现空指针异常，因为谁也不能保证从数据库中查出来的东西就一定不为空，所以在使用数据时一定要先做非空判断。  \n对空指针异常的处理很简单，和上面的逻辑一样，将异常信息换掉即可。如下：\n```java\n@ControllerAdvice\n@ResponseBody\npublic class GlobalExceptionHandler {\n\n    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n\n    /**\n     * 空指针异常\n     * @param ex NullPointerException\n     * @return\n     */\n    @ExceptionHandler(NullPointerException.class)\n    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)\n    public JsonResult handleTypeMismatchException(NullPointerException ex) {\n        logger.error(\"空指针异常，{}\", ex.getMessage());\n        return new JsonResult(\"500\", \"空指针异常了\");\n    }\n}\n```\n这个我就不测试了，代码中 ExceptionController 有个 `testNullPointException` 方法，模拟了一个空指针异常，我们在浏览器中请求一下对应的 url 即可看到返回的信息：\n```json\n{\"code\":\"500\",\"msg\":\"空指针异常了\"}\n```\n\n### 2.3 一劳永逸？\n\n当然了，异常很多，比如还有 RuntimeException，数据库还有一些查询或者操作异常等等。由于 Exception 异常是父类，所有异常都会继承该异常，所以我们可以直接拦截 Exception 异常，一劳永逸：\n```java\n@ControllerAdvice\n@ResponseBody\npublic class GlobalExceptionHandler {\n\n    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n    /**\n     * 系统异常 预期以外异常\n     * @param ex\n     * @return\n     */\n    @ExceptionHandler(Exception.class)\n    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)\n    public JsonResult handleUnexpectedServer(Exception ex) {\n        logger.error(\"系统异常：\", ex);\n        return new JsonResult(\"500\", \"系统发生异常，请联系管理员\");\n    }\n}\n```\n但是项目中，我们一般都会比较详细的去拦截一些常见异常，拦截 Exception 虽然可以一劳永逸，但是不利于我们去排查或者定位问题。实际项目中，可以把拦截 Exception 异常写在 GlobalExceptionHandler 最下面，如果都没有找到，最后再拦截一下 Exception 异常，保证输出信息友好。\n\n## 3. 拦截自定义异常\n\n在实际项目中，除了拦截一些系统异常外，在某些业务上，我们需要自定义一些业务异常，比如在微服务中，服务之间的相互调用很平凡，很常见。要处理一个服务的调用时，那么可能会调用失败或者调用超时等等，此时我们需要自定义一个异常，当调用失败时抛出该异常，给 GlobalExceptionHandler 去捕获。\n\n### 3.1 定义异常信息\n由于在业务中，有很多异常，针对不同的业务，可能给出的提示信息不同，所以为了方便项目异常信息管理，我们一般会定义一个异常信息枚举类。比如：\n```java\n/**\n * 业务异常提示信息枚举类\n * @author shengwu ni\n */\npublic enum BusinessMsgEnum {\n    /** 参数异常 */\n    PARMETER_EXCEPTION(\"102\", \"参数异常!\"),\n    /** 等待超时 */\n    SERVICE_TIME_OUT(\"103\", \"服务调用超时！\"),\n    /** 参数过大 */\n    PARMETER_BIG_EXCEPTION(\"102\", \"输入的图片数量不能超过50张!\"),\n    /** 500 : 一劳永逸的提示也可以在这定义 */\n    UNEXPECTED_EXCEPTION(\"500\", \"系统发生异常，请联系管理员！\");\n    // 还可以定义更多的业务异常\n\n    /**\n     * 消息码\n     */\n    private String code;\n    /**\n     * 消息内容\n     */\n    private String msg;\n\n    private BusinessMsgEnum(String code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\t// set get方法\n}\n```\n\n### 3.2 拦截自定义异常\n\n然后我们可以定义一个业务异常，当出现业务异常时，我们就抛这个自定义的业务异常即可。比如我们定义一个 BusinessErrorException 异常，如下：\n```java\n/**\n * 自定义业务异常\n * @author shengwu ni\n */\npublic class BusinessErrorException extends RuntimeException {\n    \n    private static final long serialVersionUID = -7480022450501760611L;\n\n    /**\n     * 异常码\n     */\n    private String code;\n    /**\n     * 异常提示信息\n     */\n    private String message;\n\n    public BusinessErrorException(BusinessMsgEnum businessMsgEnum) {\n        this.code = businessMsgEnum.code();\n        this.message = businessMsgEnum.msg();\n    }\n\t// get set方法\n}\n```\n在构造方法中，传入我们上面自定义的异常枚举类，所以在项目中，如果有新的异常信息需要添加，我们直接在枚举类中添加即可，很方便，做到统一维护，然后再拦截该异常时获取即可。\n```java\n@ControllerAdvice\n@ResponseBody\npublic class GlobalExceptionHandler {\n\n    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n    /**\n     * 拦截业务异常，返回业务异常信息\n     * @param ex\n     * @return\n     */\n    @ExceptionHandler(BusinessErrorException.class)\n    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)\n    public JsonResult handleBusinessError(BusinessErrorException ex) {\n        String code = ex.getCode();\n        String message = ex.getMessage();\n        return new JsonResult(code, message);\n    }\n}\n```\n在业务代码中，我们可以直接模拟一下抛出业务异常，测试一下：\n```java\n@RestController\n@RequestMapping(\"/exception\")\npublic class ExceptionController {\n\n    private static final Logger logger = LoggerFactory.getLogger(ExceptionController.class);\n\n    @GetMapping(\"/business\")\n    public JsonResult testException() {\n        try {\n            int i = 1 / 0;\n        } catch (Exception e) {\n            throw new BusinessErrorException(BusinessMsgEnum.UNEXPECTED_EXCEPTION);\n        }\n        return new JsonResult();\n    }\n}\n```\n运行一下项目，测试一下，返回 json 如下，说明我们自定义的业务异常捕获成功：\n```json\n{\"code\":\"500\",\"msg\":\"系统发生异常，请联系管理员！\"}\n```\n\n## 4. 总结\n\n本节课程主要讲解了Spring Boot 的全局异常处理，包括异常信息的封装、异常信息的捕获和处理，以及在实际项目中，我们用到的自定义异常枚举类和业务异常的捕获与处理，在项目中运用的非常广泛，基本上每个项目中都需要做全局异常处理。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n\n\n\n# 第09课：Spring Boot中的切面AOP处理\n\n## 1. 什么是AOP\n\nAOP：Aspect Oriented Programming 的缩写，意为：面向切面编程。面向切面编程的目标就是分离关注点。什么是关注点呢？就是关注点，就是你要做的事情。假如你是一位公子哥，没啥人生目标，每天衣来伸手，饭来张口，整天只知道一件事：玩（这就是你的关注点，你只要做这一件事）！但是有个问题，你在玩之前，你还需要起床、穿衣服、穿鞋子、叠被子、做早饭等等等等，但是这些事情你不想关注，也不用关注，你只想想玩，那么怎么办呢？  \n\n对！这些事情通通交给下人去干。你有一个专门的仆人 A 帮你穿衣服，仆人 B 帮你穿鞋子，仆人 C 帮你叠好被子，仆人 D 帮你做饭，然后你就开始吃饭、去玩（这就是你一天的正事），你干完你的正事之后，回来，然后一系列仆人又开始帮你干这个干那个，然后一天就结束了！  \n\n这就是 AOP。AOP 的好处就是你只需要干你的正事，其它事情别人帮你干。也许有一天，你想裸奔，不想穿衣服，那么你把仆人 A 解雇就是了！也许有一天，出门之前你还想带点钱，那么你再雇一个仆人 E 专门帮你干取钱的活！这就是AOP。每个人各司其职，灵活组合，达到一种可配置的、可插拔的程序结构。\n\n## 2. Spring Boot 中的 AOP 处理\n\n### 2.1 AOP 依赖\n使用AOP，首先需要引入AOP的依赖。\n```xml\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-aop</artifactId>\n</dependency>\n```\n### 2.2 实现 AOP 切面\nSpring Boot 中使用 AOP 非常简单，假如我们要在项目中打印一些 log，在引入了上面的依赖之后，我们新建一个类 LogAspectHandler，用来定义切面和处理方法。只要在类上加个`@Aspect`注解即可。`@Aspect` 注解用来描述一个切面类，定义切面类的时候需要打上这个注解。`@Component` 注解让该类交给 Spring 来管理。\n```java\n@Aspect\n@Component\npublic class LogAspectHandler {\n\n}\n```\n这里主要介绍几个常用的注解及使用：\n> 1.@Pointcut：定义一个切面，即上面所描述的关注的某件事入口。  \n> 2.@Before：在做某件事之前做的事。  \n> 3.@After：在做某件事之后做的事。  \n> 4.@AfterReturning：在做某件事之后，对其返回值做增强处理。  \n> 5.@AfterThrowing：在做某件事抛出异常时，处理。\n\n#### 2.2.1 @Pointcut 注解\n\n`@Pointcut` 注解：用来定义一个切面（切入点），即上文中所关注的某件事情的入口。切入点决定了连接点关注的内容，使得我们可以控制通知什么时候执行。\n\n```java\n@Aspect\n@Component\npublic class LogAspectHandler {\n\n    /**\n     * 定义一个切面，拦截com.itcodai.course09.controller包和子包下的所有方法\n     */\n    @Pointcut(\"execution(* com.itcodai.course09.controller..*.*(..))\")\n    public void pointCut() {}\n}\n```\n`@Pointcut` 注解指定一个切面，定义需要拦截的东西，这里介绍两个常用的表达式：一个是使用 `execution()`，另一个是使用 `annotation()`。  \n以 `execution(* com.itcodai.course09.controller..*.*(..)))` 表达式为例，语法如下：\n> `execution()` 为表达式主体  \n> 第一个 `*` 号的位置：表示返回值类型，`*` 表示所有类型  \n> 包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，`com.itcodai.course09.controller` 包、子包下所有类的方法  \n> 第二个 `*` 号的位置：表示类名，`*` 表示所有类  \n> `*(..)` ：这个星号表示方法名，`*` 表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数\n\n`annotation()` 方式是针对某个注解来定义切面，比如我们对具有`@GetMapping`注解的方法做切面，可以如下定义切面：\n\n```java\n@Pointcut(\"@annotation(org.springframework.web.bind.annotation.GetMapping)\")\npublic void annotationCut() {}\n```\n然后使用该切面的话，就会切入注解是 `@GetMapping` 的方法。因为在实际项目中，可能对于不同的注解有不同的逻辑处理，比如 `@GetMapping`、`@PostMapping`、`@DeleteMapping` 等。所以这种按照注解的切入方式在实际项目中也很常用。\n\n#### 2.2.2 @Before 注解\n\n`@Before` 注解指定的方法在切面切入目标方法之前执行，可以做一些 log 处理，也可以做一些信息的统计，比如获取用户的请求 url 以及用户的 ip 地址等等，这个在做个人站点的时候都能用得到，都是常用的方法。例如：\n\n```java\n@Aspect\n@Component\npublic class LogAspectHandler {\n\n    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 在上面定义的切面方法之前执行该方法\n     * @param joinPoint jointPoint\n     */\n    @Before(\"pointCut()\")\n    public void doBefore(JoinPoint joinPoint) {\n        logger.info(\"====doBefore方法进入了====\");\n\n        // 获取签名\n        Signature signature = joinPoint.getSignature();\n        // 获取切入的包名\n        String declaringTypeName = signature.getDeclaringTypeName();\n        // 获取即将执行的方法名\n        String funcName = signature.getName();\n        logger.info(\"即将执行方法为: {}，属于{}包\", funcName, declaringTypeName);\n        \n        // 也可以用来记录一些信息，比如获取请求的url和ip\n        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n        HttpServletRequest request = attributes.getRequest();\n        // 获取请求url\n        String url = request.getRequestURL().toString();\n        // 获取请求ip\n        String ip = request.getRemoteAddr();\n        logger.info(\"用户请求的url为：{}，ip地址为：{}\", url, ip);\n    }\n}\n```\nJointPoint 对象很有用，可以用它来获取一个签名，然后利用签名可以获取请求的包名、方法名，包括参数（通过 `joinPoint.getArgs()` 获取）等等。\n\n#### 2.2.3 @After 注解\n\n`@After` 注解和 `@Before`  注解相对应，指定的方法在切面切入目标方法之后执行，也可以做一些完成某方法之后的 log 处理。\n\n```java\n@Aspect\n@Component\npublic class LogAspectHandler {\n\n    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 定义一个切面，拦截com.itcodai.course09.controller包下的所有方法\n     */\n    @Pointcut(\"execution(* com.itcodai.course09.controller..*.*(..))\")\n    public void pointCut() {}\n\n    /**\n     * 在上面定义的切面方法之后执行该方法\n     * @param joinPoint jointPoint\n     */\n    @After(\"pointCut()\")\n    public void doAfter(JoinPoint joinPoint) {\n\n        logger.info(\"====doAfter方法进入了====\");\n        Signature signature = joinPoint.getSignature();\n        String method = signature.getName();\n        logger.info(\"方法{}已经执行完\", method);\n    }\n}\n```\n到这里，我们来写一个 Controller 来测试一下执行结果，新建一个 AopController 如下：\n```java\n@RestController\n@RequestMapping(\"/aop\")\npublic class AopController {\n\n    @GetMapping(\"/{name}\")\n    public String testAop(@PathVariable String name) {\n        return \"Hello \" + name;\n    }\n}\n```\n启动项目，在浏览器中输入 `localhost:8080/aop/CSDN`，观察一下控制台的输出信息：\n```\n====doBefore方法进入了====  \n即将执行方法为: testAop，属于com.itcodai.course09.controller.AopController包  \n用户请求的url为：http://localhost:8080/aop/name，ip地址为：0:0:0:0:0:0:0:1  \n====doAfter方法进入了====  \n方法testAop已经执行完\n```\n从打印出来的 log 中可以看出程序执行的逻辑与顺序，可以很直观的掌握 `@Before` 和 `@After` 两个注解的实际作用。\n\n#### 2.2.4 @AfterReturning 注解\n\n`@AfterReturning` 注解和 `@After` 有些类似，区别在于 `@AfterReturning` 注解可以用来捕获切入方法执行完之后的返回值，对返回值进行业务逻辑上的增强处理，例如：\n```java\n@Aspect\n@Component\npublic class LogAspectHandler {\n\n    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 在上面定义的切面方法返回后执行该方法，可以捕获返回对象或者对返回对象进行增强\n     * @param joinPoint joinPoint\n     * @param result result\n     */\n    @AfterReturning(pointcut = \"pointCut()\", returning = \"result\")\n    public void doAfterReturning(JoinPoint joinPoint, Object result) {\n\n        Signature signature = joinPoint.getSignature();\n        String classMethod = signature.getName();\n        logger.info(\"方法{}执行完毕，返回参数为：{}\", classMethod, result);\n        // 实际项目中可以根据业务做具体的返回值增强\n        logger.info(\"对返回参数进行业务上的增强：{}\", result + \"增强版\");\n    }\n}\n```\n需要注意的是：在 `@AfterReturning`注解 中，属性 `returning` 的值必须要和参数保持一致，否则会检测不到。该方法中的第二个入参就是被切方法的返回值，在 `doAfterReturning` 方法中可以对返回值进行增强，可以根据业务需要做相应的封装。我们重启一下服务，再测试一下（多余的 log 我不贴出来了）：\n```\n方法testAop执行完毕，返回参数为：Hello CSDN  \n对返回参数进行业务上的增强：Hello CSDN增强版\n```\n\n#### 2.2.5 @AfterThrowing 注解\n\n顾名思义，`@AfterThrowing` 注解是当被切方法执行时抛出异常时，会进入 `@AfterThrowing` 注解的方法中执行，在该方法中可以做一些异常的处理逻辑。要注意的是 `throwing` 属性的值必须要和参数一致，否则会报错。该方法中的第二个入参即为抛出的异常。\n```java\n/**\n * 使用AOP处理log\n * @author shengwu ni\n * @date 2018/05/04 20:24\n */\n@Aspect\n@Component\npublic class LogAspectHandler {\n\n    private final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 在上面定义的切面方法执行抛异常时，执行该方法\n     * @param joinPoint jointPoint\n     * @param ex ex\n     */\n    @AfterThrowing(pointcut = \"pointCut()\", throwing = \"ex\")\n    public void afterThrowing(JoinPoint joinPoint, Throwable ex) {\n        Signature signature = joinPoint.getSignature();\n        String method = signature.getName();\n        // 处理异常的逻辑\n        logger.info(\"执行方法{}出错，异常为：{}\", method, ex);\n    }\n}\n```\n该方法我就不测试了，大家可以自行测试一下。\n\n## 3. 总结\n\n本节课针对 Spring Boot 中的切面 AOP 做了详细的讲解，主要介绍了 Spring Boot 中 AOP 的引入，常用注解的使用，参数的使用，以及常用 api 的介绍。AOP 在实际项目中很有用，对切面方法执行前后都可以根据具体的业务，做相应的预处理或者增强处理，同时也可以用作异常捕获处理，可以根据具体业务场景，合理去使用 AOP。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n\n\n\n# 第10课：Spring Boot集成MyBatis\n\n## 1. MyBatis 介绍\n\n大家都知道，MyBatis 框架是一个持久层框架，是 Apache 下的顶级项目。Mybatis 可以让开发者的主要精力放在 sql 上，通过 Mybatis 提供的映射方式，自由灵活的生成满足需要的 sql 语句。使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs 映射成数据库中的记录，在国内可谓是占据了半壁江山。本节课程主要通过两种方式来对 Spring Boot 集成 MyBatis 做一讲解。重点讲解一下基于注解的方式。因为实际项目中使用注解的方式更多一点，更简洁一点，省去了很多 xml 配置（这不是绝对的，有些项目组中可能也在使用 xml 的方式）。\n\n## 2. MyBatis 的配置\n\n## 2.1 依赖导入\n\nSpring Boot 集成 MyBatis，需要导入 `mybatis-spring-boot-starter` 和 mysql 的依赖，这里我们使用的版本时 1.3.2，如下：\n```xml\n<dependency>\n\t<groupId>org.mybatis.spring.boot</groupId>\n\t<artifactId>mybatis-spring-boot-starter</artifactId>\n\t<version>1.3.2</version>\n</dependency>\n<dependency>\n\t<groupId>mysql</groupId>\n\t<artifactId>mysql-connector-java</artifactId>\n\t<scope>runtime</scope>\n</dependency>\n```\n我们点开 `mybatis-spring-boot-starter` 依赖，可以看到我们之前使用 Spring 时候熟悉的依赖，就像我在课程的一开始介绍的那样，Spring Boot 致力于简化编码，使用 starter 系列将相关依赖集成在一起，开发者不需要关注繁琐的配置，非常方便。\n```xml\n<!-- 省去其他 -->\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis-spring</artifactId>\n</dependency>\n```\n\n## 2.2 properties.yml配置\n\n我们再来看一下，集成 MyBatis 时需要在 properties.yml 配置文件中做哪些基本配置呢？\n\n```xml\n# 服务端口号\nserver:\n  port: 8080\n\n# 数据库地址\ndatasource:\n  url: localhost:3306/blog_test\n\nspring:\n  datasource: # 数据库配置\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql://${datasource.url}?useSSL=false&useUnicode=true&characterEncoding=utf-8&allowMultiQueries=true&autoReconnect=true&failOverReadOnly=false&maxReconnects=10\n    username: root\n    password: 123456\n    hikari:\n      maximum-pool-size: 10 # 最大连接池数\n      max-lifetime: 1770000\n\nmybatis:\n  # 指定别名设置的包为所有entity\n  type-aliases-package: com.itcodai.course10.entity\n  configuration:\n    map-underscore-to-camel-case: true # 驼峰命名规范\n  mapper-locations: # mapper映射文件位置\n    - classpath:mapper/*.xml\n```\n我们来简单介绍一下上面的这些配置：关于数据库的相关配置，我就不详细的解说了，这点相信大家已经非常熟练了，配置一下用户名、密码、数据库连接等等，这里使用的连接池是 Spring Boot 自带的 hikari，感兴趣的朋友可以去百度或者谷歌搜一搜，了解一下。  \n\n这里说明一下 `map-underscore-to-camel-case: true`， 用来开启驼峰命名规范，这个比较好用，比如数据库中字段名为：`user_name`， 那么在实体类中可以定义属性为 `userName` （甚至可以写成 `username`，也能映射上），会自动匹配到驼峰属性，如果不这样配置的话，针对字段名和属性名不同的情况，会映射不到。\n\n## 3. 基于 xml 的整合\n\n使用原始的 xml 方式，需要新建 UserMapper.xml 文件，在上面的 application.yml 配置文件中，我们已经定义了 xml 文件的路径：`classpath:mapper/*.xml`，所以我们在 resources 目录下新建一个 mapper 文件夹，然后创建一个 UserMapper.xml 文件。\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.itcodai.course10.dao.UserMapper\">\n  <resultMap id=\"BaseResultMap\" type=\"com.itcodai.course10.entity.User\">\n\n    <id column=\"id\" jdbcType=\"BIGINT\" property=\"id\" />\n    <result column=\"user_name\" jdbcType=\"VARCHAR\" property=\"username\" />\n    <result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\" />\n  </resultMap>\n  \n   <select id=\"getUserByName\" resultType=\"User\" parameterType=\"String\">\n       select * from user where user_name = #{username}\n  </select>\n</mapper>\n```\n这和整合 Spring 一样的，namespace 中指定的是对应的 Mapper， `<resultMap>` 中指定对应的实体类，即 User。然后在内部指定表的字段和实体的属性相对应即可。这里我们写一个根据用户名查询用户的 sql。  \n\n实体类中有 id，username 和 password，我不在这贴代码，大家可以下载源码查看。UserMapper.java 文件中写一个接口即可：\n```java\nUser getUserByName(String username);\n```\n\n中间省略 service 的代码，我们写一个 Controller 来测试一下：\n```java\n@RestController\npublic class TestController {\n\n    @Resource\n    private UserService userService;\n    \n    @RequestMapping(\"/getUserByName/{name}\")\n    public User getUserByName(@PathVariable String name) {\n        return userService.getUserByName(name);\n    }\n}\n```\n启动项目，在浏览器中输入：`http://localhost:8080/getUserByName/CSDN` 即可查询到数据库表中用户名为 CSDN 的用户信息（事先搞两个数据进去即可）：\n```json\n{\"id\":2,\"username\":\"CSDN\",\"password\":\"123456\"}\n```\n这里需要注意一下：Spring Boot 如何知道这个 Mapper 呢？一种方法是在上面的 mapper 层对应的类上面添加 `@Mapper` 注解即可，但是这种方法有个弊端，当我们有很多个 mapper 时，那么每一个类上面都得添加 `@Mapper` 注解。另一种比较简便的方法是在 Spring Boot 启动类上添加`@MaperScan` 注解，来扫描一个包下的所有 mapper。如下：\n```java\n@SpringBootApplication\n@MapperScan(\"com.itcodai.course10.dao\")\npublic class Course10Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Course10Application.class, args);\n\t}\n}\n```\n这样的话，`com.itcodai.course10.dao` 包下的所有 mapper 都会被扫描到了。\n\n## 4. 基于注解的整合\n\n基于注解的整合就不需要 xml 配置文件了，MyBatis 主要提供了 `@Select`， `@Insert`， `@Update`， `Delete` 四个注解。这四个注解是用的非常多的，也很简单，注解后面跟上对应的 sql 语句即可，我们举个例子：\n```java\n@Select(\"select * from user where id = #{id}\")\nUser getUser(Long id);\n```\n这跟 xml 文件中写 sql 语句是一样的，这样就不需要 xml 文件了，但是有个问题，有人可能会问，如果是两个参数呢？如果是两个参数，我们需要使用 `@Param` 注解来指定每一个参数的对应关系，如下：\n```java\n@Select(\"select * from user where id = #{id} and user_name=#{name}\")\nUser getUserByIdAndName(@Param(\"id\") Long id, @Param(\"name\") String username);\n```\n可以看出，`@Param` 指定的参数应该要和 sql 中 `#{}` 取的参数名相同，不同则取不到。可以在 controller 中自行测试一下，接口都在源码中，文章中我就不贴测试代码和结果了。  \n\n有个问题需要注意一下，一般我们在设计表字段后，都会根据自动生成工具生成实体类，这样的话，基本上实体类是能和表字段对应上的，最起码也是驼峰对应的，由于在上面配置文件中开启了驼峰的配置，所以字段都是能对的上的。但是，万一有对不上的呢？我们也有解决办法，使用 `@Results` 注解来解决。\n```java\n@Select(\"select * from user where id = #{id}\")\n@Results({\n        @Result(property = \"username\", column = \"user_name\"),\n        @Result(property = \"password\", column = \"password\")\n})\nUser getUser(Long id);\n```\n`@Results` 中的 `@Result` 注解是用来指定每一个属性和字段的对应关系，这样的话就可以解决上面说的这个问题了。  \n\n当然了，我们也可以 xml 和注解相结合使用，目前我们实际的项目中也是采用混用的方式，因为有时候 xml 方便，有时候注解方便，比如就上面这个问题来说，如果我们定义了上面的这个 UserMapper.xml，那么我们完全可以使用 `@ResultMap` 注解来替代 `@Results` 注解，如下：\n```java\n@Select(\"select * from user where id = #{id}\")\n@ResultMap(\"BaseResultMap\")\nUser getUser(Long id);\n```\n`@ResultMap` 注解中的值从哪来呢？对应的是 UserMapper.xml 文件中定义的 `<resultMap>` 时对应的 id 值：\n```xml\n<resultMap id=\"BaseResultMap\" type=\"com.itcodai.course10.entity.User\">\n```\n这种 xml 和注解结合着使用的情况也很常见，而且也减少了大量的代码，因为 xml 文件可以使用自动生成工具去生成，也不需要人为手动敲，所以这种使用方式也很常见。\n\n## 5. 总结\n\n本节课主要系统的讲解了 Spring Boot 集成 MyBatis 的过程，分为基于 xml 形式和基于注解的形式来讲解，通过实际配置手把手讲解了 Spring Boot 中 MyBatis 的使用方式，并针对注解方式，讲解了常见的问题已经解决方式，有很强的实战意义。在实际项目中，建议根据实际情况来确定使用哪种方式，一般 xml 和注解都在用。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n\n\n\n# 第11课：Spring Boot事务配置管理\n\n## 1. 事务相关\n\n场景：我们在开发企业应用时，由于数据操作在顺序执行的过程中，线上可能有各种无法预知的问题，任何一步操作都有可能发生异常，异常则会导致后续的操作无法完成。此时由于业务逻辑并未正确的完成，所以在之前操作过数据库的动作并不可靠，需要在这种情况下进行数据的回滚。  \n\n事务的作用就是为了保证用户的每一个操作都是可靠的，事务中的每一步操作都必须成功执行，只要有发生异常就回退到事务开始未进行操作的状态。这很好理解，转账、购票等等，必须整个事件流程全部执行完才能人为该事件执行成功，不能转钱转到一半，系统死了，转账人钱没了，收款人钱还没到。\n\n事务管理是 Spring Boot 框架中最为常用的功能之一，我们在实际应用开发时，基本上在 service 层处理业务逻辑的时候都要加上事务，当然了，有时候可能由于场景需要，也不用加事务（比如我们就要往一个表里插数据，相互没有影响，插多少是多少，不能因为某个数据挂了，把之前插的全部回滚）。\n\n## 2. Spring Boot 事务配置\n\n### 2.1 依赖导入\n在 Spring Boot 中使用事务，需要导入 mysql 依赖：\n```xml\n<dependency>\n\t<groupId>org.mybatis.spring.boot</groupId>\n\t<artifactId>mybatis-spring-boot-starter</artifactId>\n\t<version>1.3.2</version>\n</dependency>\n```\n导入了 mysql 依赖后，Spring Boot 会自动注入 DataSourceTransactionManager，我们不需要任何其他的配置就可以用 `@Transactional` 注解进行事务的使用。关于 mybatis 的配置，在上一节课中已经说明了，这里还是使用上一节课中的 mybatis 配置即可。  \n\n### 2.2 事务的测试\n\n我们首先在数据库表中插入一条数据：\n|id|user_name|password|\n|:--:|:--:|:--:|\n|1|倪升武|123456|\n\n然后我们写一个插入的 mapper：\n```java\npublic interface UserMapper {\n\n    @Insert(\"insert into user (user_name, password) values (#{username}, #{password})\")\n    Integer insertUser(User user);\n}\n```\nOK，接下来我们来测试一下 Spring Boot 中的事务处理，在 service 层，我们手动抛出个异常来模拟实际中出现的异常，然后观察一下事务有没有回滚，如果数据库中没有新的记录，则说明事务回滚成功。\n```java\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Resource\n    private UserMapper userMapper;\n\n    @Override\n    @Transactional\n    public void isertUser(User user) {\n        // 插入用户信息\n        userMapper.insertUser(user);\n        // 手动抛出异常\n        throw new RuntimeException();\n    }\n}\n```\n我们来测试一下：\n```java\n@RestController\npublic class TestController {\n\n    @Resource\n    private UserService userService;\n\n    @PostMapping(\"/adduser\")\n    public String addUser(@RequestBody User user) throws Exception {\n        if (null != user) {\n            userService.isertUser(user);\n            return \"success\";\n        } else {\n            return \"false\";\n        }\n    }\n}\n```\n我们使用 postman 调用一下该接口，因为在程序中抛出了个异常，会造成事务回滚，我们刷新一下数据库，并没有增加一条记录，说明事务生效了。事务很简单，我们平时在使用的时候，一般不会有多少问题，但是并不仅仅如此……\n\n\n## 3. 常见问题总结\n\n从上面的内容中可以看出，Spring Boot 中使用事务非常简单，`@Transactional` 注解即可解决问题，说是这么说，但是在实际项目中，是有很多小坑在等着我们，这些小坑是我们在写代码的时候没有注意到，而且正常情况下不容易发现这些小坑，等项目写大了，某一天突然出问题了，排查问题非常困难，到时候肯定是抓瞎，需要费很大的精力去排查问题。  \n\n这一小节，我专门针对实际项目中经常出现的，和事务相关的细节做一下总结，希望读者在读完之后，能够落实到自己的项目中，能有所受益。\n\n### 3.1 异常并没有被 ”捕获“ 到\n\n首先要说的，就是异常并没有被 ”捕获“ 到，导致事务并没有回滚。我们在业务层代码中，也许已经考虑到了异常的存在，或者编辑器已经提示我们需要抛出异常，但是这里面有个需要注意的地方：并不是说我们把异常抛出来了，有异常了事务就会回滚，我们来看一个例子：\n```java\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Resource\n    private UserMapper userMapper;\n    \n    @Override\n    @Transactional\n    public void isertUser2(User user) throws Exception {\n        // 插入用户信息\n        userMapper.insertUser(user);\n        // 手动抛出异常\n        throw new SQLException(\"数据库异常\");\n    }\n}\n```\n我们看上面这个代码，其实并没有什么问题，手动抛出一个 `SQLException` 来模拟实际中操作数据库发生的异常，在这个方法中，既然抛出了异常，那么事务应该回滚，实际却不如此，读者可以使用我源码中 controller 的接口，通过 postman 测试一下，就会发现，仍然是可以插入一条用户数据的。  \n\n那么问题出在哪呢？因为 Spring Boot 默认的事务规则是遇到运行异常（RuntimeException）和程序错误（Error）才会回滚。比如上面我们的例子中抛出的 RuntimeException 就没有问题，但是抛出 SQLException 就无法回滚了。针对非运行时异常，如果要进行事务回滚的话，可以在 `@Transactional` 注解中使用 `rollbackFor` 属性来指定异常，比如 `@Transactional(rollbackFor = Exception.class)`，这样就没有问题了，所以在实际项目中，一定要指定异常。\n\n### 3.2 异常被 ”吃“ 掉\n\n这个标题很搞笑，异常怎么会被吃掉呢？还是回归到现实项目中去，我们在处理异常时，有两种方式，要么抛出去，让上一层来捕获处理；要么把异常 try catch 掉，在异常出现的地方给处理掉。就因为有这中 try...catch，所以导致异常被 ”吃“ 掉，事务无法回滚。我们还是看上面那个例子，只不过简单修改一下代码：\n```java\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Resource\n    private UserMapper userMapper;\n\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public void isertUser3(User user) {\n        try {\n            // 插入用户信息\n            userMapper.insertUser(user);\n            // 手动抛出异常\n            throw new SQLException(\"数据库异常\");\n        } catch (Exception e) {\n\t\t\t// 异常处理逻辑\n        }\n    }\n}\n```\n读者可以使用我源码中 controller 的接口，通过 postman 测试一下，就会发现，仍然是可以插入一条用户数据，说明事务并没有因为抛出异常而回滚。这个细节往往比上面那个坑更难以发现，因为我们的思维很容易导致 try...catch 代码的产生，一旦出现这种问题，往往排查起来比较费劲，所以我们平时在写代码时，一定要多思考，多注意这种细节，尽量避免给自己埋坑。  \n\n那这种怎么解决呢？直接往上抛，给上一层来处理即可，千万不要在事务中把异常自己 ”吃“ 掉。\n\n### 3.3 事务的范围\n\n事务范围这个东西比上面两个坑埋的更深！我之所以把这个也写上，是因为这是我之前在实际项目中遇到的，该场景在这个课程中我就不模拟了，我写一个 demo 让大家看一下，把这个坑记住即可，以后在写代码时，遇到并发问题，就会注意这个坑了，那么这节课也就有价值了。  \n\n我来写个 demo：\n```java\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Resource\n    private UserMapper userMapper;\n\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public synchronized void isertUser4(User user) {\n        // 实际中的具体业务……\n        userMapper.insertUser(user);\n    }\n}\n```\n可以看到，因为要考虑并发问题，我在业务层代码的方法上加了个 synchronized 关键字。我举个实际的场景，比如一个数据库中，针对某个用户，只有一条记录，下一个插入动作过来，会先判断该数据库中有没有相同的用户，如果有就不插入，就更新，没有才插入，所以理论上，数据库中永远就一条同一用户信息，不会出现同一数据库中插入了两条相同用户的信息。  \n\n但是在压测时，就会出现上面的问题，数据库中确实有两条同一用户的信息，分析其原因，在于事务的范围和锁的范围问题。  \n\n从上面方法中可以看到，方法上是加了事务的，那么也就是说，在执行该方法开始时，事务启动，执行完了后，事务关闭。但是 synchronized 没有起作用，其实根本原因是因为事务的范围比锁的范围大。也就是说，在加锁的那部分代码执行完之后，锁释放掉了，但是事务还没结束，此时另一个线程进来了，事务没结束的话，第二个线程进来时，数据库的状态和第一个线程刚进来是一样的。即由于mysql Innodb引擎的默认隔离级别是可重复读（在同一个事务里，SELECT的结果是事务开始时时间点的状态），线程二事务开始的时候，线程一还没提交完成，导致读取的数据还没更新。第二个线程也做了插入动作，导致了脏数据。  \n\n这个问题可以避免，第一，把事务去掉即可（不推荐）；第二，在调用该 service 的地方加锁，保证锁的范围比事务的范围大即可。\n\n## 4. 总结\n\n本章主要总结了 Spring Boot 中如何使用事务，只要使用 `@Transactional` 注解即可使用，非常简单方便。除此之外，重点总结了三个在实际项目中可能遇到的坑点，这非常有意义，因为事务这东西不出问题还好，出了问题比较难以排查，所以总结的这三点注意事项，希望能帮助到开发中的朋友。\n\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n\n\n\n# 第12课：Spring Boot中使用监听器\n\n## 1. 监听器介绍\n\n什么是 web 监听器？web 监听器是一种 Servlet 中特殊的类，它们能帮助开发者监听 web 中特定的事件，比如 ServletContext, HttpSession, ServletRequest 的创建和销毁；变量的创建、销毁和修改等。可以在某些动作前后增加处理，实现监控。\n\n## 2. Spring Boot中监听器的使用\n\nweb 监听器的使用场景很多，比如监听 servlet 上下文用来初始化一些数据、监听 http session 用来获取当前在线的人数、监听客户端请求的 servlet request 对象来获取用户的访问信息等等。这一节中，我们主要通过这三个实际的使用场景来学习一下 Spring Boot 中监听器的使用。\n\n### 2.1 监听Servlet上下文对象\n\n监听 servlet 上下文对象可以用来初始化数据，用于缓存。什么意思呢？我举一个很常见的场景，比如用户在点击某个站点的首页时，一般都会展现出首页的一些信息，而这些信息基本上或者大部分时间都保持不变的，但是这些信息都是来自数据库。如果用户的每次点击，都要从数据库中去获取数据的话，用户量少还可以接受，如果用户量非常大的话，这对数据库也是一笔很大的开销。  \n\n针对这种首页数据，大部分都不常更新的话，我们完全可以把它们缓存起来，每次用户点击的时候，我们都直接从缓存中拿，这样既可以提高首页的访问速度，又可以降低服务器的压力。如果做的更加灵活一点，可以再加个定时器，定期的来更新这个首页缓存。就类似与 CSDN 个人博客首页中排名的变化一样。\n\n下面我们针对这个功能，来写一个 demo，在实际中，读者可以完全套用该代码，来实现自己项目中的相关逻辑。首先写一个 Service，模拟一下从数据库查询数据：\n```java\n@Service\npublic class UserService {\n\n    /**\n     * 获取用户信息\n     * @return\n     */\n    public User getUser() {\n        // 实际中会根据具体的业务场景，从数据库中查询对应的信息\n        return new User(1L, \"倪升武\", \"123456\");\n    }\n}\n```\n然后写一个监听器，实现 `ApplicationListener<ContextRefreshedEvent>` 接口，重写 `onApplicationEvent` 方法，将 ContextRefreshedEvent 对象传进去。如果我们想在加载或刷新应用上下文时，也重新刷新下我们预加载的资源，就可以通过监听 ContextRefreshedEvent 来做这样的事情。如下：\n```java\n/**\n * 使用ApplicationListener来初始化一些数据到application域中的监听器\n * @author shengni ni\n * @date 2018/07/05\n */\n@Component\npublic class MyServletContextListener implements ApplicationListener<ContextRefreshedEvent> {\n\n    @Override\n    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {\n        // 先获取到application上下文\n        ApplicationContext applicationContext = contextRefreshedEvent.getApplicationContext();\n        // 获取对应的service\n        UserService userService = applicationContext.getBean(UserService.class);\n        User user = userService.getUser();\n        // 获取application域对象，将查到的信息放到application域中\n        ServletContext application = applicationContext.getBean(ServletContext.class);\n        application.setAttribute(\"user\", user);\n    }\n}\n```\n正如注释中描述的一样，首先通过 contextRefreshedEvent 来获取 application 上下文，再通过 application 上下文来获取 UserService 这个 bean，项目中可以根据实际业务场景，也可以获取其他的 bean，然后再调用自己的业务代码获取相应的数据，最后存储到 application 域中，这样前端在请求相应数据的时候，我们就可以直接从 application 域中获取信息，减少数据库的压力。下面写一个 Controller 直接从 application 域中获取 user 信息来测试一下。\n```java\n@RestController\n@RequestMapping(\"/listener\")\npublic class TestController {\n\n    @GetMapping(\"/user\")\n    public User getUser(HttpServletRequest request) {\n        ServletContext application = request.getServletContext();\n        return (User) application.getAttribute(\"user\");\n    }\n}\n```\n启动项目，在浏览器中输入 `http://localhost:8080/listener/user` 测试一下即可，如果正常返回 user 信息，那么说明数据已经缓存成功。不过 application 这种是缓存在内存中，对内存会有消耗，后面的课程中我会讲到 redis，到时候再给大家介绍一下 redis 的缓存。\n\n### 2.2 监听HTTP会话 Session对象\n\n监听器还有一个比较常用的地方就是用来监听 session 对象，来获取在线用户数量，现在有很多开发者都有自己的网站，监听 session 来获取当前在下用户数量是个很常见的使用场景，下面来介绍一下如何来使用。\n```java\n/**\n * 使用HttpSessionListener统计在线用户数的监听器\n * @author shengwu ni\n * @date 2018/07/05\n */\n@Component\npublic class MyHttpSessionListener implements HttpSessionListener {\n\n    private static final Logger logger = LoggerFactory.getLogger(MyHttpSessionListener.class);\n\n    /**\n     * 记录在线的用户数量\n     */\n    public Integer count = 0;\n\n    @Override\n    public synchronized void sessionCreated(HttpSessionEvent httpSessionEvent) {\n        logger.info(\"新用户上线了\");\n        count++;\n        httpSessionEvent.getSession().getServletContext().setAttribute(\"count\", count);\n    }\n\n    @Override\n    public synchronized void sessionDestroyed(HttpSessionEvent httpSessionEvent) {\n        logger.info(\"用户下线了\");\n        count--;\n        httpSessionEvent.getSession().getServletContext().setAttribute(\"count\", count);\n    }\n}\n```\n可以看出，首先该监听器需要实现 HttpSessionListener 接口，然后重写 `sessionCreated` 和 `sessionDestroyed` 方法，在 `sessionCreated` 方法中传递一个 HttpSessionEvent 对象，然后将当前 session 中的用户数量加1，`sessionDestroyed` 方法刚好相反，不再赘述。然后我们写一个 Controller 来测试一下。\n```java\n@RestController\n@RequestMapping(\"/listener\")\npublic class TestController {\n\n    /**\n     * 获取当前在线人数，该方法有bug\n     * @param request\n     * @return\n     */\n    @GetMapping(\"/total\")\n    public String getTotalUser(HttpServletRequest request) {\n        Integer count = (Integer) request.getSession().getServletContext().getAttribute(\"count\");\n        return \"当前在线人数：\" + count;\n    }\n}\n```\n该 Controller 中是直接获取当前 session 中的用户数量，启动服务器，在浏览器中输入 `localhost:8080/listener/total` 可以看到返回的结果是1，再打开一个浏览器，请求相同的地址可以看到 count 是 2 ，这没有问题。但是如果关闭一个浏览器再打开，理论上应该还是2，但是实际测试却是 3。原因是 session 销毁的方法没有执行（可以在后台控制台观察日志打印情况），当重新打开时，服务器找不到用户原来的 session，于是又重新创建了一个 session，那怎么解决该问题呢？我们可以将上面的 Controller 方法改造一下：\n```java\n@GetMapping(\"/total2\")\npublic String getTotalUser(HttpServletRequest request, HttpServletResponse response) {\n    Cookie cookie;\n    try {\n        // 把sessionId记录在浏览器中\n        cookie = new Cookie(\"JSESSIONID\", URLEncoder.encode(request.getSession().getId(), \"utf-8\"));\n        cookie.setPath(\"/\");\n        //设置cookie有效期为2天，设置长一点\n        cookie.setMaxAge( 48*60 * 60);\n        response.addCookie(cookie);\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    }\n    Integer count = (Integer) request.getSession().getServletContext().getAttribute(\"count\");\n    return \"当前在线人数：\" + count;\n}\n```\n可以看出，该处理逻辑是让服务器记得原来那个 session，即把原来的 sessionId 记录在浏览器中，下次再打开时，把这个 sessionId 传过去，这样服务器就不会重新再创建了。重启一下服务器，在浏览器中再次测试一下，即可避免上面的问题。\n\n### 2.3 监听客户端请求Servlet Request对象\n\n使用监听器获取用户的访问信息比较简单，实现 ServletRequestListener 接口即可，然后通过 request 对象获取一些信息。如下：\n\n```java\n/**\n * 使用ServletRequestListener获取访问信息\n * @author shengwu ni\n * @date 2018/07/05\n */\n@Component\npublic class MyServletRequestListener implements ServletRequestListener {\n\n    private static final Logger logger = LoggerFactory.getLogger(MyServletRequestListener.class);\n\n    @Override\n    public void requestInitialized(ServletRequestEvent servletRequestEvent) {\n        HttpServletRequest request = (HttpServletRequest) servletRequestEvent.getServletRequest();\n        logger.info(\"session id为：{}\", request.getRequestedSessionId());\n        logger.info(\"request url为：{}\", request.getRequestURL());\n\n        request.setAttribute(\"name\", \"倪升武\");\n    }\n\n    @Override\n    public void requestDestroyed(ServletRequestEvent servletRequestEvent) {\n\n        logger.info(\"request end\");\n        HttpServletRequest request = (HttpServletRequest) servletRequestEvent.getServletRequest();\n        logger.info(\"request域中保存的name值为：{}\", request.getAttribute(\"name\"));\n\n    }\n\n}\n```\n这个比较简单，不再赘述，接下来写一个 Controller 测试一下即可。\n```java\n@GetMapping(\"/request\")\npublic String getRequestInfo(HttpServletRequest request) {\n    System.out.println(\"requestListener中的初始化的name数据：\" + request.getAttribute(\"name\"));\n    return \"success\";\n}\n```\n\n## 3. Spring Boot中自定义事件监听\n\n在实际项目中，我们往往需要自定义一些事件和监听器来满足业务场景，比如在微服务中会有这样的场景：微服务 A 在处理完某个逻辑之后，需要通知微服务 B 去处理另一个逻辑，或者微服务 A 处理完某个逻辑之后，需要将数据同步到微服务 B，这种场景非常普遍，这个时候，我们可以自定义事件以及监听器来监听，一旦监听到微服务 A 中的某事件发生，就去通知微服务 B 处理对应的逻辑。\n\n### 3.1 自定义事件\n\n自定义事件需要继承 ApplicationEvent 对象，在事件中定义一个 User 对象来模拟数据，构造方法中将 User 对象传进来初始化。如下：\n\n```java\n/**\n * 自定义事件\n * @author shengwu ni\n * @date 2018/07/05\n */\npublic class MyEvent extends ApplicationEvent {\n\n    private User user;\n\n    public MyEvent(Object source, User user) {\n        super(source);\n        this.user = user;\n    }\n\n    // 省去get、set方法\n}\n```\n\n### 3.2 自定义监听器\n\n接下来，自定义一个监听器来监听上面定义的 MyEvent 事件，自定义监听器需要实现 `ApplicationListener` 接口即可。如下：\n\n```java\n/**\n * 自定义监听器，监听MyEvent事件\n * @author shengwu ni\n * @date 2018/07/05\n */\n@Component\npublic class MyEventListener implements ApplicationListener<MyEvent> {\n    @Override\n    public void onApplicationEvent(MyEvent myEvent) {\n        // 把事件中的信息获取到\n        User user = myEvent.getUser();\n        // 处理事件，实际项目中可以通知别的微服务或者处理其他逻辑等等\n        System.out.println(\"用户名：\" + user.getUsername());\n        System.out.println(\"密码：\" + user.getPassword());\n\n    }\n}\n```\n然后重写 `onApplicationEvent` 方法，将自定义的 MyEvent 事件传进来，因为该事件中，我们定义了 User 对象（该对象在实际中就是需要处理的数据，在下文来模拟），然后就可以使用该对象的信息了。\n\nOK，定义好了事件和监听器之后，需要手动发布事件，这样监听器才能监听到，这需要根据实际业务场景来触发，针对本文的例子，我写个触发逻辑，如下：\n```java\n/**\n * UserService\n * @author shengwu ni\n */\n@Service\npublic class UserService {\n\n    @Resource\n    private ApplicationContext applicationContext;\n\n    /**\n     * 发布事件\n     * @return\n     */\n    public User getUser2() {\n        User user = new User(1L, \"倪升武\", \"123456\");\n        // 发布事件\n        MyEvent event = new MyEvent(this, user);\n        applicationContext.publishEvent(event);\n        return user;\n    }\n}\n```\n在 service 中注入 ApplicationContext，在业务代码处理完之后，通过 ApplicationContext 对象手动发布 MyEvent 事件，这样我们自定义的监听器就能监听到，然后处理监听器中写好的业务逻辑。\n\n最后，在 Controller 中写一个接口来测试一下：\n```java\n@GetMapping(\"/request\")\npublic String getRequestInfo(HttpServletRequest request) {\n    System.out.println(\"requestListener中的初始化的name数据：\" + request.getAttribute(\"name\"));\n    return \"success\";\n}\n```\n在浏览器中输入 `http://localhost:8080/listener/publish`，然后观察一下控制台打印的用户名和密码，即可说明自定义监听器已经生效。\n\n## 4. 总结\n\n本课系统的介绍了监听器原理，以及在 Spring Boot 中如何使用监听器，列举了监听器的三个常用的案例，有很好的实战意义。最后讲解了项目中如何自定义事件和监听器，并结合微服务中常见的场景，给出具体的代码模型，均能运用到实际项目中去，希望读者认真消化。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n\n\n\n# 第13课：Spring Boot中使用拦截器\n\n拦截器的原理很简单，是 AOP 的一种实现，专门拦截对动态资源的后台请求，即拦截对控制层的请求。使用场景比较多的是判断用户是否有权限请求后台，更拔高一层的使用场景也有，比如拦截器可以结合 websocket 一起使用，用来拦截 websocket 请求，然后做相应的处理等等。拦截器不会拦截静态资源，Spring Boot 的默认静态目录为 resources/static，该目录下的静态页面、js、css、图片等等，不会被拦截（也要看如何实现，有些情况也会拦截，我在下文会指出）。\n\n## 1. 拦截器的快速使用\n\n使用拦截器很简单，只需要两步即可：定义拦截器和配置拦截器。在配置拦截器中，Spring Boot 2.0 以后的版本和之前的版本有所不同，我会重点讲解一下这里可能出现的坑。\n\n### 1.1 定义拦截器\n定义拦截器，只需要实现 `HandlerInterceptor` 接口，`HandlerInterceptor` 接口是所有自定义拦截器或者 Spring Boot 提供的拦截器的鼻祖，所以，首先来了解下该接口。该接口中有三个方法： `preHandle(……)`、`postHandle(……)` 和 `afterCompletion(……)` 。\n\n> `preHandle(……)` 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在这个方法执行之前。所以 `preHandle(……)` 方法可以决定是否将请求放行，这是通过返回值来决定的，返回 true 则放行，返回 false 则不会向后执行。  \n> `postHandle(……)` 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在执行完了该方法，但是在 DispatcherServlet 视图渲染之前。所以在这个方法中有个 ModelAndView 参数，可以在此做一些修改动作。  \n> `afterCompletion(……)` 方法：顾名思义，该方法是在整个请求处理完成后（包括视图渲染）执行，这时做一些资源的清理工作，这个方法只有在 `preHandle(……)` 被成功执行后并且返回 true 才会被执行。  \n\n了解了该接口，接下来自定义一个拦截器。\n```java\n/**\n * 自定义拦截器\n * @author shengwu ni\n * @date 2018/08/03\n */\npublic class MyInterceptor implements HandlerInterceptor {\n\n    private static final Logger logger = LoggerFactory.getLogger(MyInterceptor.class);\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n\n        HandlerMethod handlerMethod = (HandlerMethod) handler;\n        Method method = handlerMethod.getMethod();\n        String methodName = method.getName();\n        logger.info(\"====拦截到了方法：{}，在该方法执行之前执行====\", methodName);\n        // 返回true才会继续执行，返回false则取消当前请求\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n        logger.info(\"执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染\");\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        logger.info(\"整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了\");\n    }\n}\n```\nOK，到此为止，拦截器已经定义完成，接下来就是对该拦截器进行拦截配置。\n\n### 1.2 配置拦截器\n\n在 Spring Boot 2.0 之前，我们都是直接继承 WebMvcConfigurerAdapter 类，然后重写 `addInterceptors` 方法来实现拦截器的配置。但是在 Spring Boot 2.0 之后，该方法已经被废弃了（当然，也可以继续用），取而代之的是 WebMvcConfigurationSupport 方法，如下：\n\n```java\n@Configuration\npublic class MyInterceptorConfig extends WebMvcConfigurationSupport {\n\n    @Override\n    protected void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/**\");\n        super.addInterceptors(registry);\n    }\n}\n```\n在该配置中重写 `addInterceptors` 方法，将我们上面自定义的拦截器添加进去，`addPathPatterns` 方法是添加要拦截的请求，这里我们拦截所有的请求。这样就配置好拦截器了，接下来写一个 Controller 测试一下：\n```java\n@Controller\n@RequestMapping(\"/interceptor\")\npublic class InterceptorController {\n\n    @RequestMapping(\"/test\")\n    public String test() {\n        return \"hello\";\n    }\n}\n```\n让其跳转到 hello.html 页面，直接在 hello.html 中输出 `hello interceptor` 即可。启动项目，在浏览器中输入 `localhost:8080/interceptor/test` 看一下控制台的日志：\n```\n====拦截到了方法：test，在该方法执行之前执行====  \n执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染  \n整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了\n```\n可以看出拦截器已经生效，并能看出其执行顺序。\n\n### 1.3 解决静态资源被拦截问题\n\n上文中已经介绍了拦截器的定义和配置，但是这样是否就没问题了呢？其实不然，如果使用上面这种配置的话，我们会发现一个缺陷，那就是静态资源被拦截了。可以在 resources/static/ 目录下放置一个图片资源或者 html 文件，然后启动项目直接访问，即可看到无法访问的现象。\n\n也就是说，虽然 Spring Boot 2.0 废弃了WebMvcConfigurerAdapter，但是 WebMvcConfigurationSupport 又会导致默认的静态资源被拦截，这就需要我们手动将静态资源放开。\n\n如何放开呢？除了在 MyInterceptorConfig 配置类中重写 `addInterceptors` 方法外，还需要再重写一个方法：`addResourceHandlers`，将静态资源放开：\n```java\n/**\n * 用来指定静态资源不被拦截，否则继承WebMvcConfigurationSupport这种方式会导致静态资源无法直接访问\n * @param registry\n */\n@Override\nprotected void addResourceHandlers(ResourceHandlerRegistry registry) {\n    registry.addResourceHandler(\"/**\").addResourceLocations(\"classpath:/static/\");\n    super.addResourceHandlers(registry);\n}\n```\n这样配置好之后，重启项目，静态资源也可以正常访问了。如果你是个善于学习或者研究的人，那肯定不会止步于此，没错，上面这种方式的确能解决静态资源无法访问的问题，但是，还有更方便的方式来配置。\n\n我们不继承 WebMvcConfigurationSupport 类，直接实现 WebMvcConfigurer 接口，然后重写 `addInterceptors` 方法，将自定义的拦截器添加进去即可，如下：\n```java\n@Configuration\npublic class MyInterceptorConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // 实现WebMvcConfigurer不会导致静态资源被拦截\n        registry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/**\");\n    }\n}\n```\n这样就非常方便了，实现 WebMvcConfigure 接口的话，不会拦截 Spring Boot 默认的静态资源。\n\n这两种方式都可以，具体他们之间的细节，感兴趣的读者可以做进一步的研究，由于这两种方式的不同，继承 WebMvcConfigurationSupport 类的方式可以用在前后端分离的项目中，后台不需要访问静态资源（就不需要放开静态资源了）；实现 WebMvcConfigure 接口的方式可以用在非前后端分离的项目中，因为需要读取一些图片、css、js文件等等。\n\n## 2. 拦截器使用实例\n\n### 2.1 判断用户有没有登录\n\n一般用户登录功能我们可以这么做，要么往 session 中写一个 user，要么针对每个 user 生成一个 token，第二种要更好一点，那么针对第二种方式，如果用户登录成功了，每次请求的时候都会带上该用户的 token，如果未登录，则没有该 token，服务端可以检测这个 token 参数的有无来判断用户有没有登录，从而实现拦截功能。我们改造一下 `preHandle` 方法，如下：\n```java\n@Override\npublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n\n    HandlerMethod handlerMethod = (HandlerMethod) handler;\n    Method method = handlerMethod.getMethod();\n    String methodName = method.getName();\n    logger.info(\"====拦截到了方法：{}，在该方法执行之前执行====\", methodName);\n\n    // 判断用户有没有登陆，一般登陆之后的用户都有一个对应的token\n    String token = request.getParameter(\"token\");\n    if (null == token || \"\".equals(token)) {\n        logger.info(\"用户未登录，没有权限执行……请登录\");\n        return false;\n    }\n\n    // 返回true才会继续执行，返回false则取消当前请求\n    return true;\n}\n```\n重启项目，在浏览器中输入 `localhost:8080/interceptor/test` 后查看控制台日志，发现被拦截，如果在浏览器中输入 `localhost:8080/interceptor/test?token=123` 即可正常往下走。\n\n### 2.2 取消拦截操作\n根据上文，如果我要拦截所有 `/admin` 开头的 url 请求的话，需要在拦截器配置中添加这个前缀，但是在实际项目中，可能会有这种场景出现：某个请求也是 `/admin` 开头的，但是不能拦截，比如 `/admin/login` 等等，这样的话又需要去配置。那么，可不可以做成一个类似于开关的东西，哪里不需要拦截，我就在哪里弄个开关上去，做成这种灵活的可插拔的效果呢？\n\n是可以的，我们可以定义一个注解，该注解专门用来取消拦截操作，如果某个 Controller 中的方法我们不需要拦截掉，即可在该方法上加上我们自定义的注解即可，下面先定义一个注解：\n\n```java\n/**\n * 该注解用来指定某个方法不用拦截\n */\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface UnInterception {\n}\n```\n然后在 Controller 中的某个方法上添加该注解，在拦截器处理方法中添加该注解取消拦截的逻辑，如下：\n```java\n@Override\npublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n\n    HandlerMethod handlerMethod = (HandlerMethod) handler;\n    Method method = handlerMethod.getMethod();\n    String methodName = method.getName();\n    logger.info(\"====拦截到了方法：{}，在该方法执行之前执行====\", methodName);\n\n    // 通过方法，可以获取该方法上的自定义注解，然后通过注解来判断该方法是否要被拦截\n    // @UnInterception 是我们自定义的注解\n    UnInterception unInterception = method.getAnnotation(UnInterception.class);\n    if (null != unInterception) {\n        return true;\n    }\n    // 返回true才会继续执行，返回false则取消当前请求\n    return true;\n}\n```\nController 中的方法代码可以参见源码，重启项目在浏览器中输入 `http://localhost:8080/interceptor/test2?token=123` 测试一下，可以看出，加了该注解的方法不会被拦截。\n\n## 3. 总结\n\n本节主要介绍了 Spring Boot 中拦截器的使用，从拦截器的创建、配置，到拦截器对静态资源的影响，都做了详细的分析。Spring Boot 2.0 之后拦截器的配置支持两种方式，可以根据实际情况选择不同的配置方式。最后结合实际中的使用，举了两个常用的场景，希望读者能够认真消化，掌握拦截器的使用。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n\n\n\n# 第14课：Spring Boot 中集成Redis\n\n## 1. Redis 介绍\n\nRedis 是一种非关系型数据库（NoSQL），NoSQL 是以 key-value 的形式存储的，和传统的关系型数据库不一样，不一定遵循传统数据库的一些基本要求，比如说 SQL 标准，ACID 属性，表结构等等，这类数据库主要有以下特点：非关系型的、分布式的、开源的、水平可扩展的。 \nNoSQL 使用场景有：对数据高并发读写、对海量数据的高效率存储和访问、对数据的高可扩展性和高可用性等等。 \nRedis 的 key 可以是字符串、哈希、链表、集合和有序集合。value 类型很多，包括 String、list、set、zset。这些数据类型都支持 push/pop、add/remove、取交集和并集以及更多更丰富的操作，Redis 也支持各种不同方式的排序。为了保证效率，数据都是在缓存在内存中，它也可以周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中。 有了 redis 有哪些好处呢？举个比较简单的例子，看下图： \n\n![Redis使用场景](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi80MjU4YjljMC05ZjkzLTExZTgtYTM0Zi1kOTNkYTkyMzQ3ZWE?x-oss-process=image/format,png)\n\nRedis 集群和 Mysql 是同步的，首先会从 redis 中获取数据，如果 redis 挂了，再从 mysql 中获取数据，这样网站就不会挂掉。更多关于 redis 的介绍以及使用场景，可以谷歌和百度，在这就不赘述了。\n\n## 2. Redis 安装\n\n本课程是在 vmvare 虚拟机中来安装的 redis （centos 7），学习的时候如果有自己的阿里云服务器，也可以在阿里云中来安装 redis，都可以。只要能 ping 的通云主机或者虚拟机的 ip，然后在虚拟机或者云主机中放行对应的端口（或者关掉防火墙）即可访问 redis。下面来介绍一下 redis 的安装过程：\n\n* 安装 gcc 编译\n\n因为后面安装redis的时候需要编译，所以事先得先安装gcc编译。阿里云主机已经默认安装了 gcc，如果是自己安装的虚拟机，那么需要先安装一下 gcc：\n```\nyum install gcc-c++\n```\n\n* 下载 redis\n\n有两种方式下载安装包，一种是去官网上下载（https://redis.io），然后将安装包考到 centos 中，另种方法是直接使用 wget 来下载：\n```\nwget http://download.redis.io/releases/redis-3.2.8.tar.gz\n```\n如果没有安装过 wget，可以通过如下命令安装：\n```\nyum install wget\n```\n\n* 解压安装\n\n解压安装包：\n```\ntar –vzxf redis-3.2.8.tar.gz\n```\n然后将解压的文件夹 redis-3.2.8 放到 `/usr/local/` 下，一般安装软件都放在 `/usr/local` 下。然后进入 `/usr/local/redis-3.2.8/` 文件夹下，执行 `make` 命令即可完成安装。\n【注】如果 make 失败，可以尝试如下命令：\n```\nmake MALLOC=libc\nmake install\n```\n\n* 修改配置文件\n\n安装成功之后，需要修改一下配置文件，包括允许接入的 ip，允许后台执行，设置密码等等。\n打开 redis 配置文件：`vi redis.conf`\n在命令模式下输入 `/bind` 来查找 bind 配置，按 n 来查找下一个，找到配置后，将 bind 配置成 0.0.0.0，允许任意服务器来访问 redis，即：\n```\nbind 0.0.0.0\n```\n使用同样的方法，将 daemonize 改成 yes （默认为 no），允许 redis 在后台执行。\n将 requirepass 注释打开，并设置密码为 123456（密码自己设置）。\n\n* 启动 redis\n\n在 redis-3.2.8 目录下，指定刚刚修改好的配置文件 redis.conf 来启动 redis：\n```\nredis-server ./redis.conf\n```\n再启动 redis 客户端：\n```\nredis-cli\n```\n由于我们设置了密码，在启动客户端之后，输入 `auth 123456` 即可登录进入客户端。\n然后我们来测试一下，往 redis 中插入一个数据：\n```\nset name CSDN\n```\n然后来获取 name\n```\nget name\n```\n如果正常获取到 CSDN，则说明没有问题。\n\n## 3. Spring Boot 集成 Redis\n\n### 3.1 依赖导入\nSpring Boot 集成 redis 很方便，只需要导入一个 redis 的 starter 依赖即可。如下：\n```xml\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n<!--阿里巴巴fastjson -->\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>fastjson</artifactId>\n    <version>1.2.35</version>\n</dependency>\n```\n这里也导入阿里巴巴的 fastjson 是为了在后面我们要存一个实体，为了方便把实体转换成 json 字符串存进去。\n\n### 3.2 Redis 配置\n导入了依赖之后，我们在 application.yml 文件里配置 redis：\n```yml\nserver:\n  port: 8080\nspring:\n  #redis相关配置\n  redis:\n    database: 5\n    # 配置redis的主机地址，需要修改成自己的\n    host: 192.168.48.190\n    port: 6379\n    password: 123456\n    timeout: 5000\n    jedis:\n      pool:\n        # 连接池中的最大空闲连接，默认值也是8。\n        max-idle: 500\n        # 连接池中的最小空闲连接，默认值也是0。\n        min-idle: 50\n        # 如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)\n        max-active: 1000\n        # 等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException\n        max-wait: 2000\n```\n### 3.3 常用 api 介绍\nSpring Boot 对 redis 的支持已经非常完善了，丰富的 api 已经足够我们日常的开发，这里我介绍几个最常用的供大家学习，其他 api 希望大家自己多学习，多研究。用到会去查即可。\n\n有两个 redis 模板：RedisTemplate 和 StringRedisTemplate。我们不使用 RedisTemplate，RedisTemplate 提供给我们操作对象，操作对象的时候，我们通常是以 json 格式存储，但在存储的时候，会使用 Redis 默认的内部序列化器；导致我们存进里面的是乱码之类的东西。当然了，我们可以自己定义序列化，但是比较麻烦，所以使用 StringRedisTemplate 模板。StringRedisTemplate 主要给我们提供字符串操作，我们可以将实体类等转成 json 字符串即可，在取出来后，也可以转成相应的对象，这就是上面我导入了阿里 fastjson 的原因。\n\n#### 3.3.1 redis:string 类型\n\n新建一个 RedisService，注入 StringRedisTemplate，使用 `stringRedisTemplate.opsForValue()` 可以获取 `ValueOperations<String, String>` 对象，通过该对象即可读写 redis 数据库了。如下：\n\n```java\npublic class RedisService {\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    /**\n     * set redis: string类型\n     * @param key key\n     * @param value value\n     */\n    public void setString(String key, String value){\n        ValueOperations<String, String> valueOperations = stringRedisTemplate.opsForValue();\n        valueOperations.set(key, value);\n    }\n\n    /**\n     * get redis: string类型\n     * @param key key\n     * @return\n     */\n    public String getString(String key){\n        return stringRedisTemplate.opsForValue().get(key);\n    }\n```\n该对象操作的是 string，我们也可以存实体类，只需要将实体类转换成 json 字符串即可。下面来测试一下：\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class Course14ApplicationTests {\n\n    private static final Logger logger = LoggerFactory.getLogger(Course14ApplicationTests.class);\n\n\t@Resource\n\tprivate RedisService redisService;\n\n\t@Test\n\tpublic void contextLoads() {\n        //测试redis的string类型\n        redisService.setString(\"weichat\",\"程序员私房菜\");\n        logger.info(\"我的微信公众号为：{}\", redisService.getString(\"weichat\"));\n\n        // 如果是个实体，我们可以使用json工具转成json字符串，\n        User user = new User(\"CSDN\", \"123456\");\n        redisService.setString(\"userInfo\", JSON.toJSONString(user));\n        logger.info(\"用户信息：{}\", redisService.getString(\"userInfo\"));\n    }\n}\n```\n先启动 redis，然后运行这个测试用例，观察控制台打印的日志如下：\n```\n我的微信公众号为：程序员私房菜\n用户信息：{\"password\":\"123456\",\"username\":\"CSDN\"}\n```\n#### 3.3.2 redis:hash 类型\n\nhash 类型其实原理和 string 一样的，但是有两个 key，使用 `stringRedisTemplate.opsForHash()` 可以获取 `HashOperations<String, Object, Object>` 对象。比如我们要存储订单信息，所有订单信息都放在 order 下，针对不同用户的订单实体，可以通过用户的 id 来区分，这就相当于两个 key 了。\n\n```java\n@Service\npublic class RedisService {\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    /**\n     * set redis: hash类型\n     * @param key key\n     * @param filedKey filedkey\n     * @param value value\n     */\n    public void setHash(String key, String filedKey, String value){\n        HashOperations<String, Object, Object> hashOperations = stringRedisTemplate.opsForHash();\n        hashOperations.put(key,filedKey, value);\n    }\n\n    /**\n     * get redis: hash类型\n     * @param key key\n     * @param filedkey filedkey\n     * @return\n     */\n    public String getHash(String key, String filedkey){\n        return (String) stringRedisTemplate.opsForHash().get(key, filedkey);\n    }\n}\n```\n可以看出，hash 和 string 没啥两样，只不过多了个参数，Spring Boot 中操作 redis 非常简单方便。来测试一下：\n```java\n@SpringBootTest\npublic class Course14ApplicationTests {\n\n    private static final Logger logger = LoggerFactory.getLogger(Course14ApplicationTests.class);\n\n\t@Resource\n\tprivate RedisService redisService;\n\n\t@Test\n\tpublic void contextLoads() {\n        //测试redis的hash类型\n        redisService.setHash(\"user\", \"name\", JSON.toJSONString(user));\n        logger.info(\"用户姓名：{}\", redisService.getHash(\"user\",\"name\"));\n    }\n}\n```\n#### 3.3.3 redis:list 类型\n使用 `stringRedisTemplate.opsForList()` 可以获取 `ListOperations<String, String> listOperations`  redis 列表对象，该列表是个简单的字符串列表，可以支持从左侧添加，也可以支持从右侧添加，一个列表最多包含 2 ^ 32 -1 个元素。\n\n```java\n@Service\npublic class RedisService {\n\n    @Resource\n    private StringRedisTemplate stringRedisTemplate;\n\n    /**\n     * set redis:list类型\n     * @param key key\n     * @param value value\n     * @return\n     */\n    public long setList(String key, String value){\n        ListOperations<String, String> listOperations = stringRedisTemplate.opsForList();\n        return listOperations.leftPush(key, value);\n    }\n\n    /**\n     * get redis:list类型\n     * @param key key\n     * @param start start\n     * @param end end\n     * @return\n     */\n    public List<String> getList(String key, long start, long end){\n        return stringRedisTemplate.opsForList().range(key, start, end);\n    }\n}\n```\n可以看出，这些 api 都是一样的形式，方便记忆也方便使用。具体的 api 细节我就不展开了，大家可以自己看 api 文档。其实，这些 api 根据参数和返回值也能知道它们是做什么用的。来测试一下：\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class Course14ApplicationTests {\n\n    private static final Logger logger = LoggerFactory.getLogger(Course14ApplicationTests.class);\n\n\t@Resource\n\tprivate RedisService redisService;\n\n\t@Test\n\tpublic void contextLoads() {\n        //测试redis的list类型\n        redisService.setList(\"list\", \"football\");\n        redisService.setList(\"list\", \"basketball\");\n        List<String> valList = redisService.getList(\"list\",0,-1);\n        for(String value :valList){\n            logger.info(\"list中有：{}\", value);\n        }\n    }\n}\n```\n\n## 4. 总结\n\n本节主要介绍了 redis 的使用场景、安装过程，以及 Spring Boot 中集成 redis 的详细步骤。在实际项目中，通常都用 redis 作为缓存，在查询数据库的时候，会先从 redis 中查找，如果有信息，则从 redis 中取；如果没有，则从数据库中查，并且同步到 redis 中，下次 redis 中就有了。更新和删除也是如此，都需要同步到 redis。redis 在高并发场景下运用的很多。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n\n\n\n# 第15课： Spring Boot中集成ActiveMQ\n\n## 1. JMS 和 ActiveMQ 介绍\n\n### 1.1 JMS 是啥\n\n百度百科的解释：\n> JMS 即 Java 消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java 消息服务是一个与具体平台无关的 API，绝大多数 MOM 提供商都对 JMS 提供支持。\n\nJMS 只是接口，不同的提供商或者开源组织对其有不同的实现，ActiveMQ 就是其中之一，它支持JMS，是 Apache 推出的。JMS 中有几个对象模型：\n> 连接工厂：ConnectionFactory  \n> JMS连接：Connection  \n> JMS会话：Session  \n> JMS目的：Destination  \n> JMS生产者：Producer  \n> JMS消费者：Consumer  \n> JMS消息两种类型：点对点和发布/订阅。  \n\n可以看出 JMS 实际上和 JDBC 有点类似，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。本文主要使用 ActiveMQ。\n\n### 1.2 ActiveMQ \n\nActiveMQ 是 Apache 的一个能力强劲的开源消息总线。ActiveMQ 完全支持JMS1.1和J2EE 1.4规范，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的 Java EE 应用中间仍然扮演着特殊的地位。ActiveMQ 用在异步消息的处理上，所谓异步消息即消息发送者无需等待消息接收者的处理以及返回，甚至无需关心消息是否发送成功。   \n\n异步消息主要有两种目的地形式，队列（queue）和主题（topic），队列用于点对点形式的消息通信，主题用于发布/订阅式的消息通信。本章节主要来学习一下在 Spring Boot 中如何使用这两种形式的消息。\n\n## 2. ActiveMQ安装\n\n使用 ActiveMQ 首先需要去官网下载，官网地址为：http://activemq.apache.org/  \n本课程使用的版本是 apache-activemq-5.15.3，下载后解压缩会有一个名为 apache-activemq-5.15.3 的文件夹，没错，这就安装好了，非常简单，开箱即用。打开文件夹会看到里面有个 `activemq-all-5.15.3.jar`，这个 jar 我们是可以加进工程里的，但是使用 maven 的话，这个 jar 我们不需要。\n\n在使用 ActiveMQ 之前，首先得先启动，刚才解压后的目录中有个 bin 目录，里面有 win32 和 win64 两个目录，根据自己电脑选择其中一个打开运行里面的 activemq.bat 即可启动 ActiveMQ。  \n消息生产者生产消息发布到queue中，然后消息消费者从queue中取出，并且消费消息。这里需要注意：消息被消费者消费以后，queue中不再有存储，所以消息消费者不可消费到已经被消费的消息。Queue支持存在多个消息消费者，但是对一个消息而言，只会有一个消费者可以消费\n启动完成后，在浏览器中输入 `http://127.0.0.1:8161/admin/` 来访问 ActiveMQ 的服务器，用户名和密码是 admin/admin。如下：\n\n![activemq](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi9jZmI5YzQ2MC1hYTk0LTExZTgtODg4Zi1kZjMzYmU4ZWQxOTE?x-oss-process=image/format,png)\n\n我们可以看到有 Queues 和 Topics 这两个选项，这两个选项分别是点对点消息和发布/订阅消息的查看窗口。何为点对点消息和发布/订阅消息呢？\n\n点对点消息：消息生产者生产消息发布到 queue 中，然后消息消费者从 queue 中取出，并且消费消息。这里需要注意：消息被消费者消费以后，queue 中不再有存储，所以消息消费者不可消费到已经被消费的消息。Queue 支持存在多个消息消费者，但是对一个消息而言，只会有一个消费者可以消费。\n\n发布/订阅消息：消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。下面分析具体的实现方式。\n\n## 3. ActiveMQ集成\n\n### 3.1 依赖导入和配置\n\n在 Spring Boot 中集成 ActiveMQ 需要导入如下 starter 依赖：\n\n```xml\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-activemq</artifactId>\n</dependency>\n```\n然后在 application.yml 配置文件中，对 activemq 做一下配置：\n\n```yml\nspring:\n  activemq:\n  \t# activemq url\n    broker-url: tcp://localhost:61616\n    in-memory: true\n    pool:\n      # 如果此处设置为true，需要添加activemq-pool的依赖包，否则会自动配置失败，无法注入JmsMessagingTemplate\n      enabled: false\n```\n\n### 3.2 Queue 和 Topic 的创建\n\n首先我们需要创建两种消息 Queue 和 Topic，这两种消息的创建，我们放到 ActiveMqConfig 中来创建，如下：\n```java\n/**\n * activemq的配置\n * @author  shengwu ni\n */\n@Configuration\npublic class ActiveMqConfig {\n    /**\n     * 发布/订阅模式队列名称\n     */\n    public static final String TOPIC_NAME = \"activemq.topic\";\n    /**\n     * 点对点模式队列名称\n     */\n    public static final String QUEUE_NAME = \"activemq.queue\";\n\n    @Bean\n    public Destination topic() {\n        return new ActiveMQTopic(TOPIC_NAME);\n    }\n\n    @Bean\n    public Destination queue() {\n        return new ActiveMQQueue(QUEUE_NAME);\n    }\n}\n```\n可以看出创建 Queue 和 Topic 两种消息，分别使用 `new ActiveMQQueue` 和 `new ActiveMQTopic` 来创建，分别跟上对应消息的名称即可。这样在其他地方就可以直接将这两种消息作为组件注入进来了。\n\n### 3.3 消息的发送接口\n\n在 Spring Boot 中，我们只要注入 JmsMessagingTemplate 模板即可快速发送消息，如下：\n\n```java\n/**\n * 消息发送者\n * @author shengwu ni\n */\n@Service\npublic class MsgProducer {\n\n    @Resource\n    private JmsMessagingTemplate jmsMessagingTemplate;\n\n    public void sendMessage(Destination destination, String msg) {\n        jmsMessagingTemplate.convertAndSend(destination, msg);\n    }\n}\n```\n`convertAndSend` 方法中第一个参数是消息发送的目的地，第二个参数是具体的消息内容。\n\n\n### 3.4 点对点消息生产与消费\n\n#### 3.4.1 点对点消息的生产\n\n消息的生产，我们放到 Controller 中来做，由于上面已经生成了 Queue 消息的组件，所以在 Controller 中我们直接注入进来即可。然后调用上文的消息发送方法 `sendMessage` 即可成功生产一条消息。\n```java\n/**\n * ActiveMQ controller\n * @author shengwu ni\n */\n@RestController\n@RequestMapping(\"/activemq\")\npublic class ActiveMqController {\n\n    private static final Logger logger = LoggerFactory.getLogger(ActiveMqController.class);\n\n    @Resource\n    private MsgProducer producer;\n    @Resource\n    private Destination queue;\n\n    @GetMapping(\"/send/queue\")\n    public String sendQueueMessage() {\n\n        logger.info(\"===开始发送点对点消息===\");\n        producer.sendMessage(queue, \"Queue: hello activemq!\");\n        return \"success\";\n    }\n}\n```\n#### 3.4.2 点对点消息的消费\n\n点对点消息的消费很简单，只要我们指定目的地即可，jms 监听器一直在监听是否有消息过来，如果有，则消费。\n```java\n/**\n * 消息消费者\n * @author shengwu ni\n */\n@Service\npublic class QueueConsumer {\n\n    /**\n     * 接收点对点消息\n     * @param msg\n     */\n    @JmsListener(destination = ActiveMqConfig.QUEUE_NAME)\n    public void receiveQueueMsg(String msg) {\n        System.out.println(\"收到的消息为：\" + msg);\n    }\n}\n```\n可以看出，使用 `@JmsListener` 注解来指定要监听的目的地，在消息接收方法内部，我们可以根据具体的业务需求做相应的逻辑处理即可。\n\n#### 3.4.3 测试一下\n\n启动项目，在浏览器中输入：`http://localhost:8081/activemq/send/queue`，观察控制台的输出日志，出现下面的日志说明消息发送和消费成功。\n```\n收到的消息为：Queue: hello activemq!\n```\n\n### 3.5 发布/订阅消息的生产和消费\n\n#### 3.5.1 发布/订阅消息的生产\n\n和点对点消息一样，我们注入 topic 并调用 producer 的 `sendMessage` 方法即可发送订阅消息，如下，不再赘述：\n```java\n@RestController\n@RequestMapping(\"/activemq\")\npublic class ActiveMqController {\n\n    private static final Logger logger = LoggerFactory.getLogger(ActiveMqController.class);\n\n    @Resource\n    private MsgProducer producer;\n    @Resource\n    private Destination topic;\n\n    @GetMapping(\"/send/topic\")\n    public String sendTopicMessage() {\n\n        logger.info(\"===开始发送订阅消息===\");\n        producer.sendMessage(topic, \"Topic: hello activemq!\");\n        return \"success\";\n    }\n}\n```\n\n#### 3.5.2 发布/订阅消息的消费\n\n发布/订阅消息的消费和点对点不同，订阅消息支持多个消费者一起消费。其次，Spring Boot 中默认的时点对点消息，所以在使用 topic 时，会不起作用，我们需要在配置文件 application.yml 中添加一个配置：\n```yml\nspring:\n  jms:\n    pub-sub-domain: true\n```\n该配置是 false 的话，则为点对点消息，也是 Spring Boot 默认的。这样是可以解决问题，但是如果这样配置的话，上面提到的点对点消息又不能正常消费了。所以二者不可兼得，这并非一个好的解决办法。\n\n比较好的解决办法是，我们定义一个工厂，`@JmsListener` 注解默认只接收 queue 消息，如果要接收 topic 消息，需要设置一下 containerFactory。我们还在上面的那个 ActiveMqConfig 配置类中添加：\n\n```java\n/**\n * activemq的配置\n *\n * @author shengwu ni\n */\n@Configuration\npublic class ActiveMqConfig {\n    // 省略其他内容\n\n    /**\n     * JmsListener注解默认只接收queue消息,如果要接收topic消息,需要设置containerFactory\n     */\n    @Bean\n    public JmsListenerContainerFactory topicListenerContainer(ConnectionFactory connectionFactory) {\n        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();\n        factory.setConnectionFactory(connectionFactory);\n        // 相当于在application.yml中配置：spring.jms.pub-sub-domain=true\n        factory.setPubSubDomain(true);\n        return factory;\n    }\n}\n```\n经过这样的配置之后，我们在消费的时候，在 `@JmsListener` 注解中指定这个容器工厂即可消费 topic 消息。如下：\n\n```java\n/**\n * Topic消息消费者\n * @author shengwu ni\n */\n@Service\npublic class TopicConsumer1 {\n\n    /**\n     * 接收订阅消息\n     * @param msg\n     */\n    @JmsListener(destination = ActiveMqConfig.TOPIC_NAME, containerFactory = \"topicListenerContainer\")\n    public void receiveTopicMsg(String msg) {\n        System.out.println(\"收到的消息为：\" + msg);\n    }\n\n}\n```\n指定 containerFactory 属性为上面我们自己配置的 topicListenerContainer 即可。由于 topic 消息可以多个消费，所以该消费的类可以拷贝几个一起测试一下，这里我就不贴代码了，可以参考我的源码测试。\n\n#### 3.5.3 测试一下\n\n启动项目，在浏览器中输入：`http://localhost:8081/activemq/send/topic`，观察控制台的输出日志，出现下面的日志说明消息发送和消费成功。\n```\n收到的消息为：Topic: hello activemq!\n收到的消息为：Topic: hello activemq!\n```\n\n## 4. 总结\n\n本章主要介绍了 jms 和 activemq 的相关概念、activemq 的安装与启动。详细分析了 Spring Boot 中点对点消息和发布/订阅消息两种方式的配置、消息生产和消费方式。ActiveMQ 是能力强劲的开源消息总线，在异步消息的处理上很有用，希望大家好好消化一下。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n\n\n\n# 第16课：Spring Boot中集成 Shiro\n\nShiro 是一个强大、简单易用的 Java 安全框架，主要用来更便捷的认证，授权，加密，会话管等等，可为任何应用提供安全保障。本课程主要来介绍 Shiro 的认证和授权功能。\n\n## 1. Shiro 三大核心组件\n\nShiro 有三大核心的组件：`Subject`、`SecurityManager` 和 `Realm`。先来看一下它们之间的关系。\n\n![三大核心组件的关系](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi8yZGQwZjVmMC1hZjRhLTExZTgtYTUxYy05M2MzOWYyNzg1YjE?x-oss-process=image/format,png)\n\n1. Subject：认证主体。它包含两个信息：Principals 和 Credentials。看一下这两个信息具体是什么。\n> Principals：身份。可以是用户名，邮件，手机号码等等，用来标识一个登录主体身份；   \n> Credentials：凭证。常见有密码，数字证书等等。\n\n说白了，就是需要认证的东西，最常见的就是用户名密码了，比如用户在登录的时候，Shiro 需要去进行身份认证，就需要 Subject 认证主体。\n\n2. SecurityManager：安全管理员。这是 Shiro 架构的核心，它就像 Shiro 内部所有原件的保护伞一样。我们在项目中一般都会配置 SecurityManager，开发人员大部分精力主要是在 Subject 认证主体上面。我们在与 Subject 进行交互的时候，实际上是 SecurityManager 在背后做一些安全操作。\n\n3. Realms：Realms 是一个域，它是连接 Shiro 和具体应用的桥梁，当需要与安全数据交互的时候，比如用户账户、访问控制等，Shiro 就会从一个或多个 Realms 中去查找。我们一般会自己定制 Realm，这在下文会详细说明。\n\n## 1. Shiro 身份和权限认证\n\n### 1.2 Shiro 身份认证\n\n我们来分析一下 Shiro 身份认证的过程，看一下官方的一个认证图：\n\n![认证过程](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi9mMjFjNTNhMC1hZjRmLTExZTgtYTUxYy05M2MzOWYyNzg1YjE?x-oss-process=image/format,png)\n\nStep1：应用程序代码在调用 `Subject.login(token)` 方法后，传入代表最终用户的身份和凭证的 AuthenticationToken 实例 token。 \n\nStep2：将 Subject 实例委托给应用程序的 SecurityManager（Shiro的安全管理）来开始实际的认证工作。这里开始真正的认证工作了。 \n\nStep3，4，5：然后 SecurityManager 就会根据具体的 realm 去进行安全认证了。 从图中可以看出，realm 可以自定义（Custom Realm）。\n\n### 1.3 Shiro 权限认证\n\n权限认证，也就是访问控制，即在应用中控制谁能访问哪些资源。在权限认证中，最核心的三个要素是：权限，角色和用户。\n\n> 权限（permission）：即操作资源的权利，比如访问某个页面，以及对某个模块的数据的添加，修改，删除，查看的权利； \n> 角色（role）：指的是用户担任的的角色，一个角色可以有多个权限； \n> 用户（user）：在 Shiro 中，代表访问系统的用户，即上面提到的 Subject 认证主体。\n\n它们之间的的关系可以用下图来表示： \n\n![用户、角色和权限的关系](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi80NGE2OGJjMC1hZjc1LTExZTgtODVlZi1kZDk4NmRhMzUxMWU?x-oss-process=image/format,png)\n\n一个用户可以有多个角色，而不同的角色可以有不同的权限，也可由有相同的权限。比如说现在有三个角色，1是普通角色，2也是普通角色，3是管理员，角色1只能查看信息，角色2只能添加信息，管理员都可以，而且还可以删除信息，类似于这样。\n\n## 2. Spring Boot 集成 Shiro 过程\n\n### 2.1 依赖导入\n\nSpring Boot 2.0.3 集成 Shiro 需要导入如下 starter 依赖：\n\n```xml\n<dependency>\n    <groupId>org.apache.shiro</groupId>\n    <artifactId>shiro-spring</artifactId>\n    <version>1.4.0</version>\n</dependency>\n```\n\n### 2.2 数据库表数据初始化\n\n这里主要涉及到三张表：用户表、角色表和权限表，其实在 demo 中，我们完全可以自己模拟一下，不用建表，但是为了更加接近实际情况，我们还是加入 mybatis，来操作数据库。下面是数据库表的脚本。\n```sql\nCREATE TABLE `t_role` (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `rolename` varchar(20) DEFAULT NULL COMMENT '角色名称',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8\n\nCREATE TABLE `t_user` (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户主键',\n  `username` varchar(20) NOT NULL COMMENT '用户名',\n  `password` varchar(20) NOT NULL COMMENT '密码',\n  `role_id` int(11) DEFAULT NULL COMMENT '外键关联role表',\n  PRIMARY KEY (`id`),\n  KEY `role_id` (`role_id`),\n  CONSTRAINT `t_user_ibfk_1` FOREIGN KEY (`role_id`) REFERENCES `t_role` (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8\n\nCREATE TABLE `t_permission` (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `permissionname` varchar(50) NOT NULL COMMENT '权限名',\n  `role_id` int(11) DEFAULT NULL COMMENT '外键关联role',\n  PRIMARY KEY (`id`),\n  KEY `role_id` (`role_id`),\n  CONSTRAINT `t_permission_ibfk_1` FOREIGN KEY (`role_id`) REFERENCES `t_role` (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8\n```\n其中，t_user，t_role 和 t_permission，分别存储用户信息，角色信息和权限信息，表建立好了之后，我们往表里插入一些测试数据。\nt_user 表：\n|id|username|password|role_id|\n|:--:|:--:|:--:|:--:|\n|1|csdn1|123456|1|\n|2|csdn2|123456|2|\n|3|csdn3|123456|3|\n\nt_role 表：\n|id|rolename|\n|:--:|:--:|\n|1|admin|\n|2|teacher|\n|3|student|\n\nt_permission 表：\n|id|permissionname|role_id|\n|:--:|:--:|:--:|\n|1|`user:*`|1|\n|2|`student:*`|2|\n\n解释一下这里的权限：`user:*`表示权限可以是 `user:create` 或者其他，`*` 处表示一个占位符，我们可以自己定义，具体的会在下文 Shiro 配置那里说明。\n\n### 2.2 自定义 Realm\n\n有了数据库表和数据之后，我们开始自定义 realm，自定义 realm 需要继承 AuthorizingRealm 类，因为该类封装了很多方法，它也是一步步继承自 Realm 类的，继承了 AuthorizingRealm 类后，需要重写两个方法：\n\n> `doGetAuthenticationInfo()` 方法：用来验证当前登录的用户，获取认证信息   \n> `doGetAuthorizationInfo()` 方法：用来为当前登陆成功的用户授予权限和角色\n\n具体实现如下，相关的解释我放在代码的注释中，这样更加方便直观：\n\n```java\n/**\n * 自定义realm\n * @author shengwu ni\n */\npublic class MyRealm extends AuthorizingRealm {\n\n    @Resource\n    private UserService userService;\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n        // 获取用户名\n        String username = (String) principalCollection.getPrimaryPrincipal();\n        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\n        // 给该用户设置角色，角色信息存在t_role表中取\n        authorizationInfo.setRoles(userService.getRoles(username));\n        // 给该用户设置权限，权限信息存在t_permission表中取\n        authorizationInfo.setStringPermissions(userService.getPermissions(username));\n        return authorizationInfo;\n    }\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n        // 根据token获取用户名，如果您不知道该该token怎么来的，先可以不管，下文会解释\n        String username = (String) authenticationToken.getPrincipal();\n        // 根据用户名从数据库中查询该用户\n        User user = userService.getByUsername(username);\n        if(user != null) {\n            // 把当前用户存到session中\n            SecurityUtils.getSubject().getSession().setAttribute(\"user\", user);\n            // 传入用户名和密码进行身份认证，并返回认证信息\n            AuthenticationInfo authcInfo = new SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), \"myRealm\");\n            return authcInfo;\n        } else {\n            return null;\n        }\n    }\n}\n```\n从上面两个方法中可以看出：验证身份的时候是根据用户输入的用户名先从数据库中查出该用户名对应的用户，这时候并没有涉及到密码，也就是说到这一步的时候，即使用户输入的密码不对，也是可以查出来该用户的，然后将该用户的正确信息封装到 authcInfo 中返回给 Shiro，接下来就是Shiro的事了，它会根据这里面的真实信息与用户前台输入的用户名和密码进行校验， 这个时候也要校验密码了，如果校验通过就让用户登录，否则跳转到指定页面。同理，权限验证的时候也是先根据用户名从数据库中获取与该用户名有关的角色和权限，然后封装到 authorizationInfo 中返回给 Shiro。\n\n### 2.3 Shiro 配置\n\n自定义的 realm 写好了，接下来需要对 Shiro 进行配置了。我们主要配置三个东西：自定义 realm、安全管理器 SecurityManager 和 Shiro 过滤器。如下：\n\n配置自定义 realm：\n```java\n@Configuration\npublic class ShiroConfig {\n\n    private static final Logger logger = LoggerFactory.getLogger(ShiroConfig.class);\n\n    /**\n     * 注入自定义的realm\n     * @return MyRealm\n     */\n    @Bean\n    public MyRealm myAuthRealm() {\n        MyRealm myRealm = new MyRealm();\n        logger.info(\"====myRealm注册完成=====\");\n        return myRealm;\n    }\n}\n```\n配置安全管理器 SecurityManager：\n```java\n@Configuration\npublic class ShiroConfig {\n\n    private static final Logger logger = LoggerFactory.getLogger(ShiroConfig.class);\n\n    /**\n     * 注入安全管理器\n     * @return SecurityManager\n     */\n    @Bean\n    public SecurityManager securityManager() {\n        // 将自定义realm加进来\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(myAuthRealm());\n        logger.info(\"====securityManager注册完成====\");\n        return securityManager;\n    }\n}\n```\n配置 SecurityManager 时，需要将上面的自定义 realm 添加进来，这样的话 Shiro 才会走到自定义的 realm 中。\n\n配置 Shiro 过滤器：\n```java\n@Configuration\npublic class ShiroConfig {\n\n    private static final Logger logger = LoggerFactory.getLogger(ShiroConfig.class);\n    \n    /**\n     * 注入Shiro过滤器\n     * @param securityManager 安全管理器\n     * @return ShiroFilterFactoryBean\n     */\n    @Bean\n    public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) {\n        // 定义shiroFactoryBean\n        ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean();\n\n        // 设置自定义的securityManager\n        shiroFilterFactoryBean.setSecurityManager(securityManager);\n\n        // 设置默认登录的url，身份认证失败会访问该url\n        shiroFilterFactoryBean.setLoginUrl(\"/login\");\n        // 设置成功之后要跳转的链接\n        shiroFilterFactoryBean.setSuccessUrl(\"/success\");\n        // 设置未授权界面，权限认证失败会访问该url\n        shiroFilterFactoryBean.setUnauthorizedUrl(\"/unauthorized\");\n\n        // LinkedHashMap是有序的，进行顺序拦截器配置\n        Map<String,String> filterChainMap = new LinkedHashMap<>();\n\n        // 配置可以匿名访问的地址，可以根据实际情况自己添加，放行一些静态资源等，anon表示放行\n        filterChainMap.put(\"/css/**\", \"anon\");\n        filterChainMap.put(\"/imgs/**\", \"anon\");\n        filterChainMap.put(\"/js/**\", \"anon\");\n        filterChainMap.put(\"/swagger-*/**\", \"anon\");\n        filterChainMap.put(\"/swagger-ui.html/**\", \"anon\");\n        // 登录url 放行\n        filterChainMap.put(\"/login\", \"anon\");\n\n        // “/user/admin” 开头的需要身份认证，authc表示要身份认证\n        filterChainMap.put(\"/user/admin*\", \"authc\");\n        // “/user/student” 开头的需要角色认证，是“admin”才允许\n        filterChainMap.put(\"/user/student*/**\", \"roles[admin]\");\n        // “/user/teacher” 开头的需要权限认证，是“user:create”才允许\n        filterChainMap.put(\"/user/teacher*/**\", \"perms[\\\"user:create\\\"]\");\n\n        // 配置logout过滤器\n        filterChainMap.put(\"/logout\", \"logout\");\n\n        // 设置shiroFilterFactoryBean的FilterChainDefinitionMap\n        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainMap);\n        logger.info(\"====shiroFilterFactoryBean注册完成====\");\n        return shiroFilterFactoryBean;\n    }\n}\n```\n配置 Shiro 过滤器时会传入一个安全管理器，可以看出，这是一环套一环，reaml -> SecurityManager -> filter。在过滤器中，我们需要定义一个 shiroFactoryBean，然后将 SecurityManager 添加进来，结合上面代码可以看出，要配置的东西主要有：\n\n> 默认登录的 url：身份认证失败会访问该 url\n> 认证成功之后要跳转的 url\n> 权限认证失败会访问该 url\n> 需要拦截或者放行的 url：这些都放在一个 map 中\n\n从上述代码中可以看出，在 map 中，针对不同的 url，有不同的权限要求，这里总结一下常用的几个权限。\n|Filter|说明|\n|:--:|:--:|\n|anon|开放权限，可以理解为匿名用户或游客，可以直接访问的|\n|authc|需要身份认证的|\n|logout|注销，执行后会直接跳转到 `shiroFilterFactoryBean.setLoginUrl();` 设置的 url，即登录页面|\n|roles[admin]|参数可写多个，表示是某个或某些角色才能通过，多个参数时写 roles[\"admin，user\"]，当有多个参数时必须每个参数都通过才算通过|\n|perms[user]|参数可写多个，表示需要某个或某些权限才能通过，多个参数时写 perms[“user, admin”]，当有多个参数时必须每个参数都通过才算通过|\n\n### 2.4 使用 Shiro 进行认证\n\n到这里，我们对 Shiro 的准备工作都做完了，接下来开始使用 Shiro 进行认证工作。我们首先来设计几个接口：\n> 接口一： 使用 `http://localhost:8080/user/admin` 来验证身份认证\n> 接口二： 使用 `http://localhost:8080/user/student` 来验证角色认证\n> 接口三： 使用 `http://localhost:8080/user/teacher` 来验证权限认证\n> 接口四： 使用 `http://localhost:8080/user/login` 来实现用户登录\n\n然后来一下认证的流程：\n> 流程一： 直接访问接口一（此时还未登录），认证失败，跳转到 login.html 页面让用户登录，登录会请求接口四，实现用户登录功能，此时 Shiro 已经保存了用户信息了。\n> 流程二： 再次访问接口一（此时用户已经登录），认证成功，跳转到 success.html 页面，展示用户信息。\n> 流程三： 访问接口二，测试角色认证是否成功。\n> 流程四： 访问接口三，测试权限认证是否成功。\n\n#### 2.4.1 身份、角色、权限认证接口\n\n```java\n@Controller\n@RequestMapping(\"/user\")\npublic class UserController {\n\n    /**\n     * 身份认证测试接口\n     * @param request\n     * @return\n     */\n    @RequestMapping(\"/admin\")\n    public String admin(HttpServletRequest request) {\n        Object user = request.getSession().getAttribute(\"user\");\n        return \"success\";\n    }\n\n    /**\n     * 角色认证测试接口\n     * @param request\n     * @return\n     */\n    @RequestMapping(\"/student\")\n    public String student(HttpServletRequest request) {\n        return \"success\";\n    }\n\n    /**\n     * 权限认证测试接口\n     * @param request\n     * @return\n     */\n    @RequestMapping(\"/teacher\")\n    public String teacher(HttpServletRequest request) {\n        return \"success\";\n    }\n}\n```\n这三个接口很简单，直接返回到指定页面展示即可，只要认证成功就会正常跳转，如果认证失败，就会跳转到上文 ShrioConfig 中配置的页面进行展示。\n\n#### 2.4.2 用户登录接口\n\n```java\n@Controller\n@RequestMapping(\"/user\")\npublic class UserController {\n\n    /**\n     * 用户登录接口\n     * @param user user\n     * @param request request\n     * @return string\n     */\n    @PostMapping(\"/login\")\n    public String login(User user, HttpServletRequest request) {\n\n        // 根据用户名和密码创建token\n        UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(), user.getPassword());\n        // 获取subject认证主体\n        Subject subject = SecurityUtils.getSubject();\n        try{\n            // 开始认证，这一步会跳到我们自定义的realm中\n            subject.login(token);\n            request.getSession().setAttribute(\"user\", user);\n            return \"success\";\n        }catch(Exception e){\n            e.printStackTrace();\n            request.getSession().setAttribute(\"user\", user);\n            request.setAttribute(\"error\", \"用户名或密码错误！\");\n            return \"login\";\n        }\n    }\n}\n```\n我们重点分析一下这个登录接口，首先会根据前端传过来的用户名和密码，创建一个 token，然后使用 SecurityUtils 来创建一个认证主体，接下来开始调用 `subject.login(token)` 开始进行身份认证了，注意这里传了刚刚创建的 token，就如注释中所述，这一步会跳转到我们自定义的 realm 中，进入 `doGetAuthenticationInfo` 方法，所以到这里，您就会明白该方法中那个参数 token 了。然后就是上文分析的那样，开始进行身份认证。\n\n#### 2.4.3 测试一下\n\n最后，启动项目，测试一下：\n浏览器请求 `http://localhost:8080/user/admin` 会进行身份认证，因为此时未登录，所以会跳转到 IndexController 中的 `/login` 接口，然后跳转到 `login.html` 页面让我们登录，使用用户名密码为 csdn/123456 登录之后，我们在浏览器中请求 `http://localhost:8080/user/student` 接口，会进行角色认证，因为数据库中 csdn1 的用户角色是 admin，所以和配置中的吻合，认证通过；我们再请求 `http://localhost:8080/user/teacher` 接口，会进行权限认证，因为数据库中 csdn1 的用户权限为 `user:*`，满足配置中的 `user:create`，所以认证通过。\n\n接下来，我们点退出，系统会注销重新让我们登录，我们使用 csdn2 这个用户来登录，重复上述操作，当在进行角色认证和权限认证这两步时，就认证不通过了，因为数据库中 csdn2 这个用户存的角色和权限与配置中的不同，所以认证不通过。\n\n\n## 3. 总结\n\n本节主要介绍了 Shiro 安全框架与 Spring Boot 的整合。先介绍了 Shiro 的三大核心组件已经它们的作用；然后介绍了 Shiro 的身份认证、角色认证和权限认证；最后结合代码，详细介绍了 Spring Boot 中是如何整合 Shiro 的，并设计了一套测试流程，逐步分析 Shiro 的工作流程和原理，让读者更直观地体会出 Shiro 的整套工作流程。Shiro 使用的很广泛，希望读者将其掌握，并能运用到实际项目中。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n\n\n\n# 第17课：Spring Boot中集成Lucence\n\n## 1. Lucence 和全文检索\n\nLucene 是什么？看一下百度百科：\n\n> Lucene是一套用于全文检索和搜寻的开源程式库，由 Apache 软件基金会支持和提供。Lucene 提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在 Java 开发环境里 Lucene 是一个成熟的免费开源工具。就其本身而言，Lucene 是当前以及最近几年最受欢迎的免费 Java 信息检索程序库。——《百度百科》\n\n### 1.1 全文检索\n这里提到了全文检索的概念，我们先来分析一下什么是全文检索，理解了全文检索之后，再理解 Lucene 的原理就非常简单了。  \n\n何为全文检索？举个例子，比如现在要在一个文件中查找某个字符串，最直接的想法就是从头开始检索，查到了就OK，这种对于小数据量的文件来说，很实用，但是对于大数据量的文件来说，就有点吃力了。或者说找包含某个字符串的文件，也是这样，如果在一个拥有几十个 G 的硬盘中找那效率可想而知，是很低的。   \n\n文件中的数据是属于非结构化数据，也就是说它没有什么结构可言，要解决上面提到的效率问题，首先我们得将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对这些有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这就叫全文搜索。即先建立索引，再对索引进行搜索的过程。 \n\n### 1.2 Lucene 建立索引的方式\n\n那么 Lucene 中是如何建立索引的呢？假设现在有两篇文章，内容如下：\n> 文章1的内容为：Tom lives in Guangzhou, I live in Guangzhou too.   \n> 文章2的内容为：He once lived in Shanghai.\n\n首先第一步是将文档传给分词组件（Tokenizer），分词组件会将文档分成一个个单词，并去除标点符号和停词。所谓的停词指的是没有特别意义的词，比如英文中的 a，the，too 等。经过分词后，得到词元（Token） 。如下：\n> 文章1经过分词后的结果：`[Tom]` `[lives]` `[Guangzhou]` `[I]` `[live]` `[Guangzhou]`   \n> 文章2经过分词后的结果：`[He]` `[lives]` `[Shanghai]`\n\n然后将词元传给语言处理组件（Linguistic Processor），对于英语，语言处理组件一般会将字母变为小写，将单词缩减为词根形式，如 ”lives” 到 ”live” 等，将单词转变为词根形式，如 ”drove” 到 ”drive” 等。然后得到词（Term）。如下：\n> 文章1经过处理后的结果：`[tom]` `[live]` `[guangzhou]` `[i]` `[live]` `[guangzhou]` \n> 文章2经过处理后的结果：`[he]` `[live]` `[shanghai]`\n\n最后将得到的词传给索引组件（Indexer），索引组件经过处理，得到下面的索引结构：\n\n|关键词|文章号[出现频率]|出现位置|\n|:--:|:--:|:--:|\n|guangzhou|1[2]|3,6|\n|he|2[1]|1|\n|i|1[1]|4|\n|live|1[2],2[1]|2,5,2|\n|shanghai|2[1]|3|\n|tom|1[1]|1|\n\n以上就是Lucene 索引结构中最核心的部分。它的关键字是按字符顺序排列的，因此 Lucene 可以用二元搜索算法快速定位关键词。实现时 Lucene 将上面三列分别作为词典文件（Term Dictionary）、频率文件（frequencies）和位置文件（positions）保存。其中词典文件不仅保存有每个关键词，还保留了指向频率文件和位置文件的指针，通过指针可以找到该关键字的频率信息和位置信息。 \n搜索的过程是先对词典二元查找、找到该词，通过指向频率文件的指针读出所有文章号，然后返回结果，然后就可以在具体的文章中根据出现位置找到该词了。所以 Lucene 在第一次建立索引的时候可能会比较慢，但是以后就不需要每次都建立索引了，就快了。\n\n理解了 Lucene 的分词原理，接下来我们在 Spring Boot 中集成 Lucene 并实现索引和搜索的功能。\n\n## 2. Spring Boot 中集成 Lucence\n\n### 2.1 依赖导入\n\n首先需要导入 Lucene 的依赖，它的依赖有好几个，如下：\n\n```xml\n<!-- Lucence核心包 -->\n<dependency>\n\t<groupId>org.apache.lucene</groupId>\n\t<artifactId>lucene-core</artifactId>\n\t<version>5.3.1</version>\n</dependency>\n\n<!-- Lucene查询解析包 -->\n<dependency>\n\t<groupId>org.apache.lucene</groupId>\n\t<artifactId>lucene-queryparser</artifactId>\n\t<version>5.3.1</version>\n</dependency>\n\n<!-- 常规的分词（英文） -->\n<dependency>\n\t<groupId>org.apache.lucene</groupId>\n\t<artifactId>lucene-analyzers-common</artifactId>\n\t<version>5.3.1</version>\n</dependency>\n\n<!--支持分词高亮  -->\n<dependency>\n\t<groupId>org.apache.lucene</groupId>\n\t<artifactId>lucene-highlighter</artifactId>\n\t<version>5.3.1</version>\n</dependency>\n\n<!--支持中文分词  -->\n<dependency>\n\t<groupId>org.apache.lucene</groupId>\n\t<artifactId>lucene-analyzers-smartcn</artifactId>\n\t<version>5.3.1</version>\n</dependency>\n```\n最后一个依赖是用来支持中文分词的，因为默认是支持英文的。那个高亮的分词依赖是最后我要做一个搜索，然后将搜到的内容高亮显示，模拟当前互联网上的做法，大家可以运用到实际项目中去。\n\n### 2.2 快速入门\n\n根据上文的分析，全文检索有两个步骤，先建立索引，再检索。所以为了测试这个过程，我新建两个 java 类，一个用来建立索引的，另一个用来检索。\n\n#### 2.2.1 建立索引\n我们自己弄几个文件，放到 `D:\\lucene\\data` 目录下，新建一个 Indexer 类来实现建立索引功能。首先在构造方法中初始化标准分词器和写索引实例。\n\n```java\npublic class Indexer {\n\n    /**\n     * 写索引实例\n     */\n    private IndexWriter writer;\n\n    /**\n     * 构造方法，实例化IndexWriter\n     * @param indexDir\n     * @throws Exception\n     */\n    public Indexer(String indexDir) throws Exception {\n        Directory dir = FSDirectory.open(Paths.get(indexDir));\n        //标准分词器，会自动去掉空格啊，is a the等单词\n        Analyzer analyzer = new StandardAnalyzer();\n        //将标准分词器配到写索引的配置中\n        IndexWriterConfig config = new IndexWriterConfig(analyzer);\n        //实例化写索引对象\n        writer = new IndexWriter(dir, config);\n    }\n}\n```\n在构造放发中传一个存放索引的文件夹路径，然后构建标准分词器（这是英文的），再使用标准分词器来实例化写索引对象。接下来就开始建立索引了，我将解释放到代码注释里，方便大家跟进。\n\n```java\n/**\n * 索引指定目录下的所有文件\n * @param dataDir\n * @return\n * @throws Exception\n */\npublic int indexAll(String dataDir) throws Exception {\n    // 获取该路径下的所有文件\n    File[] files = new File(dataDir).listFiles();\n    if (null != files) {\n        for (File file : files) {\n            //调用下面的indexFile方法，对每个文件进行索引\n            indexFile(file);\n        }\n    }\n    //返回索引的文件数\n    return writer.numDocs();\n}\n\n/**\n * 索引指定的文件\n * @param file\n * @throws Exception\n */\nprivate void indexFile(File file) throws Exception {\n    System.out.println(\"索引文件的路径：\" + file.getCanonicalPath());\n    //调用下面的getDocument方法，获取该文件的document\n    Document doc = getDocument(file);\n    //将doc添加到索引中\n    writer.addDocument(doc);\n}\n\n/**\n * 获取文档，文档里再设置每个字段，就类似于数据库中的一行记录\n * @param file\n * @return\n * @throws Exception\n */\nprivate Document getDocument(File file) throws Exception {\n    Document doc = new Document();\n    //开始添加字段\n    //添加内容\n    doc.add(new TextField(\"contents\", new FileReader(file)));\n    //添加文件名，并把这个字段存到索引文件里\n    doc.add(new TextField(\"fileName\", file.getName(), Field.Store.YES));\n    //添加文件路径\n    doc.add(new TextField(\"fullPath\", file.getCanonicalPath(), Field.Store.YES));\n    return doc;\n}\n```\n这样就建立好索引了，我们在该类中写一个 main 方法测试一下：\n```java\npublic static void main(String[] args) {\n        //索引保存到的路径\n        String indexDir = \"D:\\\\lucene\";\n        //需要索引的文件数据存放的目录\n        String dataDir = \"D:\\\\lucene\\\\data\";\n        Indexer indexer = null;\n        int indexedNum = 0;\n        //记录索引开始时间\n        long startTime = System.currentTimeMillis();\n        try {\n            // 开始构建索引\n            indexer = new Indexer(indexDir);\n            indexedNum = indexer.indexAll(dataDir);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (null != indexer) {\n                    indexer.close();\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        //记录索引结束时间\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"索引耗时\" + (endTime - startTime) + \"毫秒\");\n        System.out.println(\"共索引了\" + indexedNum + \"个文件\");\n    }\n```\n\n我搞了两个 tomcat 相关的文件放到 `D:\\lucene\\data` 下了，执行完之后，看到控制台输出：\n```\n索引文件的路径：D:\\lucene\\data\\catalina.properties\n索引文件的路径：D:\\lucene\\data\\logging.properties\n索引耗时882毫秒\n共索引了2个文件\n```\n然后我们去 `D:\\lucene\\` 目录下可以看到一些索引文件，这些文件不能删除，删除了就需要重新构建索引，否则没了索引，就无法去检索内容了。\n\n####2.2.2 检索内容\n\n上面把这两个文件的索引建立好了，接下来我们就可以写检索程序了，在这两个文件中查找特定的词。\n\n```java\npublic class Searcher {\n\n    public static void search(String indexDir, String q) throws Exception {\n\n        //获取要查询的路径，也就是索引所在的位置\n        Directory dir = FSDirectory.open(Paths.get(indexDir));\n        IndexReader reader = DirectoryReader.open(dir);\n        //构建IndexSearcher\n        IndexSearcher searcher = new IndexSearcher(reader);\n        //标准分词器，会自动去掉空格啊，is a the等单词\n        Analyzer analyzer = new StandardAnalyzer();\n        //查询解析器\n        QueryParser parser = new QueryParser(\"contents\", analyzer);\n        //通过解析要查询的String，获取查询对象，q为传进来的待查的字符串\n        Query query = parser.parse(q);\n\n        //记录索引开始时间\n        long startTime = System.currentTimeMillis();\n        //开始查询，查询前10条数据，将记录保存在docs中\n        TopDocs docs = searcher.search(query, 10);\n        //记录索引结束时间\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"匹配\" + q + \"共耗时\" + (endTime-startTime) + \"毫秒\");\n        System.out.println(\"查询到\" + docs.totalHits + \"条记录\");\n\n        //取出每条查询结果\n        for(ScoreDoc scoreDoc : docs.scoreDocs) {\n            //scoreDoc.doc相当于docID,根据这个docID来获取文档\n            Document doc = searcher.doc(scoreDoc.doc);\n            //fullPath是刚刚建立索引的时候我们定义的一个字段，表示路径。也可以取其他的内容，只要我们在建立索引时有定义即可。\n            System.out.println(doc.get(\"fullPath\"));\n        }\n        reader.close();\n    }\n}\n```\nok，这样我们检索的代码就写完了，每一步解释我写在代码中的注释上了，下面写个 main 方法来测试一下：\n```java\npublic static void main(String[] args) {\n    String indexDir = \"D:\\\\lucene\";\n    //查询这个字符串\n    String q = \"security\";\n    try {\n        search(indexDir, q);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```\n查一下 `security` 这个字符串，执行一下看控制台打印的结果：\n\n```\n匹配security共耗时23毫秒\n查询到1条记录\nD:\\lucene\\data\\catalina.properties\n```\n可以看出，耗时了23毫秒在两个文件中找到了 security 这个字符串，并输出了文件的名称。上面的代码我写的很详细，这个代码已经比较全了，可以用在生产环境上。\n\n### 2.3 中文分词检索高亮实战\n\n上文已经写了建立索引和检索的代码，但是在实际项目中，我们往往是结合页面做一些查询结果的展示，比如我要查某个关键字，查到了之后，将相关的信息点展示出来，并将查询的关键字高亮等等。这种需求在实际项目中非常常见，而且大多数网站中都会有这种效果。所以这一小节我们就使用 Lucene 来实现这种效果。\n\n#### 2.3.1 中文分词\n\n我们新建一个 ChineseIndexer 类来建立中文索引，建立过程和英文索引一样的，不同的地方在于使用的是中文分词器。除此之外，这里我们不用通过读取文件去建立索引，我们模拟一下用字符串来建立，因为在实际项目中，绝大部分情况是获取到一些文本字符串，然后根据一些关键字去查询相关内容等等。代码如下：\n```java\npublic class ChineseIndexer {\n\n    /**\n     * 存放索引的位置\n     */\n    private Directory dir;\n\n    //准备一下用来测试的数据\n    //用来标识文档\n    private Integer ids[] = {1, 2, 3};\n    private String citys[] = {\"上海\", \"南京\", \"青岛\"};\n    private String descs[] = {\n            \"上海是个繁华的城市。\",\n            \"南京是一个文化的城市南京，简称宁，是江苏省会，地处中国东部地区，长江下游，濒江近海。全市下辖11个区，总面积6597平方公里，2013年建成区面积752.83平方公里，常住人口818.78万，其中城镇人口659.1万人。[1-4] “江南佳丽地，金陵帝王州”，南京拥有着6000多年文明史、近2600年建城史和近500年的建都史，是中国四大古都之一，有“六朝古都”、“十朝都会”之称，是中华文明的重要发祥地，历史上曾数次庇佑华夏之正朔，长期是中国南方的政治、经济、文化中心，拥有厚重的文化底蕴和丰富的历史遗存。[5-7] 南京是国家重要的科教中心，自古以来就是一座崇文重教的城市，有“天下文枢”、“东南第一学”的美誉。截至2013年，南京有高等院校75所，其中211高校8所，仅次于北京上海；国家重点实验室25所、国家重点学科169个、两院院士83人，均居中国第三。[8-10] 。\",\n            \"青岛是一个美丽的城市。\"\n    };\n\n    /**\n     * 生成索引\n     * @param indexDir\n     * @throws Exception\n     */\n    public void index(String indexDir) throws Exception {\n        dir = FSDirectory.open(Paths.get(indexDir));\n        // 先调用 getWriter 获取IndexWriter对象\n        IndexWriter writer = getWriter();\n        for(int i = 0; i < ids.length; i++) {\n            Document doc = new Document();\n            // 把上面的数据都生成索引，分别用id、city和desc来标识\n            doc.add(new IntField(\"id\", ids[i], Field.Store.YES));\n            doc.add(new StringField(\"city\", citys[i], Field.Store.YES));\n            doc.add(new TextField(\"desc\", descs[i], Field.Store.YES));\n            //添加文档\n            writer.addDocument(doc);\n        }\n        //close了才真正写到文档中\n        writer.close();\n    }\n\n    /**\n     * 获取IndexWriter实例\n     * @return\n     * @throws Exception\n     */\n    private IndexWriter getWriter() throws Exception {\n        //使用中文分词器\n        SmartChineseAnalyzer analyzer = new SmartChineseAnalyzer();\n        //将中文分词器配到写索引的配置中\n        IndexWriterConfig config = new IndexWriterConfig(analyzer);\n        //实例化写索引对象\n        IndexWriter writer = new IndexWriter(dir, config);\n        return writer;\n    }\n\n    public static void main(String[] args) throws Exception {\n        new ChineseIndexer().index(\"D:\\\\lucene2\");\n    }\n}\n```\n这里我们用 id、city、desc 分别代表 id、城市名称和城市描述，用他们作为关键字来建立索引，后面我们获取内容的时候，主要来获取城市描述。南京的描述我故意写的长一点，因为下文检索的时候，根据不同的关键字会检索到不同部分的信息，有个权重的概念在里面。\n然后执行一下 main 方法，将索引保存到 `D:\\lucene2\\` 中。 \n\n#### 2.3.2 中文分词查询\n\n中文分词查询代码逻辑和默认的查询差不多，有一些区别在于，我们需要将查询出来的关键字标红加粗等需要处理，需要计算出一个得分片段，这是什么意思呢？比如我搜索 “南京文化” 跟搜索 “南京文明”，这两个搜索结果应该根据关键字出现的位置，返回的结果不一样才对，这在下文会测试。我们先看一下代码和注释：\n```java\npublic class ChineseSearch {\n\n    private static final Logger logger = LoggerFactory.getLogger(ChineseSearch.class);\n\n    public static List<String> search(String indexDir, String q) throws Exception {\n\n        //获取要查询的路径，也就是索引所在的位置\n        Directory dir = FSDirectory.open(Paths.get(indexDir));\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        //使用中文分词器\n        SmartChineseAnalyzer analyzer = new SmartChineseAnalyzer();\n        //由中文分词器初始化查询解析器\n        QueryParser parser = new QueryParser(\"desc\", analyzer);\n        //通过解析要查询的String，获取查询对象\n        Query query = parser.parse(q);\n\n        //记录索引开始时间\n        long startTime = System.currentTimeMillis();\n        //开始查询，查询前10条数据，将记录保存在docs中\n        TopDocs docs = searcher.search(query, 10);\n        //记录索引结束时间\n        long endTime = System.currentTimeMillis();\n        logger.info(\"匹配{}共耗时{}毫秒\", q, (endTime - startTime));\n        logger.info(\"查询到{}条记录\", docs.totalHits);\n\n        //如果不指定参数的话，默认是加粗，即<b><b/>\n        SimpleHTMLFormatter simpleHTMLFormatter = new SimpleHTMLFormatter(\"<b><font color=red>\",\"</font></b>\");\n        //根据查询对象计算得分，会初始化一个查询结果最高的得分\n        QueryScorer scorer = new QueryScorer(query);\n        //根据这个得分计算出一个片段\n        Fragmenter fragmenter = new SimpleSpanFragmenter(scorer);\n        //将这个片段中的关键字用上面初始化好的高亮格式高亮\n        Highlighter highlighter = new Highlighter(simpleHTMLFormatter, scorer);\n        //设置一下要显示的片段\n        highlighter.setTextFragmenter(fragmenter);\n\n        //取出每条查询结果\n        List<String> list = new ArrayList<>();\n        for(ScoreDoc scoreDoc : docs.scoreDocs) {\n            //scoreDoc.doc相当于docID,根据这个docID来获取文档\n            Document doc = searcher.doc(scoreDoc.doc);\n            logger.info(\"city:{}\", doc.get(\"city\"));\n            logger.info(\"desc:{}\", doc.get(\"desc\"));\n            String desc = doc.get(\"desc\");\n\n            //显示高亮\n            if(desc != null) {\n                TokenStream tokenStream = analyzer.tokenStream(\"desc\", new StringReader(desc));\n                String summary = highlighter.getBestFragment(tokenStream, desc);\n                logger.info(\"高亮后的desc:{}\", summary);\n                list.add(summary);\n            }\n        }\n        reader.close();\n        return list;\n    }\n}\n```\n每一步的注释我写的很详细，在这就不赘述了。接下来我们来测试一下效果。\n\n#### 2.3.3 测试一下\n\n这里我们使用 thymeleaf 来写个简单的页面来展示获取到的数据，并高亮展示。在 controller 中我们指定索引的目录和需要查询的字符串，如下：\n\n```java\n@Controller\n@RequestMapping(\"/lucene\")\npublic class IndexController {\n\n    @GetMapping(\"/test\")\n    public String test(Model model) {\n        // 索引所在的目录\n        String indexDir = \"D:\\\\lucene2\";\n        // 要查询的字符\n//        String q = \"南京文明\";\n        String q = \"南京文化\";\n        try {\n            List<String> list = ChineseSearch.search(indexDir, q);\n            model.addAttribute(\"list\", list);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return \"result\";\n    }\n}\n```\n直接返回到 result.html 页面，该页面主要来展示一下 model 中的数据即可。\n\n```xml\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<div th:each=\"desc : ${list}\">\n    <div th:utext=\"${desc}\"></div>\n</div>\n</body>\n</html>\n```\n这里注意一下，不能使用 `th:test`，否则字符串中的 html 标签都会被转义，不会被渲染到页面。下面启动服务，在浏览器中输入 `http://localhost:8080/lucene/test`，测试一下效果，我们搜索的是 “南京文化”。\n\n![南京文化](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi84M2IzZjgxMC1iMzc3LTExZTgtODhiZi0yM2NiNzhkMWZiNGY?x-oss-process=image/format,png)\n\n再将 controller 中的搜索关键字改成 “南京文明”，看下命中的效果。\n\n![南京文明](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi84ZWY4YTRhMC1iMzc3LTExZTgtOTExZC0yN2NjNWYwNTk4Mjk?x-oss-process=image/format,png)\n\n可以看出，不同的关键词，它会计算一个得分片段，也就是说不同的关键字会命中不同位置的内容，然后将关键字根据我们自己设定的形式高亮显示。从结果中可以看出，Lucene 也可以很智能的将关键字拆分命中，这在实际项目中会很好用。\n\n## 3. 总结\n\n本节课首先详细的分析了全文检索的理论规则，然后结合 Lucene，系统的讲述了在 Spring Boot 的集成步骤，首先快速带领大家从直观上感受 Lucene 如何建立索引已经如果检索，其次通过中文检索的具体实例，展示了 Lucene 在全文检索中的广泛应用。Lucene 不难，主要就是步骤比较多，代码不用死记硬背，拿到项目中根据实际情况做对应的修改即可。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n\n\n\n# 第18课：Spring Boot搭建实际项目开发中的架构\n\n前面的课程中，我主要给大家讲解了 Spring Boot 中常用的一些技术点，这些技术点在实际项目中可能不会全部用得到，因为不同的项目可能使用的技术不同，但是希望大家都能掌握如何使用，并能自己根据实际项目中的需求进行相应的扩展。\n\n不知道大家了不了解单片机，单片机里有个最小系统，这个最小系统搭建好了之后，就可以在此基础上进行人为的扩展。这节课我们要做的就是搭建一个 “Spring Boot 最小系统架构” 。拿着这个架构，可以在此基础上根据实际需求做相应的扩展。\n\n从零开始搭建一个环境，主要要考虑几点：统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（本文不写该项，因为现在大部分项目都前后端分离了，但是考虑到也还有非前后端分离的项目，所以我在源代码里也加上了 thymeleaf）、持久层的集成、拦截器（这个也是可选的）和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了。\n\n结合前面的课程和以上的这些点，本节课手把手带领大家搭建一个实际项目开发中可用的 Spring Boot 架构。整个项目工程如下图所示，学习的时候，可以结合我的源码，这样效果会更好。\n\n![工程架构](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0Ym9vay5jbi82ZjIzYzk4MC1iODllLTExZTgtODdmMS01NTljOWI0NTY3NTQ?x-oss-process=image/format,png)\n\n## 1. 统一的数据封装 \n\n由于封装的 json 数据的类型不确定，所以在定义统一的 json 结构时，我们需要用到泛型。统一的 json 结构中属性包括数据、状态码、提示信息即可，构造方法可以根据实际业务需求做相应的添加即可，一般来说，应该有默认的返回结构，也应该有用户指定的返回结构。如下：\n```java\n/**\n * 统一返回对象\n * @author shengwu ni\n * @param <T>\n */\npublic class JsonResult<T> {\n\n    private T data;\n    private String code;\n    private String msg;\n\n    /**\n     * 若没有数据返回，默认状态码为0，提示信息为：操作成功！\n     */\n    public JsonResult() {\n        this.code = \"0\";\n        this.msg = \"操作成功！\";\n    }\n\n    /**\n     * 若没有数据返回，可以人为指定状态码和提示信息\n     * @param code\n     * @param msg\n     */\n    public JsonResult(String code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\n    /**\n     * 有数据返回时，状态码为0，默认提示信息为：操作成功！\n     * @param data\n     */\n    public JsonResult(T data) {\n        this.data = data;\n        this.code = \"0\";\n        this.msg = \"操作成功！\";\n    }\n\n    /**\n     * 有数据返回，状态码为0，人为指定提示信息\n     * @param data\n     * @param msg\n     */\n    public JsonResult(T data, String msg) {\n        this.data = data;\n        this.code = \"0\";\n        this.msg = msg;\n    }\n    \n    /**\n     * 使用自定义异常作为参数传递状态码和提示信息\n     * @param msgEnum\n     */\n    public JsonResult(BusinessMsgEnum msgEnum) {\n        this.code = msgEnum.code();\n        this.msg = msgEnum.msg();\n    }\n\n    // 省去get和set方法\n}\n```\n大家可以根据自己项目中所需要的一些东西，合理的修改统一结构中的字段信息。\n\n## 2. json的处理\n\nJson 处理工具很多，比如阿里巴巴的 fastjson，不过 fastjson 对有些未知类型的 null 无法转成空字符串，这可能是 fastjson 自身的缺陷，可扩展性也不是太好，但是使用起来方便，使用的人也蛮多的。这节课里面我们主要集成 Spring Boot 自带的 jackson。主要是对 jackson 做一下对 null 的配置即可，然后就可以在项目中使用了。\n\n```java\n/**\n * jacksonConfig\n * @author shengwu ni\n */\n@Configuration\npublic class JacksonConfig {\n    @Bean\n    @Primary\n    @ConditionalOnMissingBean(ObjectMapper.class)\n    public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {\n        ObjectMapper objectMapper = builder.createXmlMapper(false).build();\n        objectMapper.getSerializerProvider().setNullValueSerializer(new JsonSerializer<Object>() {\n            @Override\n            public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {\n                jsonGenerator.writeString(\"\");\n            }\n        });\n        return objectMapper;\n    }\n}\n```\n这里先不测试，等下面 swagger2 配置好了之后，我们一起来测试一下。\n\n## 3. swagger2在线可调式接口\n\n有了 swagger，开发人员不需要给其他人员提供接口文档，只要告诉他们一个 Swagger 地址，即可展示在线的 API 接口文档，除此之外，调用接口的人员还可以在线测试接口数据，同样地，开发人员在开发接口时，同样也可以利用 Swagger 在线接口文档测试接口数据，这给开发人员提供了便利。使用 swagger 需要对其进行配置：\n```java\n/**\n * swagger配置\n * @author shengwu ni\n */\n@Configuration\n@EnableSwagger2\npublic class SwaggerConfig {\n\n    @Bean\n    public Docket createRestApi() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                // 指定构建api文档的详细信息的方法：apiInfo()\n                .apiInfo(apiInfo())\n                .select()\n                // 指定要生成api接口的包路径，这里把controller作为包路径，生成controller中的所有接口\n                .apis(RequestHandlerSelectors.basePackage(\"com.itcodai.course18.controller\"))\n                .paths(PathSelectors.any())\n                .build();\n    }\n\n    /**\n     * 构建api文档的详细信息\n     * @return\n     */\n    private ApiInfo apiInfo() {\n        return new ApiInfoBuilder()\n                // 设置页面标题\n                .title(\"Spring Boot搭建实际项目中开发的架构\")\n                // 设置接口描述\n                .description(\"跟武哥一起学Spring Boot第18课\")\n                // 设置联系方式\n                .contact(\"倪升武，\" + \"微信公众号：程序员私房菜\")\n                // 设置版本\n                .version(\"1.0\")\n                // 构建\n                .build();\n    }\n}\n```\n到这里，可以先测试一下，写一个 Controller，弄一个静态的接口测试一下上面集成的内容。\n```java\n@RestController\n@Api(value = \"用户信息接口\")\npublic class UserController {\n\n    @Resource\n    private UserService userService;\n\n    @GetMapping(\"/getUser/{id}\")\n    @ApiOperation(value = \"根据用户唯一标识获取用户信息\")\n    public JsonResult<User> getUserInfo(@PathVariable @ApiParam(value = \"用户唯一标识\") Long id) {\n        User user = new User(id, \"倪升武\", \"123456\");\n        return new JsonResult<>(user);\n    }\n}\n```\n然后启动项目，在浏览器中输入 `localhost:8080/swagger-ui.html` 即可看到 swagger 接口文档页面，调用一下上面这个接口，即可看到返回的 json 数据。\n\n## 4. 持久层集成\n\n每个项目中是必须要有持久层的，与数据库交互，这里我们主要来集成 mybatis，集成 mybatis 首先要在 application.yml 中进行配置。\n```yml\n# 服务端口号\nserver:\n  port: 8080\n\n# 数据库地址\ndatasource:\n  url: localhost:3306/blog_test\n\nspring:\n  datasource: # 数据库配置\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql://${datasource.url}?useSSL=false&useUnicode=true&characterEncoding=utf-8&allowMultiQueries=true&autoReconnect=true&failOverReadOnly=false&maxReconnects=10\n    username: root\n    password: 123456\n    hikari:\n      maximum-pool-size: 10 # 最大连接池数\n      max-lifetime: 1770000\n\nmybatis:\n  # 指定别名设置的包为所有entity\n  type-aliases-package: com.itcodai.course18.entity\n  configuration:\n    map-underscore-to-camel-case: true # 驼峰命名规范\n  mapper-locations: # mapper映射文件位置\n    - classpath:mapper/*.xml\n```\n配置好了之后，接下来我们来写一下 dao 层，实际中我们使用注解比较多，因为比较方便，当然也可以使用 xml 的方式，甚至两种同时使用都行，这里我们主要使用注解的方式来集成，关于 xml 的方式，大家可以查看前面课程，实际中根据项目情况来定。\n```java\npublic interface UserMapper {\n\n    @Select(\"select * from user where id = #{id}\")\n    @Results({\n            @Result(property = \"username\", column = \"user_name\"),\n            @Result(property = \"password\", column = \"password\")\n    })\n    User getUser(Long id);\n\n    @Select(\"select * from user where id = #{id} and user_name=#{name}\")\n    User getUserByIdAndName(@Param(\"id\") Long id, @Param(\"name\") String username);\n\n    @Select(\"select * from user\")\n    List<User> getAll();\n}\n```\n关于 service 层我就不在文章中写代码了，大家可以结合我的源代码学习，这一节主要带领大家来搭建一个 Spring Boot 空架构。最后别忘了在启动类上添加注解扫描 `@MapperScan(\"com.itcodai.course18.dao\")`\n\n## 5. 拦截器\n\n拦截器在项目中使用的是非常多的（但不是绝对的），比如拦截一些置顶的 url，做一些判断和处理等等。除此之外，还需要将常用的静态页面或者 swagger 页面放行，不能将这些静态资源给拦截了。首先先自定义一个拦截器。\n```java\npublic class MyInterceptor implements HandlerInterceptor {\n\n    private static final Logger logger = LoggerFactory.getLogger(MyInterceptor.class);\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n\n        logger.info(\"执行方法之前执行(Controller方法调用之前)\");\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n        logger.info(\"执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染\");\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        logger.info(\"整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了\");\n    }\n}\n```\n然后将自定义的拦截器加入到拦截器配置中。\n```java\n@Configuration\npublic class MyInterceptorConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // 实现WebMvcConfigurer不会导致静态资源被拦截\n        registry.addInterceptor(new MyInterceptor())\n                // 拦截所有url\n                .addPathPatterns(\"/**\")\n                // 放行swagger\n                .excludePathPatterns(\"/swagger-resources/**\");\n    }\n}\n```\n在 Spring Boot 中，我们通常会在如下目录里存放一些静态资源：\n> classpath:/static   \n> classpath:/public   \n> classpath:/resources   \n> classpath:/META-INF/resources  \n\n上面代码中配置的 `/**` 是对所有 url 都进行了拦截，但我们实现了 WebMvcConfigurer 接口，不会导致 Spring Boot 对上面这些目录下的静态资源实施拦截。但是我们平时访问的 swagger 会被拦截，所以要将其放行。swagger 页面在 swagger-resources 目录下，放行该目录下所有文件即可。\n\n然后在浏览器中输入一下 swagger 页面，若能正常显示 swagger，说明放行成功。同时可以根据后台打印的日志判断代码执行的顺序。\n\n## 6. 全局异常处理\n\n全局异常处理是每个项目中必须用到的东西，在具体的异常中，我们可能会做具体的处理，但是对于没有处理的异常，一般会有一个统一的全局异常处理。在异常处理之前，最好维护一个异常提示信息枚举类，专门用来保存异常提示信息的。如下：\n```java\npublic enum BusinessMsgEnum {\n    /** 参数异常 */\n    PARMETER_EXCEPTION(\"102\", \"参数异常!\"),\n    /** 等待超时 */\n    SERVICE_TIME_OUT(\"103\", \"服务调用超时！\"),\n    /** 参数过大 */\n    PARMETER_BIG_EXCEPTION(\"102\", \"输入的图片数量不能超过50张!\"),\n    /** 500 : 发生异常 */\n    UNEXPECTED_EXCEPTION(\"500\", \"系统发生异常，请联系管理员！\");\n\n    /**\n     * 消息码\n     */\n    private String code;\n    /**\n     * 消息内容\n     */\n    private String msg;\n\n    private BusinessMsgEnum(String code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\n    public String code() {\n        return code;\n    }\n\n    public String msg() {\n        return msg;\n    }\n\n}\n```\n在全局统一异常处理类中，我们一般会对自定义的业务异常最先处理，然后去处理一些常见的系统异常，最后会来一个一劳永逸（Exception 异常）。\n```java\n@ControllerAdvice\n@ResponseBody\npublic class GlobalExceptionHandler {\n\n    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n\n    /**\n     * 拦截业务异常，返回业务异常信息\n     * @param ex\n     * @return\n     */\n    @ExceptionHandler(BusinessErrorException.class)\n    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)\n    public JsonResult handleBusinessError(BusinessErrorException ex) {\n        String code = ex.getCode();\n        String message = ex.getMessage();\n        return new JsonResult(code, message);\n    }\n\n    /**\n     * 空指针异常\n     * @param ex NullPointerException\n     * @return\n     */\n    @ExceptionHandler(NullPointerException.class)\n    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)\n    public JsonResult handleTypeMismatchException(NullPointerException ex) {\n        logger.error(\"空指针异常，{}\", ex.getMessage());\n        return new JsonResult(\"500\", \"空指针异常了\");\n    }\n\n    /**\n     * 系统异常 预期以外异常\n     * @param ex\n     * @return\n     */\n    @ExceptionHandler(Exception.class)\n    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)\n    public JsonResult handleUnexpectedServer(Exception ex) {\n        logger.error(\"系统异常：\", ex);\n        return new JsonResult(BusinessMsgEnum.UNEXPECTED_EXCEPTION);\n    }\n\n}\n```\n其中，BusinessErrorException 是自定义的业务异常，继承一下 RuntimeException 即可，具体可以看我的源代码，文章中就不贴代码了。\n在 UserController 中有个 testException 方法，用来测试全局异常的，打开 swagger 页面，调用一下该接口，可以看出返回用户提示信息：”系统发生异常，请联系管理员！“。当然了，实际情况中，需要根据不同的业务提示不同的信息。\n\n## 7. 总结\n\n本文主要手把手带领大家快速搭建一个项目中可以使用的 Spring Boot 空架构，主要从统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（代码中体现）、持久层的集成、拦截器和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n\nct * from user\")\n    List<User> getAll();\n}\n```\n关于 service 层我就不在文章中写代码了，大家可以结合我的源代码学习，这一节主要带领大家来搭建一个 Spring Boot 空架构。最后别忘了在启动类上添加注解扫描 `@MapperScan(\"com.itcodai.course18.dao\")`\n\n## 5. 拦截器\n\n拦截器在项目中使用的是非常多的（但不是绝对的），比如拦截一些置顶的 url，做一些判断和处理等等。除此之外，还需要将常用的静态页面或者 swagger 页面放行，不能将这些静态资源给拦截了。首先先自定义一个拦截器。\n```java\npublic class MyInterceptor implements HandlerInterceptor {\n\n    private static final Logger logger = LoggerFactory.getLogger(MyInterceptor.class);\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n\n        logger.info(\"执行方法之前执行(Controller方法调用之前)\");\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n        logger.info(\"执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染\");\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        logger.info(\"整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了\");\n    }\n}\n```\n然后将自定义的拦截器加入到拦截器配置中。\n```java\n@Configuration\npublic class MyInterceptorConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // 实现WebMvcConfigurer不会导致静态资源被拦截\n        registry.addInterceptor(new MyInterceptor())\n                // 拦截所有url\n                .addPathPatterns(\"/**\")\n                // 放行swagger\n                .excludePathPatterns(\"/swagger-resources/**\");\n    }\n}\n```\n在 Spring Boot 中，我们通常会在如下目录里存放一些静态资源：\n> classpath:/static   \n> classpath:/public   \n> classpath:/resources   \n> classpath:/META-INF/resources  \n\n上面代码中配置的 `/**` 是对所有 url 都进行了拦截，但我们实现了 WebMvcConfigurer 接口，不会导致 Spring Boot 对上面这些目录下的静态资源实施拦截。但是我们平时访问的 swagger 会被拦截，所以要将其放行。swagger 页面在 swagger-resources 目录下，放行该目录下所有文件即可。\n\n然后在浏览器中输入一下 swagger 页面，若能正常显示 swagger，说明放行成功。同时可以根据后台打印的日志判断代码执行的顺序。\n\n## 6. 全局异常处理\n\n全局异常处理是每个项目中必须用到的东西，在具体的异常中，我们可能会做具体的处理，但是对于没有处理的异常，一般会有一个统一的全局异常处理。在异常处理之前，最好维护一个异常提示信息枚举类，专门用来保存异常提示信息的。如下：\n```java\npublic enum BusinessMsgEnum {\n    /** 参数异常 */\n    PARMETER_EXCEPTION(\"102\", \"参数异常!\"),\n    /** 等待超时 */\n    SERVICE_TIME_OUT(\"103\", \"服务调用超时！\"),\n    /** 参数过大 */\n    PARMETER_BIG_EXCEPTION(\"102\", \"输入的图片数量不能超过50张!\"),\n    /** 500 : 发生异常 */\n    UNEXPECTED_EXCEPTION(\"500\", \"系统发生异常，请联系管理员！\");\n\n    /**\n     * 消息码\n     */\n    private String code;\n    /**\n     * 消息内容\n     */\n    private String msg;\n\n    private BusinessMsgEnum(String code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\n    public String code() {\n        return code;\n    }\n\n    public String msg() {\n        return msg;\n    }\n\n}\n```\n在全局统一异常处理类中，我们一般会对自定义的业务异常最先处理，然后去处理一些常见的系统异常，最后会来一个一劳永逸（Exception 异常）。\n```java\n@ControllerAdvice\n@ResponseBody\npublic class GlobalExceptionHandler {\n\n    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n\n    /**\n     * 拦截业务异常，返回业务异常信息\n     * @param ex\n     * @return\n     */\n    @ExceptionHandler(BusinessErrorException.class)\n    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)\n    public JsonResult handleBusinessError(BusinessErrorException ex) {\n        String code = ex.getCode();\n        String message = ex.getMessage();\n        return new JsonResult(code, message);\n    }\n\n    /**\n     * 空指针异常\n     * @param ex NullPointerException\n     * @return\n     */\n    @ExceptionHandler(NullPointerException.class)\n    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)\n    public JsonResult handleTypeMismatchException(NullPointerException ex) {\n        logger.error(\"空指针异常，{}\", ex.getMessage());\n        return new JsonResult(\"500\", \"空指针异常了\");\n    }\n\n    /**\n     * 系统异常 预期以外异常\n     * @param ex\n     * @return\n     */\n    @ExceptionHandler(Exception.class)\n    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)\n    public JsonResult handleUnexpectedServer(Exception ex) {\n        logger.error(\"系统异常：\", ex);\n        return new JsonResult(BusinessMsgEnum.UNEXPECTED_EXCEPTION);\n    }\n\n}\n```\n其中，BusinessErrorException 是自定义的业务异常，继承一下 RuntimeException 即可，具体可以看我的源代码，文章中就不贴代码了。\n在 UserController 中有个 testException 方法，用来测试全局异常的，打开 swagger 页面，调用一下该接口，可以看出返回用户提示信息：”系统发生异常，请联系管理员！“。当然了，实际情况中，需要根据不同的业务提示不同的信息。\n\n## 7. 总结\n\n本文主要手把手带领大家快速搭建一个项目中可以使用的 Spring Boot 空架构，主要从统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（代码中体现）、持久层的集成、拦截器和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了。\n\n课程源代码下载地址：[戳我下载](https://gitee.com/eson15/springboot_study)\n\n","tags":["Java","SpringBoot"],"categories":["MyTech","Java"]},{"title":"技术 lucene","url":"/posts/3115972334/","content":"\n@[toc]\n## ―、什么是全文检索\n\n### 1、数据的分类\n\n​    1.结构化数据\n\n​        格式固定、长度固定、数据类型固定\n<!-- more -->\n​        例如数据库中的数据\n\n​    2.非结构化数据\n\n​        word文档，pdf文档、邮件、html、xml\n\n​        格式不固定、长度不固定、数据类型不固定\n\n### 2、数据的査词\n\n​    1.结构化数据的査词\n\n​        SQL语句，査词结构化数据的方法。简单、速度快\n\n​    2.非结构化数据的査词\n\n​        从文本文件中找出包含spring单词的文件，\n\n​        1.目测\n\n​        2.使用程序把文档读取到内存中，然后匹配字符串。顺序扫描\n\n​        3.把非结构化数据变成结构化数据\n\n​            先根据空格进行字符拿拆分，得到一个单词列表.基于单词列表创建一个索引\n\n​            然后查询索引，根据单词和文档的对应关系找到文档列表，这个过程叫做全文检索\n\n​            索引： 一个为了提高査词速度.创建某种数据结构的集合\n\n### 3、全文检索\n\n​    先创建索引然后查询索引的过程叫做全文检索\n\n​    索引一次创建可以多次使用，表现为每次查询速度很快.\n\n## 二、 全文检索的应用场景\n\n​    1、 搜索引擎\n\n​        百度、360搜索、谷歌、搜狗\n\n​    2、 站内搜京\n\n​        论坛搜索、微博、文章搜索\n\n​    3、 电商搜索\n\n​        淘宝搜索、京东搜索\n\n​    4、 只要是有搜索的地方就可以使用全文检索技术\n\n##  三、 什么是Lucene\n\n​    Lucene是一个基于java开发全文检索工具包\n\n## 四、 Lucene实现全文检索的流程\n\n### 1.创建索引\n\n​    1.获得文档\n\n​            原始文档：要基于那些数据来进行搜索.那么这些数据就是原始文档\n\n​            搜索引擎：使用爬虫获得原始文档\n\n​            站内搜索：数据库中的数据。\n\n​            案例：直接使用 io 流读取磁盘上的文件。\n\n​    2.构建文档对象\n\n​        对应每个原始文档创建一个 Document 对象\n\n​        每个Document对象中包含多个域（ field ) \n\n​        域中保存就是原始文档数据。\n\n​            域的名称\n\n​            域的值\n\n​        每个文档都有一个唯一的编号，就是文档id\n\n​    3.分析文档\n\n​        就是分词的过程 \n\n​            1.根据空格进行字符串拆分．得到一个单词列表 \n\n​            2.把单词统一转换成小写。\n\n​            3.去除标点符号\n\n​            4.去除停用词\n\n​            停用词：无意义的词\n\n​            每个关键词都封装成一个下 Term对象中。\n\n​                Term中包含两部分内容：\n\n​                    关键词所在的域\n\n​                    关键词本者\n\n​                不同的域中拆分出来的相同的关键词是不同的 Term\n\n​    4.创建索引\n\n​        基于关键词列表创建一个索引．保存到索引库中。\n\n​        索引库中：\n\n​            索引 \n\n​            document 对象\n\n​            关键词和文档的对应关系\n\n​        通过词语找文档．这种索引的结构叫倒排索引结构。\n\n### 2.查询索引 \n\n​    1.用户查询接口\n\n​        用户输入查询条件的地方\n\n​        例如：百度的搜索框\n\n​    2.把关键词封装成一个查询对象\n\n​        要查询的域\n\n​        要搜索的关键词\n\n​    3.执行查询\n\n​        根据要查询的关键词到对应的域上进行搜索。\n\n​        找到关键词，根据关键词找到对应的文档\n\n​    4.渲染结果\n\n​        根据文档的 id 找到文档对象\n\n​        对关键词进行高亮显示\n\n​        分页处理\n\n​        最终展示给用户看。\n\n## 五、入门程序 \n\n### 1 ．创建索引\n\n​    环境：\n\n​        需要下载 Lucene \n\n​        http//lucene.apache.org/\n\n​        最低要求jdk1.8\n\n​    工程搭建：\n\n​        创建一个 java 工程\n\n​        添加 jar ： \n\n​            lucene-analyzers-common-7.4.0.jar \n\n​            lucene-core-7.4.0.jar \n\n​            commons-io-jar\n\n​    步骤： \n\n​        1. 创建一个Director对象．指定索引库保存的位置 。 \n\n​        2. 基于 Directory 对象创建一个 IndexWriter对象 \n\n​        3. 读取磁盘上的文件．对应每个文件创建一个文档对象。 \n\n​        4. 向文档对象中添加域 \n\n​        5. 把文档对象写入索引库 \n\n6. 关闭 indexwriter 对象 \n\n   ```java\n   //创建索引\n   @Test\n   public void createIndex() throws Exception {\n\n       //指定索引库存放的路径\n       //D:\\temp\\index\n       Directory directory = FSDirectory.open(new File(\"D:\\\\temp\\\\index\").toPath());\n       //索引库还可以存放到内存中\n       //Directory directory = new RAMDirectory();\n       //创建indexwriterCofig对象\n       IndexWriterConfig config = new IndexWriterConfig();\n       //创建indexwriter对象\n       IndexWriter indexWriter = new IndexWriter(directory, config);\n       //原始文档的路径\n       File dir = new File(\"D:\\\\temp\\\\searchsource\");\n       for (File f : dir.listFiles()) {\n           //文件名\n           String fileName = f.getName();\n           //文件内容\n           String fileContent = FileUtils.readFileToString(f);\n           //文件路径\n           String filePath = f.getPath();\n           //文件的大小\n           long fileSize  = FileUtils.sizeOf(f);\n           //创建文件名域\n           //第一个参数：域的名称\n           //第二个参数：域的内容\n           //第三个参数：是否存储\n           Field fileNameField = new TextField(\"filename\", fileName, Field.Store.YES);\n           //文件内容域\n           Field fileContentField = new TextField(\"content\", fileContent, Field.Store.YES);\n           //文件路径域（不分析、不索引、只存储）\n           Field filePathField = new TextField(\"path\", filePath, Field.Store.YES);\n           //文件大小域\n           Field fileSizeField = new TextField(\"size\", fileSize + \"\", Field.Store.YES);\n\n           //创建document对象\n           Document document = new Document();\n           document.add(fileNameField);\n           document.add(fileContentField);\n           document.add(filePathField);\n           document.add(fileSizeField);\n           //创建索引，并写入索引库\n           indexWriter.addDocument(document);\n       }\n       //关闭indexwriter\n       indexWriter.close();\n   }\n\n   ```\n\n   ​\n\n### 2. 使用 luke 查看索引库中的内容 \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217132455985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n\n\n### 3. 查询索引库\n\n   步骤： \n\n​       1. 创建一个 Directory 对象，指定索引库的位置 \n\n​       2. 创建一个 IndexReader 对象\n\n​       3. 创建一个 IndexSearcher 对象．构造方法中的参数 indexReader 对象。\n\n​       4. 创建一个 Query对象，TermQuery\n\n​       5. 执行查询，得到一个 TopDocs 对象\n\n​       6. 取查询结果的总记录数\n\n​       7. 取文档列表\n\n​       8. 打印文档中的内容\n\n9. 关闭 indexReader 对象\n\n   ```java\n   //查询索引库\n   @Test\n   public void searchIndex() throws Exception {\n       //指定索引库存放的路径\n       //D:\\temp\\index\n       Directory directory = FSDirectory.open(new File(\"D:\\\\temp\\\\index\").toPath());\n       //创建indexReader对象\n       IndexReader indexReader = DirectoryReader.open(directory);\n       //创建indexsearcher对象\n       IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n       //创建查询\n       Query query = new TermQuery(new Term(\"filename\", \"apache\"));\n       //执行查询\n       //第一个参数是查询对象，第二个参数是查询结果返回的最大值\n       TopDocs topDocs = indexSearcher.search(query, 10);\n       //查询结果的总条数\n       System.out.println(\"查询结果的总条数：\"+ topDocs.totalHits);\n       //遍历查询结果\n       //topDocs.scoreDocs存储了document对象的id\n       for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n           //scoreDoc.doc属性就是document对象的id\n           //根据document的id找到document对象\n           Document document = indexSearcher.doc(scoreDoc.doc);\n           System.out.println(document.get(\"filename\"));\n           //System.out.println(document.get(\"content\"));\n           System.out.println(document.get(\"path\"));\n           System.out.println(document.get(\"size\"));\n           System.out.println(\"-------------------------\");\n       }\n       //关闭indexreader对象\n       indexReader.close();\n   }\n   ```\n\n   ​\n\n## 六、分析器\n\n​    默认使用的数标准分析器 StandardAnalyzer\n\n### 1. 查看分析器的分析效果\n\n​    使用 Analyzer 对象的 tokenStream 方法返回一个 TokenStream 对象。词对象中包含了最终分词结果。\n\n​    实现步骤： \n\n​        1. 创建一个Analyzer对象，StandardAnalyzer对象 \n\n​        2. 使用分析器对象的 tokenStream 方法获得一个 TokenStream 对象 \n\n​        3. 向 TokenStream 对象中设置一个引用，相当于数一个指针 \n\n​        4. 调用 TokenStream 对象的 reset 方法。如果不调用抛异常 \n\n​        5. 使用 while 循环遍历 TokenStream 对象\n\n6. 关闭TokenStream对象。\n\n   ```java\n   //查看标准分析器的分词效果\n   @Test\n   public void testTokenStream() throws Exception {\n       //创建一个标准分析器对象\n       Analyzer analyzer = new StandardAnalyzer();\n       //获得tokenStream对象\n       //第一个参数：域名，可以随便给一个\n       //第二个参数：要分析的文本内容\n       TokenStream tokenStream = analyzer.tokenStream(\"test\", \"The Spring Framework provides a comprehensive programming and configuration model.\");\n       //添加一个引用，可以获得每个关键词\n       CharTermAttribute charTermAttribute = tokenStream.addAttribute(CharTermAttribute.class);\n       //添加一个偏移量的引用，记录了关键词的开始位置以及结束位置\n       OffsetAttribute offsetAttribute = tokenStream.addAttribute(OffsetAttribute.class);\n       //将指针调整到列表的头部\n       tokenStream.reset();\n       //遍历关键词列表，通过incrementToken方法判断列表是否结束\n       while(tokenStream.incrementToken()) {\n           //关键词的起始位置\n           System.out.println(\"start->\" + offsetAttribute.startOffset());\n           //取关键词\n           System.out.println(charTermAttribute);\n           //结束位置\n           System.out.println(\"end->\" + offsetAttribute.endOffset());\n       }\n       tokenStream.close();\n   }\n   ```\n\n   ​\n\n### 2. IKAnalyzer 的便用方法（中文分析器） \n\n​    1.把 IKAnalyzer 的 jar 包添加到工程中 \n\n​    2.把配置文件和扩展词典添加到工程的 classpath 下\n\n​    注意：扩展词典严禁使用weindows记事本编辑保证扩展词典的编码格式是utf-8 \n\n​    扩展词典：添加一些新词\n\n​    停用词词典：无意义的词或者是敏感词汇\n\n```java\n@Test\npublic void addDocument() throws Exception {\n    //索引库存放路径\n    Directory directory = FSDirectory.open(new File(\"D:\\\\temp\\\\index\").toPath());\n    IndexWriterConfig config = new IndexWriterConfig(new IKAnalyzer());\n    //创建一个indexwriter对象\n    IndexWriter indexWriter = new IndexWriter(directory, config);\n//...\n}\n```\n\n\n\n## 七、索引库维护 \n\n1. ### Field域的属性\n\n   **是否分析**：是否对域的内容进行分词处理。前提是我们要对域的内容进行查询。\n\n   **是否索引**：将Field分析后的词或整个Field值进行索引，只有索引方可搜索到。\n\n   比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分析但也要索引，这些将来都要作为查询条件。\n\n   **是否存储**：将Field值存储在文档中，存储在文档中的Field才可以从Document中获取\n\n   比如：商品名称、订单号，凡是将来要从Document中获取的Field都要存储。\n\n   **是否存储的标准：是否要将内容展示给用户**\n\n   | Field类                                                      | 数据类型               | Analyzed  是否分析 | Indexed  是否索引 | Stored  是否存储 | 说明                                                         |\n   | ------------------------------------------------------------ | ---------------------- | ------------------ | ----------------- | ---------------- | ------------------------------------------------------------ |\n   | StringField(FieldName,  FieldValue,Store.YES))               | 字符串                 | N                  | Y                 | Y或N             | 这个Field用来构建一个字符串Field，但是不会进行分析，会将整个串存储在索引中，比如(订单号,姓名等)  是否存储在文档中用Store.YES或Store.NO决定 |\n   | LongPoint(String name, long... point)                        | Long型                 | Y                  | Y                 | N                | 可以使用LongPoint、IntPoint等类型存储数值类型的数据。让数值类型可以进行索引。但是不能存储数据，如果想存储数据还需要使用StoredField。 |\n   | StoredField(FieldName, FieldValue)                           | 重载方法，支持多种类型 | N                  | N                 | Y                | 这个Field用来构建不同类型Field  不分析，不索引，但要Field存储在文档中 |\n   | TextField(FieldName, FieldValue, Store.NO)  或  TextField(FieldName, reader) | 字符串  或  流         | Y                  | Y                 | Y或N             | 如果是一个Reader, lucene猜测内容比较多,会采用Unstored的策略. |\n\n2. ###  添加文档\n\n   ```java\n   //添加索引\n   @Test\n   public void addDocument() throws Exception {\n       //索引库存放路径\n       Directory directory = FSDirectory.open(new File(\"D:\\\\temp\\\\index\").toPath());\n       IndexWriterConfig config = new IndexWriterConfig(new IKAnalyzer());\n       //创建一个indexwriter对象\n       IndexWriter indexWriter = new IndexWriter(directory, config);\n       //创建一个Document对象\n       Document document = new Document();\n       //向document对象中添加域。\n       //不同的document可以有不同的域，同一个document可以有相同的域。\n       document.add(new TextField(\"filename\", \"新添加的文档\", Field.Store.YES));\n       document.add(new TextField(\"content\", \"新添加的文档的内容\", Field.Store.NO));\n       //LongPoint创建索引\n       document.add(new LongPoint(\"size\", 1000l));\n       //StoreField存储数据\n       document.add(new StoredField(\"size\", 1000l));\n       //不需要创建索引的就使用StoreField存储\n       document.add(new StoredField(\"path\", \"d:/temp/1.txt\"));\n       //添加文档到索引库\n       indexWriter.addDocument(document);\n       //关闭indexwriter\n       indexWriter.close();\n   }\n   ```\n\n   ​\n\n3. ###  删除文档\n\n4. 删除全部 (说明：将索引目录的索引信息全部删除，直接彻底删除，无法恢复)\n\n   ```java\n   //删除全部索引\n   \t@Test\n   \tpublic void deleteAllIndex() throws Exception {\n   \t\tIndexWriter indexWriter = getIndexWriter();\n   \t\t//删除全部索引\n   \t\tindexWriter.deleteAll();\n   \t\t//关闭indexwriter\n   \t\tindexWriter.close();\n   \t}\n   ```\n\n5. 根据查询、关键词删除文档 , \n\n   ```java\n   //根据查询条件删除索引\n   \t@Test\n   \tpublic void deleteIndexByQuery() throws Exception {\n   \t\tIndexWriter indexWriter = getIndexWriter();\n   \t\t//创建一个查询条件\n   \t\tQuery query = new TermQuery(new Term(\"filename\", \"apache\"));\n   \t\t//根据查询条件删除\n   \t\tindexWriter.deleteDocuments(query);\n   \t\t//关闭indexwriter\n   \t\tindexWriter.close();\n   \t}\n   ```\n\n   ​\n\n### 3. 修改文档\n\n​    修改的原理是先删除后添加\n\n```java\n//修改索引库\n@Test\npublic void updateIndex() throws Exception {\n    IndexWriter indexWriter = getIndexWriter();\n    //创建一个Document对象\n    Document document = new Document();\n    //向document对象中添加域。\n    //不同的document可以有不同的域，同一个document可以有相同的域。\n    document.add(new TextField(\"filename\", \"要更新的文档\", Field.Store.YES));\n    document.add(new TextField(\"content\", \" Lucene 简介 Lucene 是一个基于 Java 的全文信息检索工具包,\" +\n                                                       \"它不是一个完整的搜索应用程序,而是为你的应用程序提供索引和搜索功能。\",\n                Field.Store.YES));\n    indexWriter.updateDocument(new Term(\"content\", \"java\"), document);\n    //关闭indexWriter\n    indexWriter.close();\n}\n```\n\n\n\n## 八、索引库查询 \n\n### 1. 使用 Query 的子类 \n\n​    1. TermQuery \n\n​        根据关键词进行查询。\n\n​        需要指定要查询的域及要查询的关键词 \n\n```java\n//使用Termquery查询\n@Test\npublic void testTermQuery() throws Exception {\n    Directory directory = FSDirectory.open(new File(\"D:\\\\temp\\\\index\").toPath());\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    \n    //创建查询对象\n    Query query = new TermQuery(new Term(\"content\", \"lucene\"));\n    //执行查询\n    TopDocs topDocs = indexSearcher.search(query, 10);\n    //共查询到的document个数\n    System.out.println(\"查询结果总数量：\" + topDocs.totalHits);\n    //遍历查询结果\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n        Document document = indexSearcher.doc(scoreDoc.doc);\n        System.out.println(document.get(\"filename\"));\n        //System.out.println(document.get(\"content\"));\n        System.out.println(document.get(\"path\"));\n        System.out.println(document.get(\"size\"));\n    }\n    //关闭indexreader\n    indexSearcher.getIndexReader().close();\n}\n```\n\n​    2. RangeQuery \n\n​        范围查询\n\n```java\n@Test\npublic void testRangeQuery() throws Exception {\n    IndexSearcher indexSearcher = getIndexSearcher();\n    Query query = LongPoint.newRangeQuery(\"size\", 0l, 10000l);\n    printResult(query, indexSearcher);\n}\n```\n\n### 2. 使用 QueryPaser 解析查询表达式\n\n1. 可以对要查询的内容先分词，然后基于分词的结果进行查询。\n2. 添加一个jar包 \n\n​        lucene-queryparser-7.4.0.jar\n\n```java\n@Test\npublic void testQueryParser() throws Exception {\n    IndexSearcher indexSearcher = getIndexSearcher();\n    //创建queryparser对象\n    //第一个参数默认搜索的域\n    //第二个参数就是分析器对象\n    QueryParser queryParser = new QueryParser(\"content\", new IKAnalyzer());\n    Query query = queryParser.parse(\"Lucene是java开发的\");\n    //执行查询\n    printResult(query, indexSearcher);\n}\nprivate void printResult(Query query, IndexSearcher indexSearcher) throws Exception {\n    //执行查询\n    TopDocs topDocs = indexSearcher.search(query, 10);\n    //共查询到的document个数\n    System.out.println(\"查询结果总数量：\" + topDocs.totalHits);\n    //遍历查询结果\n    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n        Document document = indexSearcher.doc(scoreDoc.doc);\n        System.out.println(document.get(\"filename\"));\n        //System.out.println(document.get(\"content\"));\n        System.out.println(document.get(\"path\"));\n        System.out.println(document.get(\"size\"));\n    }\n    //关闭indexreader\n    indexSearcher.getIndexReader().close();\n}\n```\n\n\n\n\n\n","tags":["lucene","检索"],"categories":["MyTech","技术"]},{"title":"区间DP 矩阵链的乘法","url":"/posts/203698481/","content":"# 矩阵相乘\n**实际上矩阵相乘题是典型的区间动态规划**\n<!-- more -->\n区间DP的操作如图，区间范围由小到大逐步增加\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200422215901363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n首先我们来看看动态规划的**四个步骤**：\n\n  1. 找出最优解的性质，并且刻画其结构特性；\n  2. 递归的定义最优解；\n  3. 以自底向上的方式刻画最优值；\n  4. 根据计算最优值时候得到的信息，构造最优解\n\n其中改进的动态规划算法：备忘录法，是以自顶向下的方式刻画最优值，对于动态规划方法和备忘录方法，**两者的使用情况如下：**\n\n>    一般来讲，当一个问题的所有子问题都至少要解一次时，使用动态规划算法比使用备忘录方法好。此时，动态规划算法没有任何多余的计算。同时，对于许多问题，常常可以利用其规则的表格存取方式，减少动态规划算法的计算时间和空间需求。当子问题空间中的部分子问题可以不必求解时，使用备忘录方法则较为有利，因为从其控制结构可以看出，该方法只解那些确实需要求解的问题。\n\n>对于动态规划算法，我们必须明确两个基本要素，这两个要素对于在设计求解具体问题的算法时，是否选择动态规划算法具有**指导意义：**\n\n1. 算法有效性依赖于问题本身所具有的**最优子结构性质**：**设计算法的第一步通常是要刻画最优解的结构。当问题的最优解包含了子问题的最优解时，称该问题具有最优子结构性质。问题的最优子结构性质提供了该问题可以使用动态规划算法求解的重要线索**\n\n>在矩阵连乘积最优次序问题中注意到，若A1A2...An的最优完全加括号方式在Ak和Ak+1之间断开，则由此可以确定的子链A1A2A3...Ak和Ak+1Ak+2...An的完全加括号方式也最优，即该问题具有最优子结构性质。在分析该问题的最优子结构性质时候，所使用的方法具有普遍性。首先假设由原问题导出的子问题的借不是最优解，然后在设法说明在这个假设下可以构造出比原问题最优解更好的解，从而导致矛盾。\n\n>      在动态规划算法中，利用问题的最优子结构性质，以自底向上的方式递归的从子问题的最优解逐渐构造出整个问题的最优解。算法考察的子问题的空间规模较小。例如在举证连乘积的最优计算次序问题中，子问题空间由矩阵链的所有不用的子链组成。所有不用的子链的个数为o(n* n),因而子问题的空间规模为o(n* n)\n\n2. 可以用动态规划算法求解问题应该具备另一个基本要素是**子问题的重叠性**。在用递归算法自顶向下求解此问题时候，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。**动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题都只是求解一次，而后将其保存到一个表格中，当再次需要解此问题时，只是简单使用常数时间查看一下结果。** 通常，不同子问题个数随着问题大小呈多项式增长。因此使用动态规划算法通常只是需要多项式时间，从而获得较高的解题效率。\n\n---\n## 逐步分析\nP=<30,35,15,5,10,20>   它对应5个矩阵    \n```\nA1：30*35   A2：35*15   A3：15*5   A4：5*10   A5：10*20\n```\n---\n\n先计算：\n当`r=1`表示两个矩阵相乘的运算量\nm[1,1]=0  m[2,2]=0  m[3,3]=0  m[4,4]=0  m[5,5]=0  \n\n当`r=2`表示两个矩阵相乘的运算量\nm[1,2]=30*35*15=15750\nm[2,3]=35*15*5=2625\nm[3,4]=15*5*10=750\nm[4,5]=5*10*20=1000\n\n当`r=3`表示3个矩阵相乘的运算量\nm[1,3]=min{m[1,2]+30*15*5,m[2,3]+30*35*5}=min{15750+2625,2625+5250}=7875  A1(A2A3)   s[1,3]=1\nm[2,4]=min{m[2,3]+35*5*10,m[3,4]+35*15*10}={2625+1750,750+5250}=4375      (A2A3)A4   s[2,4]=3\nm[3,5]=min{m[3,4]+15*10*20,m[4,5]+15*5*20}=2500                           A3(A4A5)   s[3,5]=3\n\n\n当`r=4`表示4个矩阵相乘的运算量\nm[1,4]=min{m[2,4]+30*35*10,m[1,2]+m[3,4]+30*15*10,m[1,3]+30*5*10}\n      =min{4375+10500,15750+750+4500,7875+1500}\n      =9375                  [A1A2A3]A4---->(A1(A2A3))A4           s[1,4]=3\nm[2,5]=min{m[3,5]+35*15*20,m[2,3]+m[4,5]+35*5*20,m[2,4]+35*10*20}\n      =min{2500+10500,2625+1000+3500,4375+7000}\n      =7125                  (A2A3)(A4A5)                          s[2,5]=3\n\n当`r=5`表示5个矩阵相乘的运算量\nm[1,5]=min{m[2,5]+30*35*20,m[1,2]+m[3,5]+30*15*20,m[1,3]+m[4,5]+30*5*20,m[1,4]+30*10*20}\n      =min{7125+21000,15750+2500+9000,7875+1000+3000,9375+9000}\n      =11875                ` [A1A2A3](A4A5)---->(A1(A2A3))`\n      (A4A5)    s[1,5]=3 \n\n\n\n\n## 优化函数备忘录：\nr=1  m[1,1]=0      m[2,2]=0     m[3,3]=0    m[4,4]=0  m[5,5]=0  \nr=2  m[1,2]=15750  m[2,3]=2625  m[3,4]=750  m[4,5]=1000\nr=3  m[1,3]=7875   m[2,4]=4375  m[3,5]=2500 \nr=4  m[1,4]=9375   m[2,5]=7125\nr=5  m[1,5]=11875\n\n## 标记函数\nr=2  s[1,2]=1  s[2,3]=2  s[3,4]=3  s[4,5]=4\nr=3  s[1,3]=1  s[2,4]=3  s[3,5]=3\nr=4  s[1,4]=3  s[2,5]=3\nr=5  s[1,5]=3\n\n根据 `s[1,5]=3 `推出最后一次划分的位置为3  ` [A1A2A3][A4A5]  `\n然后再由`[A1A2A3]`找s[1,3]=1   \n推出最后一次划分位置为1  `A1(A2A3)`\n所以最终答案为：`(A1(A2A3))(A4A5) `  运算次数为：`11875`次\n\n---\n练习：\n再将P=<20,70,25,30,5,35,10>计算出来\n\n## Java实现\n```java \npublic class Strassen {\n    /*\n     * array[i][j]表示Ai...Aj相乘最少计算次数\n     * s[i][j]=k,表示Ai...Aj这(j-i+1)个矩阵中最优子结构为Ai...Ak和A(k+1)...Aj\n     * p[i]表示Ai的行数，p[i+1]表示Ai的列数\n     */\n\tprivate int array[][];\n\tprivate int p[];\n\tprivate int s[][];\n\t\n\tpublic Strassen(){\n\t\tp=new int[]{2,4,5,5,3};\n\t\tarray=new int[4][4];\n\t\ts=new int[4][4];\n\t}\n\t\n\tpublic Strassen(int n,int []p){\n\t\tthis.p=new int[n+1];\n\t\tthis.array=new int[n][n];\n\t\tthis.s=new int[4][4];\n\t\tfor(int i=0;i<p.length;i++)\n\t\t\tthis.p[i]=p[i];\n\t}\n\t/*********************方法一，动态规划**********************************/\n\tpublic void martixChain(){\n\t\tint n=array.length;\n\t\tfor(int i=0;i<n;i++) \n\t\t\tarray[i][i]=0;\n\t\tfor(int r=2;r<=n;r++){\n\t\t\tfor(int i=0;i<=n-r;i++){\n\t\t\t\tint j=i+r-1;\n\t\t\t\tarray[i][j]=array[i+1][j]+p[i]*p[i+1]*p[j+1];\n\t\t\t\ts[i][j]=i;\n\t\t\t\tfor(int k=i+1;k<j;k++){\n\t\t\t\t\tint t=array[i][k]+array[k+1][j]+p[i]*p[k+1]*p[j];\n\t\t\t\t\tif(t<array[i][j]){\n\t\t\t\t\t\tarray[i][j]=t;\n\t\t\t\t\t\ts[i][j]=k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * 如果待求矩阵为：Ap...Aq,then a=0,b=q-p\n\t */\n\tpublic void traceBack(int a,int b){\n\t\tif(a<b){\n\t\t\ttraceBack(a, s[a][b]);\n\t\t\ttraceBack(s[a][b]+1, b);\n\t\t\tSystem.out.println(\"先把A\"+a+\"到A\"+s[a][b]+\"括起来，在把A\"+(s[a][b]+1)+\"到A\"+b+\"括起来，然后把A\"+a+\"到A\"+b+\"括起来\");\n\t\t}\n\t}\n\t\n\t/*********************方法二：备忘录方法*****************************/\n\tpublic int memorizedMatrixChain(){\n\t\tint n=array.length;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i;j<n;j++)\n\t\t\t\tarray[i][j]=0;\n\t\t}\n\t\treturn lookUpChain(0,n-1);\n\t}\n\t\n\tpublic int lookUpChain(int a,int b){\n\t\tif(array[a][b]!=0)\n\t\t\treturn array[a][b];\n\t\tif(a==b)\n\t\t\treturn 0;\n\t\tarray[a][b]=lookUpChain(a, a)+lookUpChain(a+1, b)+p[a]*p[a+1]*p[b+1];\n\t\ts[a][b]=a;\n\t\tfor(int k=a+1;k<b;k++){\n\t\t\tint t=lookUpChain(a, k)+lookUpChain(k+1, b)+p[a]*p[k+1]*p[b+1];\n\t\t\tif(t<array[a][b]){\n\t\t\t\tarray[a][b]=t;\n\t\t\t\ts[a][b]=k;\n\t\t\t}\n\t\t}\n\t\treturn array[a][b];\n\t}\n\tpublic static void main(String[] args) {\n\t\tStrassen strassen=new Strassen();\n\t\t//strassen.martixChain();\n\t\tstrassen.memorizedMatrixChain();\n\t\tstrassen.traceBack(0, 3);\n\t}\n}\n```\n## C++实现\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nLL a[100],d[100][100],b[100][100],n,cost;\n//a为矩阵链各向量长度，d为优化函数，b为标记函数\nvoid link(int l,int r) {\n\tif (l==r) {\n\t\tprintf(\"A%d\",l);\n\t\treturn;\n\t}\n\t//输出左边矩阵/矩阵链的括号表示法\n\tif (b[l][r]-l>0) putchar('(');\n\tlink(l,b[l][r]);\n\tif (b[l][r]-l>0) putchar(')');\n\t//输出右边矩阵/矩阵链的括号表示法\n\tif (r-b[l][r]>1) putchar('(');\n\tlink(b[l][r]+1,r);\n\tif (r-b[l][r]>1) putchar(')');\n}\nint main()\n{\n\t//读入矩阵相乘的长度\n\tscanf(\"%lld\",&n);\n\tfor (int i=0;i<=n;i++) scanf(\"%lld\",a+i);\n\t//逐层计算r长度矩阵链的最优运算量，r=k+1\n\tfor (int k=1;k<n;k++) {\n\t\t//p枚举区间右端，所计算区间为[p-k,p]\n\t\tfor (int p=k+1;p<=n;p++) {\n\t\t\t//枚举标记点，按照题意，是左区间末端\n\t\t\tfor (int i=p-k;i<p;i++) {\n\t\t\t\tcost=d[p-k][i]+d[i+1][p]+a[p-k-1]*a[p]*a[i];\n\t\t\t\tif (!b[p-k][p] || cost<d[p-k][p]) {\n\t\t\t\t\tb[p-k][p]=i; //标记\n\t\t\t\t\td[p-k][p]=cost; //更新优化函数\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//优化函数备忘录\n\tputs(\"优化函数备忘录\");\n\tfor (int k=0;k<n;k++) {\n\t\tprintf(\"r=%d\",k+1);\n\t\t//p枚举区间右端，所计算区间为[p-k,p]\n\t\tfor (int p=k+1;p<=n;p++)\n\t\t\tprintf(\" m[%d,%d]=%lld\",p-k,p,d[p-k][p]);\n\t\tprintf(\"\\n\");\n\t}\n\t//标记函数\n\tputs(\"标记函数\");\n\tfor (int k=1;k<n;k++) {\n\t\tprintf(\"r=%d\",k+1);\n\t\t//p枚举区间右端，所计算区间为[p-k,p]\n\t\tfor (int p=k+1;p<=n;p++)\n\t\t\tprintf(\" s[%d,%d]=%lld\",p-k,p,b[p-k][p]);\n\t\tprintf(\"\\n\");\n\t}\n\t//括号表示法用axx表示矩阵\n\tputs(\"括号表示法\");\n\tlink(1,n);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n\n/*\n6\n20 70 25 30 5 35 10\n===================================================================\n优化函数备忘录\nr=1 m[1,1]=0 m[2,2]=0 m[3,3]=0 m[4,4]=0 m[5,5]=0 m[6,6]=0\nr=2 m[1,2]=35000 m[2,3]=52500 m[3,4]=3750 m[4,5]=5250 m[5,6]=1750\nr=3 m[1,3]=50000 m[2,4]=12500 m[3,5]=8125 m[4,6]=3250\nr=4 m[1,4]=19500 m[2,5]=24750 m[3,6]=6750\nr=5 m[1,5]=23000 m[2,6]=17750\nr=6 m[1,6]=22250\n===================================================================\n标记函数\nr=2 s[1,2]=1 s[2,3]=2 s[3,4]=3 s[4,5]=4 s[5,6]=5\nr=3 s[1,3]=2 s[2,4]=2 s[3,5]=4 s[4,6]=4\nr=4 s[1,4]=1 s[2,5]=4 s[3,6]=4\nr=5 s[1,5]=4 s[2,6]=4\nr=6 s[1,6]=4\n===================================================================\n括号表示法\n(A1(A2(A3A4)))(A5A6)\n*/\n```\n","tags":["算法","动态规划"],"categories":["MyTech","算法","动态规划"]},{"title":"搜索 金币阵列问题","url":"/posts/1278288142/","content":"### 金币阵列问题\n**问题描述：**\n<!-- more -->\n有m x n (m<=100, n<=100 ) 个金币在桌面上排成一个m行n 列的金币阵列。每一枚金币或正面朝上或背面朝上。用数字表示金币状态，0表示金币正面朝上，1 表示背面朝上。金币阵列游戏的规则是：\n1. 每次可将任一行金币翻过来放在原来的位置上；\n2. 每次可任选2 列，交换这2 列金币的位置。\n\n**算法设计：**\n\n        给定金币阵列的初始状态和目标状态，计算按金币游戏规则，将金币阵列从初始状态变换到目标状态所需的最少变换次数。\n\n\n\n**数据输入：**\n        由文件input.txt给出输入数据。文件中有多组数据。文件的第1行有1 个正整数k，表示有k 组数据。每组数据的第1 行有2 个正整数m 和n。以下的m行是金币阵列的初始状态，每行有n 个数字表示该行金币的状态，0 表示金币正面朝上，1 表示背面朝上。接着的m行是金币阵列的目标状态。\n\n**结果输出:**\n\n        将计算出的最少变换次数按照输入数据的次序输出到文件output.txt。相应数据无解时输出-1。\n输入文件示例 输出文件示例\ninput.txt \n```\n2\n4 3\n1 0 1\n0 0 0\n1 1 0\n1 0 1\n\n1 0 1\n1 1 1\n0 1 1\n\n1 0 1\n\n\n\n4 3\n1 0 1\n0 0 0\n1 0 0\n1 1 1\n\n1 1 0\n1 1 1\n0 1 1\n1 0 1\n```\n\n\noutput.txt\n```\n2\n\n-1\n```\n\n```cpp\n#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\ntypedef long long LL;\nconst int maxn = 15;\nint m, n;\nint src[maxn][maxn], des[maxn][maxn];\nint cnt, tmp[maxn][maxn];\n\nvoid copy(int a[maxn][maxn], int b[maxn][maxn])\n{\n    for (int i = 1; i <= m; ++i)\n        for (int j = 1; j <= n; ++j)\n            a[i][j] = b[i][j];\n}\n\nvoid flipByRow(int r)\n{ //对某一行进行翻转\n    for (int j = 1; j <= n; ++j)\n        tmp[r][j] = tmp[r][j] ^ 1; // a[j][i]^=1; //异或运算也可以\n    ++cnt;\n}\n\nvoid exchangeByColumn(int c1, int c2)\n{ //对两列进行互换\n    for (int i = 1; i <= m; ++i)\n        swap(tmp[i][c1], tmp[i][c2]);\n    if (c1 != c2)\n        ++cnt;\n}\n\nbool same(int c1, int c2)\n{\n    //判断两列是否相同\n    for (int i = 1; i <= m; ++i)\n        if (des[i][c1] != tmp[i][c2])\n            return false;\n    return true;\n}\n\nint main()\n{\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        cin >> m >> n;\n        for (int i = 1; i <= m; ++i)\n            for (int j = 1; j <= n; ++j)\n                cin >> src[i][j];\n        for (int i = 1; i <= m; ++i)\n            for (int j = 1; j <= n; ++j)\n                cin >> des[i][j];\n\n        int best = m + n + 1;\n\n        //整体思路，将每一列运用列交换作为第1列，然后对每一行进行判断，如果元素//与目标元素不相等，\n\n        //进行翻转处理，再向后判断相关列是否相同。\n        for (int col = 1; col <= n; ++col)\n        {                   //在tmp中依次寻找des的每一列\n            copy(tmp, src); //先复制数组\n            cnt = 0;\n            exchangeByColumn(1, col); //将第k列与第1列互换\n                                      //对所有行的第1个元素与目标数组对应的元素进行比较，如果不同\n                                      //进行按行变换\n            for (int i = 1; i <= m; ++i)\n                if (tmp[i][1] != des[i][1])\n                    flipByRow(i);\n            //检查每一列是否满足条件\n            bool found;\n            for (int c1 = 1; c1 <= n; ++c1)\n            { //判断是否可以通过后续列的交换达到目的\n                found = false;\n                for (int c2 = c1; c2 <= n; ++c2)\n                    if (same(c1, c2))\n                    {\n                        exchangeByColumn(c1, c2);\n                        found = true;\n                        break;\n                    }\n                if (!found)\n                    break;\n            }\n            if (found && best > cnt)\n                best = cnt;\n        }\n\n        if (best < m + n + 1)\n            cout << best << \"\\n\";\n        else\n            cout << \"-1\\n\";\n    }\n    return 0;\n}\n```","tags":["算法","搜索"],"categories":["MyTech","算法","搜索"]},{"title":"树型DP 选课","url":"/posts/2422265838/","content":"## 树型动规 选课\n**知识点：** 树型DP、多叉树转二叉树\n\n---\n多叉树转二叉树表示方式之**孩子兄弟链存储结构**：\n<!-- more -->\n孩子兄弟存储结构是为每个节点设计**三个域**：\n1. 一个数据元素域\n2. 一个该节点的第一个孩子节点指针域\n3. 一个该节点下的下一个兄弟节点指针域。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200428221109235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n\n**描述**\n学校实行学分制。每门的必修课都有固定的学分，同时还必须获得相应的选修课程学分。学校开设了N（N<300）门的选修课程，每个学生可选课程的数量M是给定的。学生选修了这M门课并考核通过就能获得相应的学分。\n\n在选修课程中，有些课程可以直接选修，有些课程需要一定的基础知识，必须在选了其它的一些课程的基础上才能选修。例如《Frontpage》必须在选修了《Windows操作基础》之后才能选修。我们称《Windows操作基础》是《Frontpage》的先修课。每门课的直接先修课最多只有一门。两门课也可能存在相同的先修课。每门课都有一个课号，依次为1，2，3，…。 例如:\n\n表中1是2的先修课，2是3、4的先修课。如果要选3，那么1和2都一定已被选修过。 　　你的任务是为自己确定一个选课方案，使得你能得到的学分最多，并且必须满足先修课优先的原则。假定课程之间不存在时间上的冲突。\n\n**格式\n输入格式**\n输入文件的第一行包括两个整数N、M（中间用一个空格隔开）其中1≤N≤300,1≤M≤N。\n\n以下N行每行代表一门课。课号依次为1，2，…，N。每行有两个数（用一个空格隔开），第一个数为这门课先修课的课号（若不存在先修课则该项为0），第二个数为这门课的学分。学分是不超过10的正整数。\n\n**输出格式**\n输出文件每行只有一个数。第一行是实际所选课程的学分总数。\n\n**样例1\n样例输入**\n```\n5 4\n0 1\n1 1\n2 3\n0 3\n2 4\n```\n**样例输出**\n```\n9\n```\n**样例2\n样例输入**\n```\n7 4\n2 2\n0 1\n0 4\n2 1\n7 1\n7 6\n2 2\n```\n**样例输出**\n```\n13\n```\n```cpp\n/*\n一道树形dp，因为每门课的先修课最多只有一节，则说明这是个树结构\n对于读入的边，我们先将多叉树建立成二叉树\n原则是左儿子右兄弟\n然后再定义状态f表示以i课程为父亲结点的子树上选j门课程的最多学分\n则有状态转移方程\nf[i][j]=max(f[left][j-k-1]+f[right][k]+score[i](0<=k<=j-1),f[right][j])\n方程含义：1、取当前i节点，则剩下的j-1们课程，在孩子中选j-k-1门，在兄弟中选k门。\n          2、不取当前节点，则只能在兄弟中选j门。\nk用来表示的是分别分配在某个节点上的左右子树的选择课程树\n注意还有个f[right][j]即表示不选这门课程而选择它的右兄弟\n原理上两种情况是根本上相同可合并的但是实际实现中没有那么方便\n所以我们可以自顶向下用dfs进行树的遍历递归求解\n*/\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int maxn=305;\nstruct node\n{\n    int l,r,v;\n}tree[maxn];\nint n,m;\nint f[maxn][maxn];\n\nint dfs(int x,int y)\n{\n    if(!y||x<0)\n        return 0;\n    if(!x)\n        return dfs(tree[x].l,y);\n    if(f[x][y])\n        return f[x][y];\n    f[x][y]=dfs(tree[x].r,y);\n    for(int i=0;i<y;i++)\n        f[x][y]=max(f[x][y],dfs(tree[x].l,i)+tree[x].v+dfs(tree[x].r,y-i-1));\n    return f[x][y];\n}\n\nint main()\n{\n    memset(tree,-1,sizeof(tree));\n    cin>>n>>m;\n    int fa,v;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>fa>>v;\n        tree[i].r=tree[fa].l;\n        tree[fa].l=i;\n        tree[i].v=v;\n    }\n    cout<<dfs(0,m)<<endl;//0表示入口，0的子节点表示第一层\n    return 0;\n}\n```\n","tags":["算法","动态规划","二叉树","树型DP"],"categories":["MyTech","算法","动态规划"]},{"title":"BF算法的实际应用 套汇","url":"/posts/69415872/","content":"如果**没接触过bf算法**，先看看它的介绍吧？\n[bellman ford算法百度百科介绍](https://baike.baidu.com/item/Bellman-Ford%E7%AE%97%E6%B3%95/1089090?fr=aladdin)\n<!-- more -->\n图中的加权有向边代表汇率，我们可以发现如果把 100 单位的货币 A 换成 B，再换成 C，最后换回 A，就可以得到 100×0.9×0.8×1.4 = 100.8 单位的 A！\n如果交易的金额大一些的话，赚的钱是很可观的，这种空手套白狼的操作就是套汇。\n现实中交易会有种种限制，而且市场瞬息万变，但是套汇的利润还是很高的，关键就在于如何快速找到这种套汇机会呢？\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200426112503124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n\n借助图的抽象，我们发现套汇机会其实就是一个环，且这个环上的权重之积大于 1，只要在顺着这个环交易一圈就能空手套白狼。\n图论中有一个经典算法叫做 **Bellman-Ford** 算法，可以用于**寻找负权重环**。对于我们说的套汇问题，可以先把所有边的权重 w 替换成 **-ln(w)**，这样「寻找权重乘积大于 1 的环」就转化成了「寻找权重和小于 0 的环」\n就可以使用 Bellman-Ford 算法在 O(EV) 的时间内寻找负权重环，也就是寻找套汇机会。\n\n---\n**Bellman-Ford 伪代码理解**\n```cpp\nbool Bellman-Ford(G,w,s)        //图G ，边集 函数 w ，s为源点\n  for each vertex v ∈ V(G):     //初始化距离源点距离均为无穷大\n    d[v] ←+∞\n  d[s] ←0                       //源点距离自身为0\n  for i = 1 → |V|:              //松弛操作需要重复多次\n    for each edge (u,v) ∈ E(G):\n      if d[v] > d[u] + w(u,v):\n        d[v] = d[u] + w(u,v)\n  for each edge(u,v) ∈ E(G):    //判断是否存在负权环路\n    if d[v] > d[u] + w(u,v):\n      return false\n  return true\n```\nSPFA实际上是用队列对bf的*优化*，思路差不多\n```cpp\nint SPFA(int s) {\n     queue<int> q; \n     bool inq[maxn] = {false}; \n     for(int i = 1; i <= N; i++) dis[i] = 2147483647; \n     dis[s] = 0; \n     q.push(s); inq[s] = true; \n     while(!q.empty()) { \n         int x = q.front(); q.pop(); \n         inq[x] = false;\n         for(int i = front[x]; i !=0 ; i = e[i].next) {\n             int k = e[i].v;\n             if(dis[k] > dis[x] + e[i].w) {\n                 dis[k] = dis[x] + e[i].w;\n                 if(!inq[k]) {\n                     inq[k] = true;\n                     q.push(k);\n                 }\n             }\n         }\n     }\n     for(int i =  1; i <= N; i++) cout << dis[i] << ' ';\n     cout << endl;\n     return 0;\n }\n```","tags":["图论","算法"],"categories":["MyTech","算法"]},{"title":"蓝桥杯 蚂蚁感冒","url":"/posts/1665851491/","content":"**蚂蚁感冒**\n时间限制：1000 ms  |  内存限制：65535 KB\n\n难度：2\n<!-- more -->\n**描述**\n\n长100厘米的细长直杆子上有n只蚂蚁。它们的头有的朝左，有的朝右。 每只蚂蚁都只能沿着杆子向前爬，速度是1厘米/秒。 当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。 这些蚂蚁中，有1只蚂蚁感冒了。并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。 请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。\n\n**输入**\n\n第一行输入一个整数n (1 < n < 50), 表示蚂蚁的总数。\n\n\n接着的一行是n个用空格分开的整数 Xi (-100 < Xi < 100), Xi的绝对值，表示蚂蚁离开杆子左边端点的距离。正值表示头朝右，负值表示头朝左，数据中不会出现0值，也不会出现两只蚂蚁占用同一位置。其中，第一个数据代表的蚂蚁感冒了。\n\n**输出**\n\n要求输出1个整数，表示最后感冒蚂蚁的数目。\n\n**样例输入**\n\n3\n5 -2 8\n5\n-10 8 -20 12 25\n**样例输出**\n\n1\n3\n\n\n乍一看还以为是一道模拟题，但是仔细想想可以发现出题者的小陷阱：蚂蚁碰面后会掉头。首先，哪有这么傻的蚂蚁，其次，这个掉头动作会让我们的逻辑变得混乱，因为谁也不知道什么时候会碰面，表面上看会无从下手，那么我们分析一下蚂蚁碰面后的状态。\n\n1.两只健康蚂蚁碰面后，两个方向都会有一只健康的蚂蚁在行走\n\n2.至少一只蚂蚁有病，两个方向都会有一只有病的蚂蚁在行走\n\n看出端倪了吧，其实蚂蚁碰面后根本没有必要掉头，或者说即使掉头，效果也是和不掉头一样的。\n\n明白了上面的，我知道，每只蚂蚁都会坚定不移的朝一个固定的方向走，下面看看第一只有病的蚂蚁，如果它初始向左走，那是不是它左边所有的向右走的蚂蚁都会遭殃？同样，当左边遭了秧的蚂蚁遇到了其右边向左走的蚂蚁，那么它们也会遭殃。\n\n存在一种特殊的情况，即所有的蚂蚁都朝一个方向走，那谁也不会被传染，最终只有一只蚂蚁有病。\n\n假设有病的蚂蚁是A，A左边向右走的蚂蚁数量为lf，A右边向左走的蚂蚁数量为rg，那么\n\n1.A向右走，且rg==0,；或者A向左走，且lf==0，ans=1；\n\n2.ans=lf+rg+1；\n```C++\n#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n \nstruct Ant\n{\n\tint pos;\n\tint dir;\n\tint cold;\t\n};\n \n \nint n,ans,lf,rg;\nAnt ant[60];\n \nbool cmp(const Ant a,const Ant b)\n{\n\treturn a.pos<b.pos;\n}\n \nint main()\n{\n\tint i,j;\n\tint len;\n\tint cold_ant;\n\twhile(~scanf(\"%d\",&n))\n\t{\n\t\tfor(i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&len);\n\t\tant[i].pos=abs(len);\n\t\tant[i].dir=len<0?-1:1;\n\t\tant[i].cold=0;\n\t}\n\tant[0].cold=1;\n\tlf=rg=0;\n\tsort(ant,ant+n,cmp);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tif(ant[i].cold==1)\n\t\t\tbreak;\n\t\tif(ant[i].dir>0)\n\t\t\tlf++;\n\t}\n\tcold_ant=i;\n\tfor(i=i+1;i<n;i++)\n\t{\n\t\tif(ant[i].dir<0)\n\t\t\trg++;\n\t}\n\tif((ant[cold_ant].dir>0&&rg==0)||(ant[cold_ant].dir<0&&lf==0))\n\t\tans=1;\n\telse\n\t\tans=lf+rg+1;\n\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}\n```\n\n","tags":["算法","蓝桥杯"],"categories":["MyTech","算法","模拟"]},{"title":"毕向东Java基础","url":"/posts/1544453252/","content":"Table of Contents\n\nJava基础知识精华部分\n<!-- more -->\n一：java概述：\n\n1，JDK：Java Development Kit，java的开发和运行环境，java的开发工具和jre。\n\n2，JRE：Java Runtime Environment，java程序的运行环境，java运行的所需的类库+JVM(java虚拟机)。\n\n3，配置环境变量：让java jdk\\bin目录下的工具，可以在任意目录下运行，原因是，将该工具所在目录告诉了系统，当使用该工具时，由系统帮我们去找指定的目录。\n\n4，javac命令和java命令做什么事情呢？\n\n二：java语法基础：\n\n1，关键字：其实就是某种语言赋予了特殊含义的单词。\n\n2，标示符：其实就是在程序中自定义的名词。比如类名，变量名，函数名。包含 0-9、a-z、$、_ ；\n\n3，常量：是在程序中的不会变化的数据。\n\n4，变量：其实就是内存中的一个存储空间，用于存储常量数据。\n\n什么时候定义变量？只要是数据不确定的时候，就定义变量。\n\n变量空间的开辟需要什么要素呢？\n\n变量的作用域和生存期:\n\n数据类型：\n\n运算符号：\n\n   5）、位运算符:用于操作二进制位的运算符。\n\n        5.1 移位操作符：\n\n        5.2 按位操作符\n\n   练习：对两个变量的数据进行互换。不需要第三方变量。\n\n5，语句。\n\n工作原理：用小括号中的变量的值依次和case后面的值进行对比，和哪个case后面的值相同了\n\n   while和for可以进行互换。\n\nbreak:作用于switch ，和循环语句，用于跳出，或者称为结束。\n\ncontinue:只作用于循环结构，继续循环用的。\n\n6，函 数：为了提高代码的复用性，可以将其定义成一个单独的功能，该功能的体现就是java中的函数。函数就是体现之一。\n\njava中的函数的定义格式：\n\nreturn的作用：结束函数。结束功能。\n\n如何定义一个函数？\n\n函数的作用：\n\n主函数：\n\n函数定义名称是为什么呢？\n\n重载\n\n7，数 组：\n\njava分了5片内存。\n\n三：面向对象：★★★★★\n\n特点：\n\n匿名对象使用场景：\n\nprivate\n\n类中怎么没有定义主函数呢？\n\n主函数的解释：保证所在类的独立运行，是程序的入口，被jvm调用。\n\n成员变量和局部变量的区别：\n\n构造函数：\n\n构造函数和一般函数有什么区别呢？\n\n什么时候使用构造函数呢？\n\n构造代码块和构造函数有什么区别？\n\n创建一个对象都在内存中做了什么事情？\n\n封 装（面向对象特征之一）：\n\nstatic：\n\n什么时候定义静态成员呢？或者说：定义成员时，到底需不需要被静态修饰呢？\n\n成员变量和静态变量的区别：\n\n静态的注意：静态的生命周期很长。\n\n生成Java帮助文档：\n\n设计模式\n\n单例设计模式：★★★★★\n\n继 承（面向对象特征之一）\n\n为什么不支持多继承呢？\n\n子父类出现后，类中的成员都有了哪些特点：\n\n发现子类构造函数运行时，先运行了父类的构造函数。为什么呢?\n\n为什么子类对象初始化时，都需要调用父类中的函数？(为什么要在子类构造函数的第一行加入这个super()?)\n\nsuper()或者this():为什么一定要定义在第一行？\n\n继承的细节：\n\n在方法覆盖时，注意两点：\n\nfinal特点：\n\n抽象类: abstract\n\n接 口：★★★★★\n\n接口都用于设计上，设计上的特点：（可以理解主板上提供的接口）\n\n抽象类与接口：\n\n多 态★★★★★（面向对象特征之一）\n\n多态的前提：\n\n多态在子父类中的成员上的体现的特点：\n\njava.lang.Object\n\n具体方法：\n\n1，boolean equals(Object obj)\n\n2，String toString()\n\n3，Class getClass()\n\n4，int hashCode()\n\n内部类\n\n当内部类定义在外部类中的成员位置上，可以使用一些成员修饰符修饰 private、static。\n\n为什么内部类可以直接访问外部类中的成员呢？\n\n匿名内部类的使用场景：\n\n异 常：★★★★\n\nthrow 和throws关键字的区别：\n\n异常分两种：\n\n编译时被检查的异常和运行时异常的区别：\n\n定义异常处理时，什么时候定义try，什么时候定义throws呢？\n\n自定义异常的步骤：\n\ntry  catch  finally的几种结合方式：\n\n常见异常：\n\n包：定义包用package关键字。包中可以还有包\n\n总结java中的四种权限：\n\n常见的软件包:\n\n多线程：★★★★\n\n进程\n\n线程\n\n随机性的原理\n\nstart方法：1）、启动了线程；2）、让jvm调用了run方法。\n\n创建线程的第一种方式：继承Thread ，由子类复写run方法。\n\n线程状态：\n\n创建线程的第二种方式：实现一个接口Runnable。\n\n为什么要有Runnable接口的出现？\n\n多线程安全问题的原因：\n\n解决安全问题的原理：\n\n同步：★★★★★\n\n同步函数是用的哪个锁呢？\n\n当同步函数被static修饰时，这时的同步用的是哪个锁呢？\n\n同步代码块和同步函数的区别？\n\n同步死锁\n\n线程间通信\n\n等待唤醒机制\n\n注意：\n\nwait和sleep区别\n\n线程的停止\n\nLock接口\n\nAPI\n\n--< java.lang >-- String字符串：★★★☆\n\n字符串的方法：\n\n--< java.lang >-- StringBuffer字符串缓冲区：★★★☆\n\n容器通常具备一些固定的方法：\n\n--< java.lang >-- StringBuilder字符串缓冲区：★★★☆//建议使用\n\n基本数据类型对象包装类\n\nInteger对象： ★★★☆\n\n集合框架：★★★★★，用于存储数据的容器。\n\n--< java.util >-- Collection接口：\n\n--< java.util >-- Iterator接口：\n\n--< java.util >-- List接口：\n\n可变长度数组的原理：\n\n--< java.util >-- Set接口：Set中的元素不能重复\n\n哈希表的原理：\n\nTreeSet:\n\nMap集合\n\nMap集合存储和Collection有着很大不同：\n\n访问map集合中所有元素\n\n有关于 map.entrySet() 和 keySet():\n\n使用集合的技巧：\n\nArrays：\n\n高级for循环可以遍历map集合吗\n\n可变参数（...）\n\n枚举：关键字 enum\n\n自动拆装箱\n\n泛型\n\n泛型中的通配符\n\n泛型限定：\n\n泛型的细节：\n\nAPI--- java.lang.System: 属性和行为都是静态的。\n\nAPI--- java.lang.Runtime: 类中没有构造方法，不能创建对象。\n\nAPI--- java.util.Math: 用于数学运算的工具类，属性和行为都是静态的。该类是final不允许继承。\n\nAPI--- java.util.Date：日期类，月份从0-11；\n\nAPI--- java.util. Calendar：日历类\n\nIO流：★★★★★，用于处理设备上数据。\n\n字节流\n\n字符流\n\nclose()和flush()的区别：\n\nFileWriter写入数据的细节：\n\nFileReader\n\nIO中的使用到了一个设计模式：装饰设计模式。灵活性较强\n\n字符流：\n\nReader\n\nWriter\n\n字节流：\n\nInputStream\n\nOutputStream\n\n缓冲区是提高效率用的，给谁提高呢？\n\nBufferedWriter\n\nBufferedReader：\n\n流对象\n\n转换流特有功能\n\nFile类\n\nFile类常见方法：\n\nJava.io.outputstream.PrintStream：打印流\n\nPrintWriter：具备了PrintStream的特点同时，还有自身特点：\n\nSequenceInputStream：序列流\n\nRandomAccessFile:\n\n管道流\n\n对象的序列化\n\nDataOutputStream、DataInputStream\n\nByteArrayInputStream：源：内存    ArrayStream\n\nByteArrayOutputStream：目的：内存。\n\n网络编程\n\nSocket：★★★★，套接字，通信的端点。\n\nUDP传输：\n\nudp的发送端：\n\nudp的接收端：\n\nTCP客户端：应先启动服务端\n\nTCP服务端：\n\n反射技术\n\n反射的基本步骤：\n\n反射的用法：\n\n正则表达式：★★★☆，其实是用来操作字符串的一些规则。\n\n组\n\n常见操作：\n\nJava基础知识精华部分\n写代码：\n1，明确需求。我要做什么？\n2，分析思路。我要怎么？1,2,3。\n3，确定步骤。每一个思路部分用到哪些语句，方法，和对象。\n4，代码实现。用具体的java语言代码把思路体现出来。\n学习新技术的四点：\n1，该技术是什么？\n2，该技术有什么特点(使用注意)：\n3，该技术怎么使用。demo\n4，该技术什么时候用？test。\n-----------------------------------------------------------------------------------------------\n一：java概述：\n1991 年Sun公司的James Gosling等人开始开发名称为 Oak 的语言，希望用于控制嵌入在有线电视交换盒、PDA等的微处理器；\n1994年将Oak语言更名为Java；\nJava的三种技术架构:\nJAVAEE：Java Platform Enterprise Edition，开发企业环境下的应用程序，主要针对web程序开发；\nJAVASE：Java Platform Standard Edition，完成桌面应用程序的开发，是其它两者的基础；\nJAVAME：Java Platform Micro Edition，开发电子消费产品和嵌入式设备，如手机中的程序；\n1，JDK：Java Development Kit，java的开发和运行环境，java的开发工具和jre。\n2，JRE：Java Runtime Environment，java程序的运行环境，java运行的所需的类库+JVM(java虚拟机)。\n3，配置环境变量：让java jdk\\bin目录下的工具，可以在任意目录下运行，原因是，将该工具所在目录告诉了系统，当使用该工具时，由系统帮我们去找指定的目录。\n环境变量的配置：\n   1）：永久配置方式：JAVA_HOME=%安装路径%\\Java\\jdk\n                     path=%JAVA_HOME%\\bin\n   2）：临时配置方式：set path=%path%;C:\\Program Files\\Java\\jdk\\bin\n特点：系统默认先去当前路径下找要执行的程序，如果没有，再去path中设置的路径下找。\nclasspath的配置:\n   1）：永久配置方式：classpath=.;c:\\;e:\\\n   2）：临时配置方式：set classpath=.;c:\\;e:\\\n注意：在定义classpath环境变量时，需要注意的情况\n如果没有定义环境变量classpath，java启动jvm后，会在当前目录下查找要运行的类文件；\n如果指定了classpath，那么会在指定的目录下查找要运行的类文件。\n还会在当前目录找吗？两种情况：\n   1）：如果classpath的值结尾处有分号，在具体路径中没有找到运行的类，会默认在当前目录再找一次。\n   2）：如果classpath的值结果出没有分号，在具体的路径中没有找到运行的类，不会再当前目录找。\n   一般不指定分号，如果没有在指定目录下找到要运行的类文件，就报错，这样可以调试程序。\n4，javac命令和java命令做什么事情呢？\n   要知道java是分两部分的：一个是编译，一个是运行。\n   javac：负责的是编译的部分，当执行javac时，会启动java的编译器程序。对指定扩展名的.java文件进行编译。 生成了jvm可以识别的字节码文件。也就是class文件，也就是java的运行程序。\n   java：负责运行的部分.会启动jvm.加载运行时所需的类库,并对class文件进行执行.\n   一个文件要被执行,必须要有一个执行的起始点,这个起始点就是main函数.\n\n\n二：java语法基础：\n1，关键字：其实就是某种语言赋予了特殊含义的单词。\n   保留字：其实就是还没有赋予特殊含义，但是准备日后要使用过的单词。\n2，标示符：其实就是在程序中自定义的名词。比如类名，变量名，函数名。包含 0-9、a-z、$、_ ；\n   注意：\n   1），数字不可以开头。\n   2），不可以使用关键字。\n3，常量：是在程序中的不会变化的数据。\n4，变量：其实就是内存中的一个存储空间，用于存储常量数据。\n   作用：方便于运算。因为有些数据不确定。所以确定该数据的名词和存储空间。\n   特点：变量空间可以重复使用。\n什么时候定义变量？只要是数据不确定的时候，就定义变量。\n变量空间的开辟需要什么要素呢？\n   1，这个空间要存储什么数据？数据类型。\n   2，这个空间叫什么名字啊？变量名称。\n   3，这个空间的第一次的数据是什么？ 变量的初始化值。\n变量的作用域和生存期:\n变量的作用域：\n   作用域从变量定义的位置开始，到该变量所在的那对大括号结束；\n生命周期：\n   变量从定义的位置开始就在内存中活了；\n   变量到达它所在的作用域的时候就在内存中消失了；\n数据类型：\n   1）：基本数据类型：byte、short、int、long、float、double、char、boolean\n   2）：引用数据类型: 数组、类、接口。\n级别从低到高为：byte,char,short(这三个平级)-->int-->float-->long-->double\n自动类型转换：从低级别到高级别，系统自动转的；\n强制类型转换：什么情况下使用?把一个高级别的数赋给一个别该数的级别低的变量；\n运算符号：\n   1）、算术运算符。\n       + - * / %   %:任何整数模2不是0就是1，所以只要改变被模数就可以实现开关运算。\n       +:连接符。\n       ++,--\n   2）、赋值运算符。\n       =  += -= *= /= %=\n   3）、比较运算符。\n       特点：该运算符的特点是：运算完的结果，要么是true，要么是false。\n   4）、逻辑运算符。\n       &  |  ^  !   &&   ||\n       逻辑运算符除了 !  外都是用于连接两个boolean类型表达式。\n       &: 只有两边都为true结果是true。否则就是false。\n       |:只要两边都为false结果是false，否则就是true\n       ^:异或：和或有点不一样。\n            两边结果一样，就为false。\n            两边结果不一样，就为true.\n       & 和 &&区别： & ：无论左边结果是什么，右边都参与运算。\n                    &&:短路与，如果左边为false，那么右边不参数与运算。\n       | 和|| 区别：|：两边都运算。\n                  ||：短路或，如果左边为true，那么右边不参与运算。\n   5）、位运算符:用于操作二进制位的运算符。\n       &  |  ^\n       <<  >>   >>>(无符号右移)\n\n        5.1 移位操作符：\n        \n                >>:右移，移出的高位补符号位\n            <<:左移，移出的低位补0\n            >>> :无符号右移，高位补0\n            int i = 13\n            00000000 00000000 00000000 00001101\n            13>>1 右移一位，高位补符号位，结果得6\n             0 00000000 00000000 00000000 0000110\n            13<<1 左移一位，低位直接补0，结果得26\n            0000000 00000000 00000000 00001101 0\n            int i =-13\n            先求：-13的补码\n            00000000 00000000 00000000 00001101 （绝对值的二进制）\n            取反加1后\n            11111111 11111111 11111111 11110011（-13的补码）\n            -13>>1 右移一位，高位补符号位.  \n             1 11111111 11111111 11111111 1111001\n            减1取反后（符号位不变）\n            1 00000000 00000000 00000000 0000111\n            最终结果得：-7\n            如果：-13>>>1 无符号右移一位，高位补0.  \n            0 11111111 11111111 11111111 1111001\n            ---------------------\n            面试题：\n            以最快的速度算出8*2或者8/2的结果?\n            8<<1\n            8>>1\n            int r = 8*2 //用到很多块内存，所以慢。\n        5.2 按位操作符\n            \n            &:按位与 ： 见0为0，全1为1\n            |:按位或，见1为1，全0为0\n            ^:按位异或，相同为0，相异为1\n            ~:取反，原来为1变为0，原来为0变为1\n\n            \n            使用的一些例子：\n            1 任何一个数异或同一个数2次得到自身，可以用做简单加密器\n\n\n   练习：对两个变量的数据进行互换。不需要第三方变量。\n           int a  = 3,b = 5;-->b = 3,a = 5;\n           a = a + b; a = 8;\n           b = a - b; b = 3;c\n           a = a - b; a = 5;\n           a = a ^ b;//\n           b = a ^ b;//b = a ^ b ^ b = a\n           a = a ^ b;//a = a ^ b ^ a = b;\n       练习：高效的算出 2*8 = 2<<3;\n5，语句。\n   If  switch  do while   while  for\n   这些语句什么时候用？\n   1）、当判断固定个数的值的时候，可以使用if，也可以使用switch。\n   但是建议使用switch，效率相对较高。\nswitch(变量){\n  case 值:要执行的语句;break;\n  …\n  default:要执行的语句;\n}\n工作原理：用小括号中的变量的值依次和case后面的值进行对比，和哪个case后面的值相同了\n          就执行哪个case后面的语句，如果没有相同的则执行default后面的语句；\n细节：1）：break是可以省略的，如果省略了就一直执行到遇到break为止；\n      2）：switch 后面的小括号中的变量应该是byte,char,short,int四种类型中的一种；\n      3）：default可以写在switch结构中的任意位置；如果将default语句放在了第一行，则不管expression与case中的value是否匹配，程序会从default开始执行直到第一个break出现。\n   2）、当判断数据范围，获取判断运算结果boolean类型时，需要使用if。\n   3）、当某些语句需要执行很多次时，就用循环结构。\n   while和for可以进行互换。\n   区别在于：如果需要定义变量控制循环次数。建议使用for。因为for循环完毕，变量在内存中释放。\nbreak:作用于switch ，和循环语句，用于跳出，或者称为结束。\nbreak语句单独存在时，下面不要定义其他语句，因为执行不到，编译会失败。当循环嵌套时，break只跳出当前所在循环。要跳出嵌套中的外部循环，只要给循环起名字即可，这个名字称之为标号。\ncontinue:只作用于循环结构，继续循环用的。\n作用：结束本次循环，继续下次循环。该语句单独存在时，下面不可以定义语句，执行不到。\n6，函 数：为了提高代码的复用性，可以将其定义成一个单独的功能，该功能的体现就是java中的函数。函数就是体现之一。\njava中的函数的定义格式：\n   修饰符 返回值类型 函数名(参数类型 形式参数1，参数类型 形式参数1，…){\n      执行语句；\n      return 返回值；\n   }\n当函数没有具体的返回值时，返回的返回值类型用void关键字表示。\n如果函数的返回值类型是void时，return语句可以省略不写的，系统会帮你自动加上。\nreturn的作用：结束函数。结束功能。\n如何定义一个函数？\n   函数其实就是一个功能，定义函数就是实现功能，通过两个明确来完成：\n   1）、明确该功能的运算完的结果，其实是在明确这个函数的返回值类型。\n   2）、在实现该功能的过程中是否有未知内容参与了运算，其实就是在明确这个函数的参数列表(参数类型&参数个数)。\n函数的作用：\n1）、用于定义功能。\n2）、用于封装代码提高代码的复用性。\n注意：函数中只能调用函数，不能定义函数。\n主函数：\n   1）、保证该类的独立运行。\n   2）、因为它是程序的入口。\n   3）、因为它在被jvm调用。\n函数定义名称是为什么呢？\n答：1）、为了对该功能进行标示，方便于调用。\n   2）、为了通过名称就可以明确函数的功能，为了增加代码的阅读性。\n重载\n定义是：在一个类中，如果出现了两个或者两个以上的同名函数，只要它们的参数的个数，或者参数的类型不同，即可称之为该函数重载了。\n如何区分重载：\n当函数同名时，只看参数列表。和返回值类型没关系。\n7，数 组：\n用于存储同一类型数据的一个容器。好处：可以对该容器中的数据进行编号，从0开始。数组用于封装数据，就是一个具体的实体。\n如何在java中表现一个数组呢？两种表现形式。\n1）、元素类型[] 变量名 = new 元素类型[元素的个数]；\n2）、元素类型[] 变量名 = {元素1，元素2...}；\n元素类型[] 变量名 = new 元素类型[]{元素1，元素2...}；\n\n//二分查找法。必须有前提：数组中的元素要有序。\n   public static int halfSeach_2(int[] arr,int key){\n       int min,max,mid;//定义最小，最大，中间数\n       min = 0;//最小为0\n       max = arr.length-1;// 最大为数组的长度-1\n       mid = (max+min)>>1; //(max+min)/2;//中间数为最大加最小除以2\n       while(arr[mid]!=key){//如果数组中間值不等于key\n           if(key>arr[mid]){//如果key>中間值\n               min = mid + 1;\n           }\n           else if(key<arr[mid])\n               max = mid - 1;\n           if(max<min)\n               return -1;\n           mid = (max+min)>>1;\n       }\n       return mid;\n   }\n\n\n\njava分了5片内存。\n1：寄存器。2：本地方法区。3：方法区。4：栈。5：堆。\n栈：存储的都是局部变量 ( 函数中定义的变量，函数上的参数，语句中的变量 )；\n   只要数据运算完成所在的区域结束，该数据就会被释放。\n堆：用于存储数组和对象，也就是实体。啥是实体啊？就是用于封装多个数据的。\n1：每一个实体都有内存首地址值。\n2：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。\n3：垃圾回收机制。\n\n\n\n三：面向对象：★★★★★\n特点：\n1：将复杂的事情简单化。\n2：面向对象将以前的过程中的执行者，变成了指挥者。\n3：面向对象这种思想是符合现在人们思考习惯的一种思想。\n过程和对象在我们的程序中是如何体现的呢？过程其实就是函数；对象是将函数等一些内容进行了封装。\n匿名对象使用场景：\n1：当对方法只进行一次调用的时候，可以使用匿名对象。\n2：当对象对成员进行多次调用时，不能使用匿名对象。必须给对象起名字。\n在类中定义其实都称之为成员。成员有两种：\n1：成员变量：其实对应的就是事物的属性。\n2：成员函数：其实对应的就是事物的行为。\n\n所以，其实定义类，就是在定义成员变量和成员函数。但是在定义前，必须先要对事物进行属性和行为的分析，才可以用代码来体现。\n\nprivate\nint age;//私有的访问权限最低，只有在本类中的访问有效。\n注意：私有仅仅是封装的一种体现形式而已。\n私有的成员：其他类不能直接创建对象访问，所以只有通过本类对外提供具体的访问方式来完成对私有的访问，可以通过对外提供函数的形式对其进行访问。\n好处：可以在函数中加入逻辑判断等操作，对数据进行判断等操作。\n总结：开发时，记住，属性是用于存储数据的，直接被访问，容易出现安全隐患，所以，类中的属性通常被私有化，并对外提供公共的访问方法。\n这个方法一般有两个，规范写法：对于属性 xxx，可以使用setXXX(),getXXX()对其进行操作。\n类中怎么没有定义主函数呢？\n注意：主函数的存在，仅为该类是否需要独立运行，如果不需要，主函数是不用定义的。\n主函数的解释：保证所在类的独立运行，是程序的入口，被jvm调用。\n成员变量和局部变量的区别：\n1：成员变量直接定义在类中。\n  局部变量定义在方法中，参数上，语句中。\n2：成员变量在这个类中有效。\n局部变量只在自己所属的大括号内有效，大括号结束，局部变量失去作用域。\n3：成员变量存在于堆内存中，随着对象的产生而存在，消失而消失。\n局部变量存在于栈内存中，随着所属区域的运行而存在，结束而释放。\n\n构造函数：\n用于给对象进行初始化，是给与之对应的对象进行初始化，它具有针对性，函数中的一种。\n特点：\n1：该函数的名称和所在类的名称相同。\n2：不需要定义返回值类型。\n3：该函数没有具体的返回值。\n记住：所有对象创建时，都需要初始化才可以使用。\n注意事项：一个类在定义时，如果没有定义过构造函数，那么该类中会自动生成一个空参数的构造函数，为了方便该类创建对象，完成初始化。如果在类中自定义了构造函数，那么默认的构造函数就没有了。\n一个类中，可以有多个构造函数，因为它们的函数名称都相同，所以只能通过参数列表来区分。所以，一个类中如果出现多个构造函数。它们的存在是以重载体现的。\n构造函数和一般函数有什么区别呢？\n1：两个函数定义格式不同。\n2：构造函数是在对象创建时，就被调用，用于初始化，而且初始化动作只执行一次。\n   一般函数，是对象创建后，需要调用才执行，可以被调用多次。\n\n什么时候使用构造函数呢？\n分析事物时，发现具体事物一出现，就具备了一些特征，那就将这些特征定义到构造函数内。\n构造代码块和构造函数有什么区别？\n构造代码块：是给所有的对象进行初始化，也就是说，所有的对象都会调用一个代码块。只要对象一建立。就会调用这个代码块。\n构造函数：是给与之对应的对象进行初始化。它具有针对性。\nPerson p = new Person();\n创建一个对象都在内存中做了什么事情？\n    1：先将硬盘上指定位置的Person.class文件加载进内存。\n    2：执行main方法时，在栈内存中开辟了main方法的空间(压栈-进栈)，然后在main方法的栈区分配了一个变量p。\n    3：在堆内存中开辟一个实体空间，分配了一个内存首地址值。new\n    4：在该实体空间中进行属性的空间分配，并进行了默认初始化。\n    5：对空间中的属性进行显示初始化。\n    6：进行实体的构造代码块初始化。\n    7：调用该实体对应的构造函数，进行构造函数初始化。（）\n    8：将首地址赋值给p ，p变量就引用了该实体。(指向了该对象)\n\n\n封 装（面向对象特征之一）：\n是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。\n好处：将变化隔离；便于使用；提高重用性；安全性。\n封装原则：将不需要对外提供的内容都隐藏起来，把属性都隐藏，提供公共方法对其访问。\nthis:代表对象。就是所在函数所属对象的引用。\nthis到底代表什么呢？哪个对象调用了this所在的函数，this就代表哪个对象，就是哪个对象的引用。\n开发时，什么时候使用this呢？\n在定义功能时，如果该功能内部使用到了调用该功能的对象，这时就用this来表示这个对象。\nthis 还可以用于构造函数间的调用。\n调用格式：this(实际参数)；\nthis对象后面跟上 .  调用的是成员属性和成员方法(一般方法)；\nthis对象后面跟上 () 调用的是本类中的对应参数的构造函数。\n注意：用this调用构造函数，必须定义在构造函数的第一行。因为构造函数是用于初始化的，所以初始化动作一定要执行。否则编译失败。\nstatic：\n★★★ 关键字，是一个修饰符，用于修饰成员(成员变量和成员函数)。\n特点：\n1，想要实现对象中的共性数据的对象共享。可以将这个数据进行静态修饰。\n2，被静态修饰的成员，可以直接被类名所调用。也就是说，静态的成员多了一种调用方式。类名.静态方式。\n3，静态随着类的加载而加载。而且优先于对象存在。\n弊端：\n1，有些数据是对象特有的数据，是不可以被静态修饰的。因为那样的话，特有数据会变成对象的共享数据。这样对事物的描述就出了问题。所以，在定义静态时，必须要明确，这个数据是否是被对象所共享的。\n2，静态方法只能访问静态成员，不可以访问非静态成员。\n因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。\n3，静态方法中不能使用this，super关键字。\n因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。\n4，主函数是静态的。\n什么时候定义静态成员呢？或者说：定义成员时，到底需不需要被静态修饰呢？\n成员分两种：\n1，成员变量。（数据共享时静态化）\n该成员变量的数据是否是所有对象都一样：\n如果是，那么该变量需要被静态修饰，因为是共享的数据。\n如果不是，那么就说这是对象的特有数据，要存储到对象中。\n2，成员函数。（方法中没有调用特有数据时就定义成静态）\n   如果判断成员函数是否需要被静态修饰呢？\n   只要参考，该函数内是否访问了对象中的特有数据：\n   如果有访问特有数据，那方法不能被静态修饰。\n   如果没有访问过特有数据，那么这个方法需要被静态修饰。\n成员变量和静态变量的区别：\n1，成员变量所属于对象。所以也称为实例变量。\n静态变量所属于类。所以也称为类变量。\n2，成员变量存在于堆内存中。\n静态变量存在于方法区中。\n3，成员变量随着对象创建而存在。随着对象被回收而消失。\n静态变量随着类的加载而存在。随着类的消失而消失。\n4，成员变量只能被对象所调用 。\n静态变量可以被对象调用，也可以被类名调用。\n所以，成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。\n静态的注意：静态的生命周期很长。\n静态代码块：就是一个有静态关键字标示的一个代码块区域。定义在类中。\n作用：可以完成类的初始化。静态代码块随着类的加载而执行，而且只执行一次（new 多个对象就只执行一次）。如果和主函数在同一类中，优先于主函数执行。\nPublic：访问权限最大。\nstatic：不需要对象，直接类名即可。\nvoid：主函数没有返回值。\nMain：主函数特定的名称。\n(String[] args)：主函数的参数，是一个字符串数组类型的参数，jvm调用main方法时，传递的实际参数是 new String[0]。\njvm默认传递的是长度为0的字符串数组，我们在运行该类时，也可以指定具体的参数进行传递。可以在控制台，运行该类时，在后面加入参数。参数之间通过空格隔开。jvm会自动将这些字符串参数作为args数组中的元素，进行存储。\n静态代码块、构造代码块、构造函数同时存在时的执行顺序：静态代码块 à 构造代码块 à 构造函数；\n生成Java帮助文档：\n命令格式：javadoc –d 文件夹名 –auther –version *.java\n/**     //格式\n*类描述\n*@author 作者名\n*@version 版本号\n*/\n/**\n*方法描述\n*@param  参数描述\n*@return  返回值描述\n*/\n\n\n\n\n设计模式\n解决问题最行之有效的思想。是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。\njava中有23种设计模式：\n单例设计模式：★★★★★\n解决的问题：保证一个类在内存中的对象唯一性。\n比如：多程序读取一个配置文件时，建议配置文件封装成对象。会方便操作其中数据，又要保证多个程序读到的是同一个配置文件对象，就需要该配置文件对象在内存中是唯一的。\nRuntime()方法就是单例设计模式进行设计的。\n如何保证对象唯一性呢？\n思想：\n1，不让其他程序创建该类对象。\n2，在本类中创建一个本类对象。\n3，对外提供方法，让其他程序获取这个对象。\n步骤：\n1，因为创建对象都需要构造函数初始化，只要将本类中的构造函数私有化，其他程序就无法再创建该类对象；\n2，就在类中创建一个本类的对象；\n3，定义一个方法，返回该对象，让其他程序可以通过方法就得到本类对象。（作用：可控）\n代码体现：\n1，私有化构造函数；\n2，创建私有并静态的本类对象；\n3，定义公有并静态的方法，返回该对象。\n//饿汉式\nclass Single{\n   private Single(){} //私有化构造函数。\nprivate static Single s = new Single(); //创建私有并静态的本类对象。\n   public static Single getInstance(){ //定义公有并静态的方法，返回该对象。\n       return s;\n   }\n}\n---------------------------------------------\n//懒汉式:延迟加载方式。\nclass Single2{\n   private Single2(){}\nprivate static Single2 s = null;\n   public static Single2 getInstance(){\n       if(s==null)\n           s = new Single2();\n       return s;\n   }\n}\n继 承（面向对象特征之一）\n好处：\n1：提高了代码的复用性。\n2：让类与类之间产生了关系，提供了另一个特征多态的前提。\n父类的由来：其实是由多个类不断向上抽取共性内容而来的。\njava中对于继承，java只支持单继承。java虽然不直接支持多继承，但是保留了这种多继承机制，进行改良。\n单继承：一个类只能有一个父类。\n多继承：一个类可以有多个父类。\n为什么不支持多继承呢？\n因为当一个类同时继承两个父类时，两个父类中有相同的功能，那么子类对象调用该功能时，运行哪一个呢？因为父类中的方法中存在方法体。\n但是java支持多重继承。A继承B  B继承C  C继承D。\n多重继承的出现，就有了继承体系。体系中的顶层父类是通过不断向上抽取而来的。它里面定义的该体系最基本最共性内容的功能。\n所以，一个体系要想被使用，直接查阅该系统中的父类的功能即可知道该体系的基本用法。那么想要使用一个体系时，需要建立对象。建议建立最子类对象，因为最子类不仅可以使用父类中的功能。还可以使用子类特有的一些功能。\n简单说：对于一个继承体系的使用，查阅顶层父类中的内容，创建最底层子类的对象。\n子父类出现后，类中的成员都有了哪些特点：\n1：成员变量。\n    当子父类中出现一样的属性时，子类类型的对象，调用该属性，值是子类的属性值。\n    如果想要调用父类中的属性值，需要使用一个关键字：super\n    This：代表是本类类型的对象引用。\n    Super：代表是子类所属的父类中的内存空间引用。\n    注意：子父类中通常是不会出现同名成员变量的，因为父类中只要定义了，子类就不用在定义了，直接继承过来用就可以了。\n2：成员函数。\n当子父类中出现了一模一样的方法时，建立子类对象会运行子类中的方法。好像父类中的方法被覆盖掉一样。所以这种情况，是函数的另一个特性：覆盖(复写，重写)\n什么时候使用覆盖呢？当一个类的功能内容需要修改时，可以通过覆盖来实现。\n3：构造函数。\n发现子类构造函数运行时，先运行了父类的构造函数。为什么呢?\n\n原因：子类的所有构造函数中的第一行，其实都有一条隐身的语句super();\nsuper(): 表示父类的构造函数，并会调用于参数相对应的父类中的构造函数。而super():是在调用父类中空参数的构造函数。\n为什么子类对象初始化时，都需要调用父类中的函数？(为什么要在子类构造函数的第一行加入这个super()?)\n\n因为子类继承父类，会继承到父类中的数据，所以必须要看父类是如何对自己的数据进行初始化的。所以子类在进行对象初始化时，先调用父类的构造函数，这就是子类的实例化过程。\n\n注意：子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super();\n如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。\n如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。\n问题：super()和this()是否可以同时出现的构造函数中。\n两个语句只能有一个定义在第一行，所以只能出现其中一个。\n\nsuper()或者this():为什么一定要定义在第一行？\n因为super()或者this()都是调用构造函数，构造函数用于初始化，所以初始化的动作要先完成。\n继承的细节：\n什么时候使用继承呢？\n当类与类之间存在着所属关系时，才具备了继承的前提。a是b中的一种。a继承b。狼是犬科中的一种。\n英文书中，所属关系：\" is a \"\n注意：不要仅仅为了获取其他类中的已有成员进行继承。\n所以判断所属关系，可以简单看，如果继承后，被继承的类中的功能，都可以被该子类所具备，那么继承成立。如果不是，不可以继承。\n细节二：\n在方法覆盖时，注意两点：\n1：子类覆盖父类时，必须要保证，子类方法的权限必须大于等于父类方法权限可以实现继承（public>protected>default>private）。否则，编译失败。\n2：覆盖时，要么都静态，要么都不静态。 (静态只能覆盖静态，或者被静态覆盖)\n继承的一个弊端：打破了封装性。对于一些类，或者类中功能，是需要被继承，或者复写的。\n这时如何解决问题呢？介绍一个关键字，final:最终。\nfinal特点：\n1：这个关键字是一个修饰符，可以修饰类，方法，变量。\n2：被final修饰的类是一个最终类，不可以被继承。\n3：被final修饰的方法是一个最终方法，不可以被覆盖。\n4：被final修饰的变量是一个常量，只能赋值一次。\n   其实这样的原因的就是给一些固定的数据起个阅读性较强的名称。\n   不加final修饰不是也可以使用吗？那么这个值是一个变量，是可以更改的。加了final，程序更为严谨。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 _ 连接。\n抽象类: abstract\n抽象：不具体，看不明白。抽象类表象体现。\n在不断抽取过程中，将共性内容中的方法声明抽取，但是方法不一样，没有抽取，这时抽取到的方法，并不具体，需要被指定关键字abstract所标示，声明为抽象方法。\n抽象方法所在类一定要标示为抽象类，也就是说该类需要被abstract关键字所修饰。\n抽象类的特点：\n1：抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。\n2：抽象方法只定义方法声明，并不定义方法实现。\n3：抽象类不可以被创建对象(实例化)。\n4：只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。\n抽象类的细节：\n1：抽象类中是否有构造函数？有，用于给子类对象进行初始化。\n2：抽象类中是否可以定义非抽象方法？\n   可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。只不过，比一般类多了一个抽象函数。而且比一般类少了一个创建对象的部分。\n3：抽象关键字abstract和哪些不可以共存？final ,   private , static\n4：抽象类中可不可以不定义抽象方法？可以。抽象方法目的仅仅为了不让该类创建对象。\n模板方法设计模式：\n解决的问题：当功能内部一部分实现时确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。\nabstract class GetTime{\n   public final void getTime(){ //此功能如果不需要复写，可加final限定\n       long start = System.currentTimeMillis();\n       code(); //不确定的功能部分，提取出来，通过抽象方法实现\n       long end = System.currentTimeMillis();\n       System.out.println(\"毫秒是：\"+(end-start));\n   }\n   public abstract void code(); //抽象不确定的功能，让子类复写实现\n}\nclass SubDemo extends GetTime{\n   public void code(){ //子类复写功能方法\n       for(int y=0; y<1000; y++){\n           System.out.println(\"y\");\n       }\n   }\n}\n接 口：★★★★★\n1：是用关键字interface定义的。\n2：接口中包含的成员，最常见的有全局常量、抽象方法。\n注意：接口中的成员都有固定的修饰符。\n\n   成员变量：public static final\n   成员方法：public abstract\ninterface Inter{\n   public static final int x = 3;\n   public abstract void show();\n}\n3：接口中有抽象方法，说明接口不可以实例化。接口的子类必须实现了接口中所有的抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。\n\n4：类与类之间存在着继承关系，类与接口中间存在的是实现关系。\n   继承用extends  ；实现用implements ；\n5：接口和类不一样的地方，就是，接口可以被多实现，这就是多继承改良后的结果。java将多继承机制通过多现实来体现。\n6：一个类在继承另一个类的同时，还可以实现多个接口。所以接口的出现避免了单继承的局限性。还可以将类进行功能的扩展。\n7：其实java中是有多继承的。接口与接口之间存在着继承关系，接口可以多继承接口。\n接口都用于设计上，设计上的特点：（可以理解主板上提供的接口）\n1：接口是对外提供的规则。\n2：接口是功能的扩展。\n3：接口的出现降低了耦合性。\n抽象类与接口：\n抽象类：一般用于描述一个体系单元，将一组共性内容进行抽取，特点：可以在类中定义抽象内容让子类实现，可以定义非抽象内容让子类直接使用。它里面定义的都是一些体系中的基本内容。\n接口：一般用于定义对象的扩展功能，是在继承之外还需这个对象具备的一些功能。\n抽象类和接口的共性：都是不断向上抽取的结果。\n抽象类和接口的区别：\n1：抽象类只能被继承，而且只能单继承。\n接口需要被实现，而且可以多实现。\n2：抽象类中可以定义非抽象方法，子类可以直接继承使用。\n接口中都有抽象方法，需要子类去实现。\n3：抽象类使用的是  is a 关系。\n接口使用的 like a 关系。\n4：抽象类的成员修饰符可以自定义。\n接口中的成员修饰符是固定的。全都是public的。在开发之前，先定义规则，A和B分别开发，A负责实现这个规则，B负责使用这个规则。至于A是如何对规则具体实现的，B是不需要知道的。这样这个接口的出现就降低了A和B直接耦合性。\n\n\n多 态★★★★★（面向对象特征之一）\n函数本身就具备多态性，某一种事物有不同的具体的体现。\n体现：父类引用或者接口的引用指向了自己的子类对象。//Animal a = new Cat();\n多态的好处：提高了程序的扩展性。\n多态的弊端：当父类引用指向子类对象时，虽然提高了扩展性，但是只能访问父类中具备的方法，不可以访问子类中特有的方法。(前期不能使用后期产生的功能，即访问的局限性)\n多态的前提：\n   1：必须要有关系，比如继承、或者实现。\n   2：通常会有覆盖操作。\n多态的出现思想上也做着变化：以前是创建对象并指挥对象做事情。有了多态以后，我们可以找到对象的共性类型，直接操作共性类型做事情即可，这样可以指挥一批对象做事情，即通过操作父类或接口实现。\nclass 毕姥爷{\n   void 讲课(){\n       System.out.println(\"企业管理\");\n   }\n   void 钓鱼(){\n       System.out.println(\"钓鱼\");\n   }\n}\nclass 毕老师 extends 毕姥爷{\n   void 讲课(){\n       System.out.println(\"JAVA\");\n   }\n   void 看电影(){\n       System.out.println(\"看电影\");\n   }\n}\nclass {\n   public static void main(String[] args) {\n       毕姥爷 x = new 毕老师(); //毕老师对象被提升为了毕姥爷类型。\n//      x.讲课();\n//      x.看电影(); //错误.\n       毕老师 y = (毕老师)x; //将毕姥爷类型强制转换成毕老师类型。\n       y.看电影();//在多态中，自始自终都是子类对象在做着类型的变化。\n   }\n}\n如果想用子类对象的特有方法，如何判断对象是哪个具体的子类类型呢？\n\n可以可以通过一个关键字 instanceof ;//判断对象是否实现了指定的接口或继承了指定的类\n格式：<对象 instanceof 类型> ，判断一个对象是否所属于指定的类型。\nStudent instanceof Person = true;//student继承了person类\n多态在子父类中的成员上的体现的特点：\n1，成员变量：在多态中，子父类成员变量同名。\n   在编译时期：参考的是引用型变量所属的类中是否有调用的成员。（编译时不产生对象，只检查语法错误）\n   运行时期：也是参考引用型变量所属的类中是否有调用的成员。\n   简单一句话：无论编译和运行，成员变量参考的都是引用变量所属的类中的成员变量。\n   再说的更容易记忆一些：成员变量 --- 编译运行都看 = 左边。\n2，成员函数。\n   编译时期：参考引用型变量所属的类中是否有调用的方法。\n   运行事情：参考的是对象所属的类中是否有调用的方法。\n   为什么是这样的呢？因为在子父类中，对于一模一样的成员函数，有一个特性：覆盖。\n   简单一句：成员函数，编译看引用型变量所属的类，运行看对象所属的类。\n   更简单：成员函数 --- 编译看 = 左边，运行看 = 右边。\n3，静态函数。\n   编译时期：参考的是引用型变量所属的类中是否有调用的成员。\n   运行时期：也是参考引用型变量所属的类中是否有调用的成员。\n   为什么是这样的呢？因为静态方法，其实不所属于对象，而是所属于该方法所在的类。\n   调用静态的方法引用是哪个类的引用调用的就是哪个类中的静态方法。   简单说：静态函数 --- 编译运行都看 = 左边。\n\n\njava.lang.Object\nObject：所有类的直接或者间接父类，Java认为所有的对象都具备一些基本的共性内容，这些内容可以不断的向上抽取，最终就抽取到了一个最顶层的类中的，该类中定义的就是所有对象都具备的功能。\n具体方法：\n1，boolean equals(Object obj)\n用于比较两个对象是否相等，其实内部比较的就是两个对象地址。\n而根据对象的属性不同，判断对象是否相同的具体内容也不一样。所以在定义类时，一般都会复写equals方法，建立本类特有的判断对象是否相同的依据。\n public boolean equals(Object obj){\n     if(!(obj instanceof Person))\n         return false;\n     Person p = (Person)obj;\n     return this.age == p.age;\n }\n2，String toString()\n将对象变成字符串；默认返回的格式：类名@哈希值 = getClass().getName() + '@' + Integer.toHexString(hashCode())\n如果直接打印对象的调用，会默认调用toString方法。\n 为了对象对应的字符串内容有意义，可以通过复写，建立该类对象自己特有的字符串表现形式。\n public String toString(){\n     return \"person : \"+age;\n }\n\n\n3，Class getClass()\n获取任意对象运行时的所属字节码文件对象。\n4，int hashCode()\n返回该对象的哈希码值。支持此方法是为了提高哈希表的性能。\n通常equals，toString，hashCode，在应用中都会被复写，建立具体对象的特有的内容。\n\n\n内部类\n如果A类需要直接访问B类中的成员，而B类又需要建立A类的对象。这时,为了方便设计和访问，直接将A类定义在B类中。就可以了。A类就称为内部类。内部类可以直接访问外部类中的成员。而外部类想要访问内部类，必须要建立内部类的对象。\nclass Outer{\n   int num = 4;    \n   class  Inner {\n       void show(){\n           System.out.println(\"inner show run \"+num);        \n       }\n   }\n   public void method(){\n       Inner in = new Inner();//创建内部类的对象。\n       in.show();//调用内部类的方法。\n   }\n}\n当内部类定义在外部类中的成员位置上，可以使用一些成员修饰符修饰 private、static。\n1：默认修饰符。\n直接访问内部类格式：外部类名.内部类名 变量名 =  外部类对象.内部类对象;\nOuter.Inner in = new Outer.new Inner();//这种形式很少用。\n 但是这种应用不多见，因为内部类之所以定义在内部就是为了封装。想要获取内部类对象通常都通过外部类的方法来获取。这样可以对内部类对象进行控制。\n2：私有修饰符。\n 通常内部类被封装，都会被私有化，因为封装性不让其他程序直接访问。\n3：静态修饰符。\n 如果内部类被静态修饰，相当于外部类，会出现访问局限性，只能访问外部类中的静态成员。\n 注意；如果内部类中定义了静态成员，那么该内部类必须是静态的。\n内部类编译后的文件名为：“外部类名$内部类名.java”；\n为什么内部类可以直接访问外部类中的成员呢？\n那是因为内部中都持有一个外部类的引用。这个是引用是 外部类名.this\n内部类可以定义在外部类中的成员位置上，也可以定义在外部类中的局部位置上。\n当内部类被定义在局部位置上，只能访问局部中被final修饰的局部变量。\n匿名内部类：没有名字的内部类。就是内部类的简化形式。一般只用一次就可以用这种形式。匿名内部类其实就是一个匿名子类对象。想要定义匿名内部类：需要前提，内部类必须继承一个类或者实现接口。\n匿名内部类的格式：new 父类名&接口名(){ 定义子类成员或者覆盖父类方法 }.方法。\n匿名内部类的使用场景：\n当函数的参数是接口类型引用时，如果接口中的方法不超过3个。可以通过匿名内部类来完成参数的传递。\n其实就是在创建匿名内部类时，该类中的封装的方法不要过多，最好两个或者两个以内。\n//面试\n       //1\n       new Object(){\n           void show(){\n               System.out.println(\"show run\");                \n           }\n       }.show();\n       //2\n       Object obj = new Object(){\n           void show(){\n               System.out.println(\"show run\");\n           }\n       };\n       obj.show();\n       \n       1和2的写法正确吗？有区别吗？说出原因。\n       写法是正确，1和2都是在通过匿名内部类建立一个Object类的子类对象。\n       区别：\n       第一个可是编译通过，并运行。\n       第二个编译失败，因为匿名内部类是一个子类对象，当用Object的obj引用指向时，就被提升为了\n       Object类型，而编译时检查Object类中是否有show方法，所以编译失败。\n-------------------------------------------------------\nclass InnerClassDemo6 {\n   +（static）class Inner{\n       void show(){}\n   }\n   public void method(){\n       this.new Inner().show();//可以\n   }\n   public static void main(String[] args) {//static不允许this\n       This.new Inner().show();//错误，Inner类需要定义成static\n   }\n}\n------------------------------------------------------\ninterface Inter{\n   void show();\n}\nclass Outer{//通过匿名内部类补足Outer类中的代码。\n   public static Inter method(){\n       return new Inter(){\n           public void show(){}\n       };\n   }\n}\nclass InnerClassDemo7 {\n   public static void main(String[] args) {\n       Outer.method().show();\n   /*\n       Outer.method():意思是：Outer中有一个名称为method的方法，而且这个方法是静态的。\n       Outer.method().show():当Outer类调用静态的method方法运算结束后的结果又调用了show方法，意味着：method()方法运算完一个是对象，而且这个对象是Inter类型的。\n   */\n       function (new Inter(){\n           public void show(){}\n       }); //匿名内部类作为方法的参数进行传递。\n   }\n   public static void function(Inter in){\n       in.show();\n   }\n}\n异 常：★★★★\n异常：就是不正常。程序在运行时出现的不正常情况。其实就是程序中出现的问题。这个问题按照面向对象思想进行描述，并封装成了对象。因为问题的产生有产生的原因、有问题的名称、有问题的描述等多个属性信息存在。当出现多属性信息最方便的方式就是将这些信息进行封装。异常就是java按照面向对象的思想将问题进行对象封装。这样就方便于操作问题以及处理问题。\n出现的问题有很多种，比如角标越界，空指针等都是。就对这些问题进行分类。而且这些问题都有共性内容比如：每一个问题都有名称，同时还有问题描述的信息，问题出现的位置，所以可以不断的向上抽取。形成了异常体系。\n--------java.lang.Throwable：\nThrowable：可抛出的。\n   |--Error：错误，一般情况下，不编写针对性的代码进行处理，通常是jvm发生的，需要对程序进行修正。\n   |--Exception：异常，可以有针对性的处理方式\n无论是错误还是异常，它们都有具体的子类体现每一个问题，它们的子类都有一个共性，就是都以父类名才作为子类的后缀名。\n这个体系中的所有类和对象都具备一个独有的特点；就是可抛性。\n可抛性的体现：就是这个体系中的类和对象都可以被throws和throw两个关键字所操作。\n\nclass  ExceptionDemo{\n   public static void main(String[] args) {\n//      byte[] buf = new byte[1024*1024*700];//java.lang.OutOfMemoryError内存溢出错误\n   }\n}\n在开发时，如果定义功能时，发现该功能会出现一些问题，应该将问题在定义功能时标示出来，这样调用者就可以在使用这个功能的时候，预先给出处理方式。\n\n如何标示呢？通过throws关键字完成，格式：throws 异常类名,异常类名...\n这样标示后，调用者，在使用该功能时，就必须要处理，否则编译失败。\n处理方式有两种：1、捕捉；2、抛出。\n对于捕捉：java有针对性的语句块进行处理。\ntry {\n   需要被检测的代码；\n}\ncatch(异常类 变量名){\n   异常处理代码；\n}\nfianlly{\n   一定会执行的代码；\n}\n--------------------------------------------------------\ncatch (Exception e) { //e用于接收try检测到的异常对象。\n   System.out.println(\"message:\"+e.getMessage());//获取的是异常的信息。\n   System.out.println(\"toString:\"+e.toString());//获取的是异常的名字+异常的信息。\n   e.printStackTrace();//打印异常在堆栈中信息；异常名称+异常信息+异常的位置。\n}\n\n\n异常处理原则：功能抛出几个异常，功能调用如果进行try处理，需要与之对应的catch处理代码块，这样的处理有针对性，抛几个就处理几个。\n特殊情况：try对应多个catch时，如果有父类的catch语句块，一定要放在下面。\nthrow 和throws关键字的区别：\nthrow用于抛出异常对象，后面跟的是异常对象；throw用在函数内。\nthrows用于抛出异常类，后面跟的异常类名，可以跟多个，用逗号隔开。throws用在函数上。\n通常情况：函数内容如果有throw，抛出异常对象，并没有进行处理，那么函数上一定要声明，否则编译失败。但是也有特殊情况。\n异常分两种：\n1：编译时被检查的异常，只要是Exception及其子类都是编译时被检测的异常。\n2：运行时异常，其中Exception有一个特殊的子类RuntimeException，以及RuntimeException的子类是运行异常，也就说这个异常是编译时不被检查的异常。\n编译时被检查的异常和运行时异常的区别：\n编译被检查的异常在函数内被抛出，函数必须要声明，否编译失败。\n声明的原因：是需要调用者对该异常进行处理。\n运行时异常如果在函数内被抛出，在函数上不需要声明。\n不声明的原因：不需要调用者处理，运行时异常发生，已经无法再让程序继续运行，所以，不让调用处理的，直接让程序停止，由调用者对代码进行修正。\n定义异常处理时，什么时候定义try，什么时候定义throws呢？\n功能内部如果出现异常，如果内部可以处理，就用try；\n如果功能内部处理不了，就必须声明出来，让调用者处理。\n自定义异常：当开发时，项目中出现了java中没有定义过的问题时，这时就需要我们按照java异常建立思想，将项目的中的特有问题也进行对象的封装。这个异常，称为自定义异常。\n对于除法运算，0作为除数是不可以的。java中对这种问题用ArithmeticException类进行描述。对于这个功能，在我们项目中，除数除了不可以为0外，还不可以为负数。可是负数的部分java并没有针对描述。所以我们就需要自定义这个异常。\n自定义异常的步骤：\n1：定义一个子类继承Exception或RuntimeException，让该类具备可抛性。\n2：通过throw 或者throws进行操作。\n异常的转换思想：当出现的异常是调用者处理不了的，就需要将此异常转换为一个调用者可以处理的异常抛出。\ntry  catch  finally的几种结合方式：\n1，\ntry\ncatch\nfinally\n2,\ntry\ncatch\n3,\ntry\nfinally\n\n\n这种情况，如果出现异常，并不处理，但是资源一定关闭，所以try  finally集合只为关闭资源。\n记住：finally很有用，主要用户关闭资源。无论是否发生异常，资源都必须进行关闭。\nSystem.exit(0); //退出jvm，只有这种情况finally不执行。\n当异常出现后，在子父类进行覆盖时，有了一些新的特点：\n1：当子类覆盖父类的方法时，如果父类的方法抛出了异常，那么子类的方法要么不抛出异常要么抛出父类异常或者该异常的子类，不能抛出其他异常。\n2：如果父类抛出了多个异常，那么子类在覆盖时只能抛出父类的异常的子集。\n注意：\n如果父类或者接口中的方法没有抛出过异常，那么子类是不可以抛出异常的，如果子类的覆盖的方法中出现了异常，只能try不能throws。\n如果这个异常子类无法处理，已经影响了子类方法的具体运算，这时可以在子类方法中，通过throw抛出RuntimeException异常或者其子类，这样，子类的方法上是不需要throws声明的。\n常见异常：\n1、脚标越界异常（IndexOutOfBoundsException）包括数组、字符串；\n空指针异常（NullPointerException）\n2、类型转换异常：ClassCastException\n3、没有这个元素异常：NullPointerException\n4、不支持操作异常；\n异常要尽量避免，如果避免不了，需要预先给出处理方式。比如家庭备药，比如灭火器。\n\n\n包：定义包用package关键字。包中可以还有包\n1：对类文件进行分类管理。\n2：给类文件提供多层名称空间。\n如果生成的包不在当前目录下，需要最好执行classpath，将包所在父目录定义到classpath变量中即可。\n一般在定义包名时，因为包的出现是为了区分重名的类。所以包名要尽量唯一。怎么保证唯一性呢？可以使用url域名来进行包名称的定义。url域名倒序\npackage pack;//定义了一个包，名称为pack。 注意：包名的写法规范：所有字母都小写。\n//package cn.itcast.pack.demo;\n类的全名称是 包名.类名\n   编译命令：javac –d 位置（.当前路径） java源文件 （就可以自动生成包）\n包是一种封装形式，用于封装类，想要被包以外的程序访问，该类必须public；\n类中的成员，如果被包以外访问，也必须public；\n包与包之间访问可以使用的权限有两种：\n1：public\n2：protected：只能是不同包中的子类可以使用的权限。\n总结java中的四种权限：\n  范围       public protected(保护)       default（默认）       private\n同一个类中       ok            ok              ok              ok\n同一包中         ok             ok              ok      \n子类             ok        \n不同包中         ok             ok\n\n\nImport - 导入：类名称变长，写起来很麻烦。为了简化，使用了一个关键字：import，可以使用这个关键字导入指定包中的类。记住：实际开发时,到的哪个类就导入哪个类，不建议使用*.\nimport packa.*;//这个仅仅是导入了packa当前目录下的所有的类。不包含子包。\nimport packa.abc.*;//导入了packa包中的子包abc下的当前的所有类。\n如果导入的两个包中存在着相同名称的类。这时如果用到该类，必须在代码中指定包名。\n常见的软件包:\njava.lang : language java的核心包，Object System  String Throwable jdk1.2版本后，该包中的类自动被导入。\njava.awt : 定义的都是用于java图形界面开发的对象。\njavax.swing: 提供所有的windows桌面应用程序包括的控件,比如：Frame , Dialog, Table, List 等等,就是java的图形界面库。\njava.net : 用于java网络编程方面的对象都在该包中。\njava.io : input  output 用于操作设备上数据的对象都在该包中。比如：读取硬盘数据，往硬盘写入数据。\njava.util : java的工具包，时间对象，集合框架。\njava.applet: application+let 客户端java小程序。server+let  -->  servlet 服务端java小程序。\njar ：java的压缩包，主要用于存储类文件，或者配置文件等。\n命令格式：jar –cf 包名.jar 包目录\n  解压缩：jar –xvf 包名.jar\n将jar包目录列表重定向到一个文件中：jar –tf 包名.jar >c:\\1.txt\n\n\n多线程：★★★★\n进程\n正在进行中的程序。其实进程就是一个应用程序运行时的内存分配空间。\n线程\n其实就是进程中一个程序执行控制单元(进程由线程组成)，一条执行路径。进程负责的是应用程序的空间的标示。线程负责的是应用程序的执行顺序。\n一个进程至少有一个线程在运行，当一个进程中出现多个线程时，就称这个应用程序是多线程应用程序，每个线程在栈区中都有自己的执行空间，自己的方法区、自己的变量。\njvm在启动的时，首先有一个主线程，负责程序的执行，调用的是main函数。主线程执行的代码都在main方法中。JavaVM启动的时候会有一个进程java.exe\n当产生垃圾时，收垃圾的动作，是不需要主线程来完成，因为这样，会出现主线程中的代码执行会停止，会去运行垃圾回收器代码，效率较低，所以由单独一个线程来负责垃圾回收。故至少有两个进程。\n随机性的原理\n因为cpu的快速切换造成，哪个线程获取到了cpu的执行权，哪个线程就执行。//我们可以形象把多线程的运行行为认为在互相抢夺cpu的执行权。\n返回当前线程的名称：Thread.currentThread().getName()//Thread.currentThread()返回的是线程对象\n\n线程的名称是由：Thread-编号定义的。编号从0开始。\n线程要运行的代码都统一存放在了run方法中。\n线程要运行必须要通过类中指定的方法开启。start方法。（启动后，就多了一条执行路径）\nstart方法：1）、启动了线程；2）、让jvm调用了run方法。\n创建线程的第一种方式：继承Thread ，由子类复写run方法。\n步骤：\n1，定义类继承Thread类；\n2，目的是复写run方法，将要让线程运行的代码都存储到run方法中；\n3，通过创建Thread类的子类对象，创建线程对象；\n4，调用线程的start方法，开启线程，并执行run方法。若仅调用run方法，则仅用对象调用方法，线程创建了，但未运行。\n线程状态：\n被创建：start()\n运行：具备执行资格，同时具备执行权；\n冻结：sleep(time),wait()—notify()唤醒；线程释放了执行权，同时释放执行资格；\n临时阻塞状态：线程具备cpu的执行资格，没有cpu的执行权；\n消亡：stop()\n\n创建线程的第二种方式：实现一个接口Runnable。\n步骤：\n1，定义类实现Runnable接口。\n2，覆盖接口中的run方法（用于封装线程要运行的代码）。\n3，通过Thread类创建线程对象；\n4，将实现了Runnable接口的子类对象作为实际参数传递给Thread类中的构造函数。\n为什么要传递呢？因为要让线程对象明确要运行的run方法所属的对象。\n5，调用Thread对象的start方法。开启线程，并运行Runnable接口子类中的run方法。\n       Ticket t = new Ticket();\n       /*\n       直接创建Ticket对象，并不是创建线程对象。\n       因为创建对象只能通过new Thread类，或者new Thread类的子类才可以。\n       所以最终想要创建线程。既然没有了Thread类的子类，就只能用Thread类。\n       */\n       Thread t1 = new Thread(t); //创建线程。\n       /*\n       只要将t作为Thread类的构造函数的实际参数传入即可完成线程对象和t之间的关联\n       为什么要将t传给Thread类的构造函数呢？其实就是为了明确线程要运行的代码run方法。\n       */\n       t1.start();\n       \n\n为什么要有Runnable接口的出现？\n1：通过继承Thread类的方式，可以完成多线程的建立。但是这种方式有一个局限性，如果一个类已经有了自己的父类，就不可以继承Thread类，因为java单继承的局限性。\n可是该类中的还有部分代码需要被多个线程同时执行。这时怎么办呢？\n只有对该类进行额外的功能扩展，java就提供了一个接口Runnable。这个接口中定义了run方法，其实run方法的定义就是为了存储多线程要运行的代码。\n所以，通常创建线程都用第二种方式。\n因为实现Runnable接口可以避免单继承的局限性。\n2：其实是将不同类中需要被多线程执行的代码进行抽取。将多线程要运行的代码的位置单独定义到接口中。为其他类进行功能扩展提供了前提。\n所以Thread类在描述线程时，内部定义的run方法，也来自于Runnable接口。\n实现Runnable接口可以避免单继承的局限性。而且，继承Thread，是可以对Thread类中的方法，进行子类复写的。但是不需要做这个复写动作的话，只为定义线程代码存放位置，实现Runnable接口更方便一些。所以Runnable接口将线程要执行的任务封装成了对象。\n-------------------------------------------------------\n//面试\n       new Thread(new Runnable(){  //匿名\n           public void run(){\n               System.out.println(\"runnable run\");    \n           }\n       }\n       {\n           public void run(){\n               System.out.println(\"subthread run\");\n           }\n       }.start();  //结果：subthread run\n---------------------------------------------------------\nTry {\nThread.sleep(10);\n}catch(InterruptedException e){}// 当刻意让线程稍微停一下，模拟cpu切换情况。\n\n\n多线程安全问题的原因：\n通过图解：发现一个线程在执行多条语句时，并运算同一个数据时，在执行过程中，其他线程参与进来，并操作了这个数据。导致到了错误数据的产生。\n涉及到两个因素：\n1，多个线程在操作共享数据。\n2，有多条语句对共享数据进行运算。\n原因：这多条语句，在某一个时刻被一个线程执行时，还没有执行完，就被其他线程执行了。\n解决安全问题的原理：\n只要将操作共享数据的语句在某一时段让一个线程执行完，在执行过程中，其他线程不能进来执行就可以解决这个问题。\n如何进行多句操作共享数据代码的封装呢？\njava中提供了一个解决方式：就是同步代码块。\n格式：\nsynchronized(对象) { // 任意对象都可以。这个对象就是锁。\n   需要被同步的代码；//没有持有锁的进程，即使获取cpu的执行权，也进不去，因为没有获取锁。\n}                                 //案例：火车上的卫生间\n---------------------------------------------------------------\n同步：★★★★★\n好处：解决了线程安全问题。\n弊端：相对降低性能，因为判断锁需要消耗资源，产生了死锁。\n定义同步是有前提的：\n1，必须要有两个或者两个以上的线程，才需要同步。\n2，多个线程必须保证使用的是同一个锁。\n同步的第二种表现形式：\n同步函数：其实就是将同步关键字定义在函数上，让函数具备了同步性。\n同步函数是用的哪个锁呢？\n通过验证，函数都有自己所属的对象this，所以同步函数所使用的锁就是this锁。\n当同步函数被static修饰时，这时的同步用的是哪个锁呢？\n静态函数在加载时所属于类，这时有可能还没有该类产生的对象，但是该类的字节码文件加载进内存就已经被封装成了对象，这个对象就是该类的字节码文件对象。\n所以静态加载时，只有一个对象存在，那么静态同步函数就使用的这个对象。\n这个对象就是 类名.class\n同步代码块和同步函数的区别？\n同步代码块使用的锁可以是任意对象。\n同步函数使用的锁是this，静态同步函数的锁是该类的字节码文件对象。反射技术\n在一个类中只有一个同步，可以使用同步函数。如果有多同步，必须使用同步代码块，来确定不同的锁。所以同步代码块相对灵活一些。\n\n\n★考点问题：请写一个延迟加载的单例模式？写懒汉式；当出现多线程访问时怎么解决？加同步，解决安全问题；效率高吗？不高；怎样解决？通过双重判断的形式解决。\n//懒汉式：延迟加载方式。\n当多线程访问懒汉式时，因为懒汉式的方法内对共性数据进行多条语句的操作。所以容易出现线程安全问题。为了解决，加入同步机制，解决安全问题。但是却带来了效率降低。\n为了效率问题，通过双重判断的形式解决。\nclass Single{\n   private static Single s = null;\n   private Single(){}\n   public static Single getInstance(){ //锁是谁？字节码文件对象；\n       if(s == null){\n          synchronized(Single.class){\n             if(s == null)\n                 s = new Single();\n          }\n      }\n       return s;\n   }\n}\n\n\n同步死锁\n通常只要将同步进行嵌套，就可以看到现象。同步函数中有同步代码块，同步代码块中还有同步函数。\n线程间通信\n思路：多个线程在操作同一个资源，但是操作的动作却不一样。\n1：将资源封装成对象。\n2：将线程执行的任务(任务其实就是run方法。)也封装成对象。\n等待唤醒机制\n涉及的方法：（FIFO）\nwait:将同步中的线程处于冻结状态。释放了执行权，释放了资格。同时将线程对象存储到线程池中。\nnotify：唤醒线程池中某一个等待线程。\nnotifyAll:唤醒的是线程池中的所有线程。\n注意：\n1：这些方法都需要定义在同步中。\n2：因为这些方法必须要标示所属的锁。\n   你要知道 A锁上的线程被wait了,那这个线程就相当于处于A锁的线程池中，只能A锁的notify唤醒。\n3：这三个方法都定义在Object类中。为什么操作线程的方法定义在Object类中？\n   因为这三个方法都需要定义同步内，并标示所属的同步锁，既然被锁调用，而锁又可以是任意对象，那么能被任意对象调用的方法一定定义在Object类中。\nwait和sleep区别\n分析这两个方法：从执行权和锁上来分析：\nwait：可以指定时间也可以不指定时间。不指定时间，只能由对应的notify或者notifyAll来唤醒。\nsleep：必须指定时间，时间到自动从冻结状态转成运行状态(临时阻塞状态)。\nwait：线程会释放执行权，而且线程会释放锁。\nSleep：线程会释放执行权，但不是不释放锁。\n\n线程的停止\n通过stop方法就可以停止线程。但是这个方式过时了。\n停止线程：原理就是：让线程运行的代码结束，也就是结束run方法。\n怎么结束run方法？一般run方法里肯定定义循环。所以只要结束循环即可。\n第一种方式：定义循环的结束标记。\n第二种方式：如果线程处于了冻结状态，是不可能读到标记的，这时就需要通过Thread类中的interrupt方法，将其冻结状态强制清除。让线程恢复具备执行资格的状态，让线程可以读到标记，并结束。\n---------< java.lang.Thread >----------\ninterrupt()：中断线程。\nsetPriority(int newPriority)：更改线程的优先级。\ngetPriority()：返回线程的优先级。\ntoString()：返回该线程的字符串表示形式，包括线程名称、优先级和线程组。\nThread.yield()：暂停当前正在执行的线程对象，并执行其他线程。\nsetDaemon(true)：将该线程标记为守护线程或用户线程。将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。该方法必须在启动线程前调用。\njoin：临时加入一个线程的时候可以使用join方法。\n\n当A线程执行到了B线程的join方式。A线程处于冻结状态，释放了执行权，B开始执行。A什么时候执行呢？只有当B线程运行结束后，A才从冻结状态恢复运行状态执行。\n\n\nLock接口\n多线程在JDK1.5版本升级时，推出一个接口Lock接口。\n解决线程安全问题使用同步的形式，(同步代码块，要么同步函数)其实最终使用的都是锁机制。\n到了后期版本，直接将锁封装成了对象。线程进入同步就是具备了锁，执行完，离开同步，就是释放了锁。\n在后期对锁的分析过程中，发现，获取锁，或者释放锁的动作应该是锁这个事物更清楚。所以将这些动作定义在了锁当中，并把锁定义成对象。\n所以同步是隐示的锁操作，而Lock对象是显示的锁操作，它的出现就替代了同步。//一个锁可以有多个对象\n\n在之前的版本中使用Object类中wait、notify、notifyAll的方式来完成的。那是因为同步中的锁是任意对象，所以操作锁的等待唤醒的方法都定义在Object类中。\n\n而现在锁是指定对象Lock。所以查找等待唤醒机制方式需要通过Lock接口来完成。而Lock接口中并没有直接操作等待唤醒的方法，而是将这些方式又单独封装到了一个对象中。这个对象就是Condition，将Object中的三个方法进行单独的封装。并提供了功能一致的方法 await()、signal()、signalAll()体现新版本对象的好处。\n< java.util.concurrent.locks > Condition接口：await()、signal()、signalAll()；\nclass BoundedBuffer {\n  final Lock lock = new ReentrantLock();\n  final Condition notFull  = lock.newCondition();\n  final Condition notEmpty = lock.newCondition();\n  final Object[] items = new Object[100];\n  int putptr, takeptr, count;\n  public void put(Object x) throws InterruptedException {\n    lock.lock();\n    try {\n      while (count == items.length)\n        notFull.await();\n      items[putptr] = x;\n      if (++putptr == items.length) putptr = 0;\n      ++count;\n      notEmpty.signal();//本方只唤醒对方\n    }\n   finally {\n      lock.unlock();\n    }\n  }\n  public Object take() throws InterruptedException {\n    lock.lock();\n    try {\n      while (count == 0)\n        notEmpty.await();\n      Object x = items[takeptr];\n      if (++takeptr == items.length) takeptr = 0;\n      --count;\n      notFull.signal();\n      return x;\n    }\nfinally {\n      lock.unlock();\n    }\n  }\n}\n\n\nAPI\n（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件的以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。\n--< java.lang >-- String字符串：★★★☆\njava中用String类进行描述。对字符串进行了对象的封装。这样的好处是可以对字符串这种常见数据进行方便的操作。对象封装后，可以定义N多属性和行为。\n如何定义字符串对象呢？String s = \"abc\";只要是双引号引起的数据都是字符串对象。\n特点：字符串一旦被初始化，就不可以被改变，存放在方法区中的常量池中。\nString s1 = \"abc\"; // s1指向的内存中只有一个对象abc。\nString s2 = new String(\"abc\"); // s2指向的内容中有两个对象abc、new 。\nSystem.out.println(s1==s2);//false ==比较的是地址值\nSystem.out.println(s1.equals(s2));//true ，字符串中equals比较的是字符串内容是否相同。\n\n\n而在Object中，equals比较的是两个对象的地址值，是否为相同。\n查API。\n\n字符串的方法：\n1：构造方法：将字节数组或者字符数组转成字符串。\nString s1 = new String();//创建了一个空内容的字符串。\nString s2 = null;//s2没有任何对象指向，是一个null常量值。\nString s3 = \"\";//s3指向一个具体的字符串对象，只不过这个字符串中没有内容。\n//一般在定义字符串时，不用new。会产生两个对象\nString s4 = new String(\"abc\");\nString s5 = \"abc\"; 一般用此写法\nnew String(char[]);//将字符数组转成字符串。\nnew String(char[],offset,count);//将字符数组中的一部分转成字符串。\n\n\n2：一般方法：\n   按照面向对象的思想：\n2.1 获取：\n   2.1.1：获取字符串的长度。length();//不包括\\n\n   2.1.2：指定位置的字符。char charAt(int index);//当访问到字符串中不存在的角标时会抛出StringIndexOutOfBandsException.\n   2.1.3：获取指定字符的位置。如果不存在返回-1，所以可以通过返回值-1来判断某一个字符不存在的情况。\n           int indexOf(int ch);//返回第一次找到的字符角标//从零开始\n           int indexOf(int ch,int fromIndex); //返回从指定位置开始第一次找到的角标\n           int indexOf(String str); //返回第一次找到的字符串角标\n           int indexOf(String str,int fromIndex);\n           int lastIndexOf(int ch);//由该对象表示的字符序列中的最后一次出现的索引，如果该字符不发生，-1 。\n           int lastIndexOf(int ch,int fromIndex);\n           int lastIndexOf(String str);\n           int lastIndexOf(String str,int fromIndex);\n   2.1.4：获取子串。\n           String substring(int start);//从start位开始，到length()-1为止.\n           String substring(int start,int end);//从start开始到end为止。//包含start位，不包含end位。\n           substring(0,str.length());//获取整串\n2.2 判断：\n   2.2.1：字符串中包含指定的字符串吗？\n           boolean contains(String substring);\n            indexOf(str) 也可以\n   2.2.2：字符串是否以指定字符串开头啊？\n           boolean startsWith(string);\n   2.2.3：字符串是否以指定字符串结尾啊？\n           boolean endsWith(string);\n   2.2.4：判断字符串是否相同\n           boolean equals(string);//覆盖了Object中的方法，判断字符串内容是否相同。\n   2.2.5：判断字符串内容是否相同，忽略大小写。\n           boolean equalsIgnoreCase(string) ;\n2.3 转换：\n   2.3.1：通过构造函数可以将字符数组或者字节数组转成字符串。\nnew String(char[]);//将字符数组转成字符串。\nnew String(char[],offset,count);//将字符数组中的一部分转成字符串。\n   2.3.2：可以通过字符串中的静态方法，将字符数组转成字符串。\n           static String copyValueOf(char[] );//字符串数组的后续修改不会影响返回的字符串\n           static String copyValueOf(char[],int offset,int count);\n           static String valueOf(char[]);\n           static String valueOf(char[],int offset,int count);\n   2.3.3：将基本数据类型或者对象转成字符串。\n           static String valueOf(char);\n           static String valueOf(boolean);\n           static String valueOf(double);\n           static String valueOf(float);\n           static String valueOf(int);\n           static String valueOf(long);\n           static String valueOf(Object);\n   2.3.4：将字符串转成大小写。\n           String toLowerCase();\n           String toUpperCase();\n   2.3.5：将字符串转成数组。\n           char[] toCharArray();//转成字符数组。\n           byte[] getBytes();//可以加入编码表。转成字节数组。\n   2.3.6：将字符串转成字符串数组。切割方法。\n           String[] split(分割的规则-字符串);//若切割符未找到则返回原串\n   2.3.7：将字符串进行内容替换。注意：修改后变成新字符串，并不是将原字符串直接修改。\n           String replace(oldChar,newChar);将符合的字符全部替换为新字符//若不存在则返回原串\n           String replace(oldstring,newstring);\n            * 注意与replaceAll：用给定的替换替换与给定的 regular expression匹配的此字符串的每个子字符串。\n\n   2.3.8： String concat(string); //对字符串进行追加。\n           String trim();//去除字符串两端的空格\n    int compareTo();//如果参数字符串等于此字符串，则返回值 0；如果此字符串按字典顺序小于字符串参数，则返回一个小于 0 （即不一定返回-1）的值；如果此字符串按字典顺序大于字符串参数，则返回一个大于 0（不一定为1） 的值。\n\n\n--< java.lang >-- StringBuffer字符串缓冲区：★★★☆\n构造一个其中不带字符的字符串缓冲区，初始容量为 16 个字符。\n特点：\n1：可以对字符串内容进行修改。\n2：是一个容器。\n3：是可变长度的。\n4：缓冲区中可以存储任意类型的数据。\n5：最终需要变成字符串。\n容器通常具备一些固定的方法：\n1，添加。\n   StringBuffer append(data):在缓冲区中追加数据。追加到尾部。\n   StringBuffer insert(index,data):在指定位置插入数据。//角标越界\n2，删除。\n   StringBuffer delete(start,end);删除从start至end-1范围的元素\n   StringBuffer deleteCharAt(index);删除指定位置的元素\n//sb.delete(0,sb.length());//清空缓冲区。\n3，修改。\n   StringBuffer replace(start,end,string);将start至end-1替换成string\n   void setCharAt(index,char);替换指定位置的字符\n   void setLength(len);将原字符串置为指定长度的字符串\n4，查找。（查不到返回-1）\n   int indexOf(string); 返回指定子字符串在此字符串中第一次出现处的索引。\n   int indexOf(string,int fromIndex);从指定位置开始查找字符串\n   int lastIndexOf(string); 返回指定子字符串在此字符串中最右边出现处的索引。\n   int lastIndexOf(string,int fromIndex); 从指定的索引开始反向搜索\n5，获取子串。\n   string substring(start); 返回start到结尾的子串\n   string substring(start,end); 返回start至end-1的子串\n6，反转。\n   StringBuffer reverse();字符串反转\n\n\n--< java.lang >-- StringBuilder字符串缓冲区：★★★☆//建议使用\nJDK1.5出现StringBuiler；构造一个其中不带字符的字符串生成器，初始容量为 16 个字符。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。\n方法和StringBuffer一样；\nStringBuffer 和 StringBuilder 的区别：\nStringBuffer线程安全。导致效率变慢\nStringBuilder线程不安全。\n单线程操作，使用StringBuilder 效率高。\n多线程操作，使用StringBuffer 安全。\n       StringBuilder sb = new StringBuilder(\"abcdefg\");\n       sb.append(\"ak\");  //abcdefgak\n       sb.insert(1,\"et\");//aetbcdefg\n       sb.deleteCharAt(2);//abdefg\n       sb.delete(2,4);//abefg\n       sb.setLength(4);//abcd\n       sb.setCharAt(0,'k');//kbcdefg\n       sb.replace(0,2,\"hhhh\");//hhhhcdefg\n       \n//想要使用缓冲区，先要建立对象。\n       StringBuffer sb = new StringBuffer();      \n       sb.append(12).append(\"haha\");//方法调用链。\n       String s = \"abc\"+4+'q';\n       s = new StringBuffer().append(\"abc\").append(4).append('q').toString();\n---------------------------------------------------------\nclass  Test{\n   public static void main(String[] args) {\n       String s1 = \"java\";\n       String s2 = \"hello\";\n       method_1(s1,s2);\n       System.out.println(s1+\"....\"+s2); //java....hello\n       \n       StringBuilder s11 = new StringBuilder(\"java\");\n       StringBuilder s22 = new StringBuilder(\"hello\");\n       method_2(s11,s22);\n       System.out.println(s11+\"-----\"+s22); //javahello-----hello\n   }\n   public static void method_1(String s1,String s2){\n       s1.replace('a','k');\n       s1 = s2;\n   }\n   public static void method_2(StringBuilder s1,StringBuilder s2){\n       s1.append(s2);\n       s1 = s2;\n   }\n}\n\n\n基本数据类型对象包装类\n是按照面向对象思想将基本数据类型封装成了对象。\n好处：\n1：可以通过对象中的属性和行为操作基本数据。\n2：可以实现基本数据类型和字符串之间的转换。\n关键字   对应的类名\nbyte    Byte\nshort   Short     paserShort(numstring);\nint     Integer   静态方法：parseInt(numstring)\nlong    Long\nfloat   Float\ndouble    Double\nchar   Character\nBoolean   Boolean\n基本数据类型对象包装类：都有 XXX parseXXX 方法\n只有一个类型没有parse方法：Character ；\n\n\nInteger对象： ★★★☆\n数字格式的字符串转成基本数据类型的方法：\n1：将该字符串封装成了Integer对象，并调用对象的方法intValue();\n2：使用Integer.parseInt(numstring):不用建立对象，直接类名调用；\n将基本类型转成字符串：\n1：Integer中的静态方法 String toString(int);\n2：int+\"\";\n将一个十进制整数转成其他进制：\n   转成二进制：toBinaryString\n   转成八进制：toOctalString\n   转成十六进制：toHexString\n   toString(int num,int radix);\n将其他进制转换十进制：\nparseInt(string,radix); //将给定的数转成指定的基数进制；\n在jdk1.5版本后，对基本数据类型对象包装类进行升级。在升级中，使用基本数据类型对象包装类可以像使用基本数据类型一样，进行运算。\n   Integer i = new Integer(4); //1.5版本之前的写法；\n   Integer i = 4; //自动装箱，1.5版本后的写法；\n   i = i + 5;\n   //i对象是不能直接和5相加的，其实底层先将i转成int类型，在和5相加。而转成int类型的操作是隐式的。自动拆箱：拆箱的原理就是i.intValue();i+5运算完是一个int整数。如何赋值给引用类型i呢？其实有对结果进行装箱。\nInteger c = 127;\n   Integer d = 127;\n   System.out.println(c = = d); //true\n   //在装箱时，如果数值在byte范围之内，那么数值相同，不会产生新的对象，也就是说多个数值相同的引用指向的是同一个对象。\n集合框架：★★★★★，用于存储数据的容器。\n特点：\n1：对象封装数据，对象多了也需要存储。集合用于存储对象。\n2：对象的个数确定可以使用数组，但是不确定怎么办？可以用集合。因为集合是可变长度的。\n集合和数组的区别：\n1：数组是固定长度的；集合可变长度的。\n2：数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。\n3：数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。\n数据结构：就是容器中存储数据的方式。\n对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。\n集合容器在不断向上抽取过程中。出现了集合体系。\n在使用一个体系时，原则：参阅顶层内容。建立底层对象。\n\n\n--< java.util >-- Collection接口：\nCollection：若直接打印集合，则将集合中的对象封装到[]中打印出来。\n   |--List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。\n   |--Set：无序(存入和取出顺序有可能不一致)，不可以存储重复元素。必须保证元素唯一性。\n1，添加：\n   add(object)：添加一个元素//Object：以便接收任意类型对象\n   addAll(Collection) ：添加一个集合中的所有元素。\n2，删除：\n   clear()：将集合中的元素全删除，清空集合。\n   remove(obj) ：删除集合中指定的对象。注意：删除成功，集合的长度会改变。\n   removeAll(collection) ：删除部分元素。部分元素和传入Collection一致。\n3，判断：\n   boolean contains(obj) ：集合中是否包含指定元素 。\n   boolean containsAll(Collection) ：集合中是否包含指定的多个元素。\n   boolean isEmpty()：集合中是否有元素。\n4，获取：\n   int size()：集合中有几个元素。\n5，取交集：\n   boolean  retainAll(Collection) ：对当前集合中保留和指定集合中的相同的元素。如果两个集合元素相同，返回flase；如果retainAll修改了当前集合，返回true。//c1.retainAll(c2),c1集合的内容会变成c1和c2元素的交集\n6，获取集合中所有元素：\n   Iterator  iterator()：迭代器\n7，将集合变成数组：\n   toArray();\n--< java.util >-- Iterator接口：\n迭代器：是一个接口。作用：用于取集合中的元素。\n\nboolean\nhasNext() 如果仍有元素可以迭代，则返回 true。\nE\nnext()  返回迭代的下一个元素。\nvoid\nremove() 从迭代器指向的 collection 中移除迭代器返回的最后一个元素（可选操作）。\n迭代完成后若要重新使用需要显示指回.iterator()\n每一个集合都有自己的数据结构，都有特定的取出自己内部元素的方式。为了便于操作所有的容器，取出元素。将容器内部的取出方式按照一个统一的规则向外提供，这个规则就是Iterator接口。\n也就说，只要通过该接口就可以取出Collection集合中的元素，至于每一个具体的容器依据自己的数据结构，如何实现的具体取出细节，这个不用关心，这样就降低了取出元素和具体集合的耦合性。\nIterator it = coll.iterator();//获取容器中的迭代器对象，至于这个对象是是什么不重要。这对象肯定符合一个规则Iterator接口。\npublic static void main(String[] args) {\n       Collection coll = new ArrayList();\n       coll.add(\"abc0\");\n       coll.add(\"abc1\");\n       coll.add(\"abc2\");\n       //--------------方式1----------------------\n       Iterator it = coll.iterator();\n       while(it.hasNext()){\n           System.out.println(it.next());\n       }\n       //---------------方式2用此种----------------------\n       for(Iterator it = coll.iterator();it.hasNext(); ){//for循环结束会释放it\n           System.out.println(it.next());\n       }\n   }\n\n\n--< java.util >-- List接口：\nList本身是Collection接口的子接口，具备了Collection的所有方法。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。\nList：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。\n   |--ArrayList：底层的数据结构是数组,线程不同步，ArrayList替代了Vector，查询元素的速度非常快。\n   |--LinkedList：底层的数据结构是链表，线程不同步，增删元素的速度非常快。\n   |--Vector：底层的数据结构就是数组，线程同步的，Vector无论查询和增删都巨慢。\n1，添加：\n   add(index,element) ：在指定的索引位插入元素。\n   addAll(index,collection) ：在指定的索引位插入一堆元素。\n2，删除：\n   remove(index) ：删除指定索引位的元素。 返回被删的元素。  \n3，获取：\n   Object get(index) ：通过索引获取指定元素。\n   int indexOf(obj) ：获取指定元素第一次出现的索引位，如果该元素不存在返回-1；\n                    所以，通过-1，可以判断一个元素是否存在。\n   int lastIndexOf(Object o) ：反向索引指定元素的位置。\n   List subList(start,end) ：获取子列表。\n4，修改：\n   Object set(index,element) ：对指定索引位进行元素的修改。\n5，获取所有元素：\n   ListIterator listIterator()：list集合特有的迭代器。\nList集合支持对元素的增、删、改、查。\nList集合因为角标有了自己的获取元素的方式： 遍历。\nfor(int x=0; x<list.size(); x++){\n sop(\"get:\"+list.get(x));\n}\n在进行list列表元素迭代的时候，如果想要在迭代过程中，想要对元素进行操作的时候，比如满足条件添加新元素。会发生.ConcurrentModificationException并发修改异常。\n导致的原因是：\n集合引用和迭代器引用在同时操作元素，通过集合获取到对应的迭代器后，在迭代中，进行集合引用的元素添加，迭代器并不知道，所以会出现异常情况。\n如何解决呢？\n既然是在迭代中对元素进行操作,找迭代器的方法最为合适.可是Iterator中只有hasNext,next,remove方法.通过查阅的它的子接口,ListIterator,发现该列表迭代器接口具备了对元素的增、删、改、查的动作。\nListIterator是List集合特有的迭代器。\nListIterator it = list.listIterator;//取代Iterator it = list.iterator;\n\n方法摘要\nvoid\nadd( e) 将指定的元素插入列表（可选操作）。\nboolean\nhasNext() 以正向遍历列表时，如果列表迭代器有多个元素，则返回 true（换句话说，如果 next 返回一个元素而不是抛出异常，则返回 true）。\nboolean\nhasPrevious() 如果以逆向遍历列表，列表迭代器有多个元素，则返回 true。\nE\nnext() 返回列表中的下一个元素。\nint\nnextIndex() 返回对 next 的后续调用所返回元素的索引。\nE\nprevious() 返回列表中的前一个元素。\nint\npreviousIndex() 返回对 previous 的后续调用所返回元素的索引。\nvoid\nremove() 从列表中移除由 next 或 previous 返回的最后一个元素（可选操作）。\nvoid\nset(E e) 用指定元素替换 next 或 previous 返回的最后一个元素（可选操作）。\n\n可变长度数组的原理：\n当元素超出数组长度，会产生一个新数组，将原数组的数据复制到新数组中，再将新的元素添加到新数组中。\nArrayList：是按照原数组的50%延长。构造一个初始容量为 10 的空列表。\nVector：是按照原数组的100%延长。\n注意：对于list集合，底层判断元素是否相同，其实用的是元素自身的equals方法完成的。所以建议元素都要复写equals方法，建立元素对象自己的比较相同的条件依据。\nLinkedList：的特有方法。\n      addFirst();\n      addLast();\n在jdk1.6以后。\n      offerFirst();\n      offerLast();\n      getFirst():获取链表中的第一个元素。如果链表为空，抛出NoSuchElementException;\n      getLast();\n在jdk1.6以后均不会抛异常\n      peekFirst();获取链表中的第一个元素。如果链表为空，返回null。\n      peekLast();\n      removeFirst()：获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，抛出NoSuchElementException\n      removeLast();\n在jdk1.6以后。\n      pollFirst();获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，返回null。\n      pollLast();\n\n\n--< java.util >-- Set接口：Set中的元素不能重复\nSet接口中的方法和Collection中方法一致的。Set接口取出方式只有一种，迭代器。Set不提供get来获取位置的元素，所以遍历需要用到迭代器，或者增强型for循环。\n |--HashSet：底层数据结构是哈希表，线程是不同步的。无序，高效；\n     HashSet集合保证元素唯一性：通过元素的hashCode方法，和equals方法完成的。\n     当元素的hashCode值相同时，才继续判断元素的equals是否为true。\n     如果为true，那么视为相同元素，不存。如果为false，那么存储。\n     如果hashCode值不同，那么不判断equals，从而提高对象比较的速度。\n    |--LinkedHashSet：有序，hashset的子类。\n |--TreeSet：对Set集合中的元素的进行指定顺序的排序。不同步。TreeSet底层的数据结构就是二叉树。\n哈希表的原理：\n1，对对象元素中的关键字(对象中的特有数据)，进行哈希算法的运算，并得出一个具体的算法值，这个值 称为哈希值。\n2，哈希值就是这个元素的位置。\n3，如果哈希值出现冲突，再次判断这个关键字对应的对象是否相同。如果对象相同，就不存储，因为元素重复。如果对象不同，就存储，在原来对象的哈希值基础 +1顺延。\n4，存储哈希值的结构，我们称为哈希表。\n5，既然哈希表是根据哈希值存储的，为了提高效率，最好保证对象的关键字是唯一的。\n 这样可以尽量少的判断关键字对应的对象是否相同，提高了哈希表的操作效率。\n对于ArrayList集合，判断元素是否存在，或者删元素底层依据都是equals方法。\n对于HashSet集合，判断元素是否存在，或者删除元素，底层依据的是hashCode方法和equals方法。\nTreeSet:\n 用于对Set集合进行元素的指定顺序排序，排序需要依据元素自身具备的比较性。\n 如果元素不具备比较性，在运行时会发生ClassCastException异常。\n 所以需要元素实现Comparable接口，强制让元素具备比较性，复写compareTo方法。\n 依据compareTo方法的返回值，确定元素在TreeSet数据结构中的位置。\n TreeSet方法保证元素唯一性的方式：就是参考比较方法的结果是否为0，如果return 0，视为两个对象重复，不存。\n注意：在进行比较时，如果判断元素不唯一，比如，同姓名，同年龄，才视为同一个人。\n 在判断时，需要分主要条件和次要条件，当主要条件相同时，再判断次要条件，按照次要条件排序。\nTreeSet集合排序有两种方式，Comparable和Comparator区别：\n1：让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法。\n2：让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数。\n第二种方式较为灵活。\n用作键的对象必须实现HashCode的方法和equals方法\n\n\nMap集合\n当数据之间存在映射关系时，就要先想到Map集合\n|--Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。\n|--HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键（可为key或value的值），null值。替代了Hashtable.\n|--TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。线程不同步。\nMap集合存储和Collection有着很大不同：\nCollection一次存一个元素；Map一次存一对元素。\nCollection是单列集合；Map是双列集合。\nMap中的存储的一对元素：一个是键，一个是值，键与值之间有对应(映射)关系。\n特点：要保证map集合中键的唯一性。\n1，添加。\nput(key,value)：当存储的键相同时，新的值会替换老的值，若重复，则并将老值返回。如果键没有重复，返回null。\n void putAll(Map);\n2，删除。\n void clear()：清空\n value remove(key) ：删除指定键。将值返回。\n3，判断。\n boolean isEmpty()：\n boolean containsKey(key)：是否包含key\n boolean containsValue(value) ：是否包含value\n4，取出。\n int size()：返回长度\n value get(key) ：通过指定键获取对应的值。如果返回null，可以判断该键不存在。当然有特殊情况，就是在hashmap集合中，是可以存储null键null值的。并不删除元素\n Collection values()：获取map集合中的所有的值。\n5，想要获取map中的所有元素：\n 原理：map中是没有迭代器的，collection具备迭代器，只要将map集合转成Set集合，可以使用迭代器了。之所以转成set，是因为map集合具备着键的唯一性，其实set集合就来自于map，set集合底层其实用的就是map的方法。\n把map集合转成set的方法：\nSet keySet();\nSet entrySet();//取的是键和值的映射关系。\nEntry就是Map接口中的内部接口；\n为什么要定义在map内部呢？entry是访问键值关系的入口，是map的入口，访问的是map中的键值对。\n\n访问map集合中所有元素\n取出map集合中所有元素的方式一：keySet()方法。\n可以将map集合中的键都取出存放到set集合中。对set集合进行迭代。迭代完成，再通过get方法对获取到的键进行值的获取。\n     Set keySet = map.keySet();\n     Iterator it = keySet.iterator();\n    while(it.hasNext()) {\n        Object key = it.next();\n        Object value = map.get(key);\n        System.out.println(key+\":\"+value);\n    }\n--------------------------------------------------------\n取出map集合中所有元素的方式二：entrySet()方法。\n    Entry是Map接口中的一个内部接口。\n    entrySet将map集合中的映射关系去除，这个关系为Map.Entry类型。可直接用Map.Entry中getKey和getValue方法获取关系中的键和值.\n         //推荐，尤其是容量大时\n          System.out.println(\"通过Map.entrySet遍历key和value\");\n          for (Map.Entry<String, String> entry : map.entrySet()) {\n           System.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue());\n          }\n\n\n有关于 map.entrySet() 和 keySet():\n1、如果遍历 hashMap() 时 entrySet() 方法是将 key 和 value 全部取出来,所以性能开销是可以预计的, 而 keySet() 方法进行遍历的时候是根据取出的 key 值去查询对应的 value 值, 所以如果 key 值是比较简单的结构(如 1,2,3...)的话性能消耗上是比 entrySet() 方法低, 但随着 key 值得复杂度提高 entrySet() 的优势就会显露出来。\n2、综合比较在只遍历 key 的时候使用 keySet(), 在只遍历 value 的是使用 values() 方法, 在遍历 key-value 的时候使用 entrySet() 是比较合理的选择。\n3、如果遍历 TreeMap 的时候, 不同于 HashMap 在遍历 ThreeMap 的 key-value 时候务必使用 entrySet() 它要远远高于其他两个的性能, 同样只遍历 key 的时候使用 keySet(), 在只遍历 value 的是使用 values() 方法对于 TreeMap 也同样适用。\nSet entrySet = map.entrySet();\n       Iterator it = entrySet.iterator();\n       while(it.hasNext()) {\n           Map.Entry  me = (Map.Entry)it.next();\n           System.out.println(me.getKey()+\"::::\"+me.getValue());\n       }\n\n\n使用集合的技巧：\n看到Array就是数组结构，有角标，查询速度很快。\n看到link就是链表结构：增删速度快，而且有特有方法。addFirst； addLast； removeFirst()； removeLast()； getFirst()；getLast()；\n看到hash就是哈希表，就要想要哈希值，就要想到唯一性，就要想到存入到该结构的中的元素必须覆盖hashCode，equals方法。\n看到tree就是二叉树，就要想到排序，就想要用到比较。\n比较的两种方式：\n一个是Comparable：覆盖compareTo方法；\n一个是Comparator：覆盖compare方法。\nLinkedHashSet，LinkedHashMap:这两个集合可以保证哈希表有存入顺序和取出顺序一致，保证哈希表有序。\n集合什么时候用？\n当存储的是一个元素时，就用Collection。当存储对象之间存在着映射关系时，就使用Map集合。\n保证唯一，就用Set。不保证唯一，就用List。\n\n\nCollections：它的出现给集合操作提供了更多的功能。这个类不需要创建对象，内部提供的都是静态方法。\n静态方法：\nCollections.sort(list);//list集合进行元素的自然顺序排序。\nCollections.sort(list,new ComparatorByLen());//按指定的比较器方法排序。\nclass ComparatorByLen implements Comparator<String>{\n public int compare(String s1,String s2){\n     int temp = s1.length()-s2.length();\n     return temp==0?s1.compareTo(s2):temp;\n }\n}\nCollections.max(list); //返回list中字典顺序最大的元素。\nint index = Collections.binarySearch(list,\"zz\");//二分查找，返回角标。\nCollections.reverseOrder();//逆向反转排序。返回一个比较器,他强行逆转实现了Comparable接口的对象collection的自然顺序.\nCollections.shuffle(list);//如扑克牌洗牌,随机对list中的元素进行位置的置换。\n将非同步集合转成同步集合的方法：Collections中的 XXX synchronizedXXX(XXX);\nList synchronizedList(list);\nMap synchronizedMap(map);\n原理：定义一个类，将集合所有的方法加同一把锁后返回。\nCollection 和 Collections的区别：\nCollections是个java.util下的类，是针对集合类的一个工具类,提供一系列静态方法,实现对集合的查找、排序、替换、线程安全化（将非同步的集合转换成同步的）等操作。\nCollection是个java.util下的接口，它是各种集合结构的父接口，继承于它的接口主要有Set和List,提供了关于集合的一些操作,如插入、删除、判断一个元素是否其成员、遍历等。\n\n\nArrays：\n用于操作数组对象的工具类，里面都是静态方法。\nasList方法：将数组转换成list集合。\nString[] arr = {\"abc\",\"kk\",\"qq\"};\nList<String> list = Arrays.asList(arr);//将arr数组转成list集合。\n将数组转换成集合，有什么好处呢？用aslist方法，将数组变成集合；\n可以通过list集合中的方法来操作数组中的元素：isEmpty()、contains、indexOf、set；\n注意（局限性）：数组是固定长度，不可以使用集合对象增加或者删除等，会改变数组长度的功能方法。比如add、remove、clear。（会报不支持操作异常UnsupportedOperationException）；\n如果数组中存储的引用数据类型，直接作为集合的元素可以直接用集合方法操作。\n如果数组中存储的是基本数据类型，asList会将数组实体作为集合元素存在。\n集合变数组：用的是Collection接口中的方法：toArray();\n如果给toArray传递的指定类型的数据长度小于了集合的size，那么toArray方法，会自动再创建一个该类型的数据，长度为集合的size。\n   如果传递的指定的类型的数组的长度大于了集合的size，那么toArray方法，就不会创建新数组，直接使用该数组即可，并将集合中的元素存储到数组中，其他为存储元素的位置默认值null。\n   所以，在传递指定类型数组时，最好的方式就是指定的长度和size相等的数组。\n将集合变成数组后有什么好处？限定了对集合中的元素进行增删操作，只要获取这些元素即可。\n\n\nJdk5.0新特性：\nCollection在jdk1.5以后，有了一个父接口Iterable，这个接口的出现的将iterator方法进行抽取，提高了扩展性。\n\n增强for循环：foreach语句，foreach简化了迭代器。底层原理仍是迭代器,不可修改元素.\n格式：// 增强for循环括号里写两个参数，第一个是声明一个变量，第二个就是需要迭代的容器\nfor( 元素类型 变量名 : Collection集合 & 数组 ) {\n …\n}\n高级for循环和传统for循环的区别：\n高级for循环在使用时，必须要明确被遍历的目标。这个目标，可以是Collection集合或者数组，如果遍历Collection集合，在遍历过程中还需要对元素进行操作，比如删除，需要使用迭代器。\n如果遍历数组，还需要对数组元素进行操作，建议用传统for循环因为可以定义角标通过角标操作元素。如果只为遍历获取，可以简化成高级for循环，它的出现为了简化书写。\n\n高级for循环可以遍历map集合吗\n不可以。(map集合无迭代器)但是可以将map转成set后再使用foreach语句。\n1)、作用：对存储对象的容器进行迭代： 数组  collection   map\n2)、增强for循环迭代数组：\nString [] arr = {\"a\", \"b\", \"c\"};//数组的静态定义方式，只试用于数组首次定义的时候\nfor(String s : arr) {\n System.out.println(s);\n}\n3)、单列集合 Collection：\nList list = new ArrayList();\nlist.add(\"aaa\");\n// 增强for循环, 没有使用泛型的集合能不能使用增强for循环迭代？能\nfor(Object obj : list) {\n String s = (String) obj;\n System.out.println(s);\n}\n4)、双列集合 Map：\nMap map = new HashMap();\nmap.put(\"a\", \"aaa\");\n// 传统方式：必须掌握这种方式\nSet entrys = map.entrySet(); // 1.获得所有的键值对Entry对象\niter = entrys.iterator(); // 2.迭代出所有的entry\nwhile(iter.hasNext()) {\n Map.Entry entry = (Entry) iter.next();\n String key = (String) entry.getKey(); // 分别获得key和value\n String value = (String) entry.getValue();\n System.out.println(key + \"=\" + value);\n}\n// 增强for循环迭代：原则上map集合是无法使用增强for循环来迭代的，因为增强for循环只能针对实现了Iterable接口的集合进行迭代；Iterable是jdk5中新定义的接口，就一个方法iterator方法，只有实现了Iterable接口的类，才能保证一定有iterator方法，java有这样的限定是因为增强for循环内部还是用迭代器实现的，而实际上，我们可以通过某种方式来使用增强for循环。\nfor(Object obj : map.entrySet()) {\n Map.Entry entry = (Entry) obj; // obj 依次表示Entry\n System.out.println(entry.getKey() + \"=\" + entry.getValue());\n}\n5）、集合迭代注意问题：在迭代集合的过程中，不能对集合进行增删操作（会报并发访问异常）；可以用迭代器的方法进行操作（子类listIterator：有增删的方法）。\n6)、增强for循环注意问题：在使用增强for循环时，不能对元素进行赋值；\nint[] arr = {1,2,3};\nfor(int num : arr) {\n num = 0; //不能改变数组的值\n}\nSystem.out.println(arr[1]); //2\n\n\n可变参数（...）\n用到函数的参数上，当要操作的同一个类型元素个数不确定的时候，可是用这个方式，这个参数可以接受任意个数的同一类型的数据。\n和以前接收数组不一样的是：\n以前定义数组类型，需要先创建一个数组对象，再将这个数组对象作为参数传递给函数。现在，直接将数组中的元素作为参数传递即可。底层其实是将这些元素进行数组的封装，而这个封装动作，是在底层完成的，被隐藏了。所以简化了用户的书写，少了调用者定义数组的动作。\n如果在参数列表中使用了可变参数，可变参数必须定义在参数列表结尾(也就是必须是最后一个参数，否则编译会失败。)。\n如果要获取多个int数的和呢？可以使用将多个int数封装到数组中，直接对数组求和即可。\n\n\n静态导入：导入了类中的所有静态成员，简化静态成员的书写。连类名都省略,直接写方法\nimport static java.util.Collections.*;  //导入了Collections类中的所有静态成员\n\n\n枚举：关键字 enum\n问题：对象的某个属性的值不能是任意的，必须为固定的一组取值其中的某一个；\n解决办法：\n1）、在setGrade方法中做判断，不符合格式要求就抛出异常；\n2）、直接限定用户的选择，通过自定义类模拟枚举的方式来限定用户的输入，写一个Grade类，私有构造函数，对外提供5个静态的常量表示类的实例；\n3)、jdk5中新定义了枚举类型，专门用于解决此类问题；\n4)、枚举就是一个特殊的java类，可以定义属性、方法、构造函数、实现接口、继承类；\n\n\n自动拆装箱\njava中数据类型分为两种 ： 基本数据类型   引用数据类型(对象)\n在 java程序中所有的数据都需要当做对象来处理，针对8种基本数据类型提供了包装类，如下：\nint --> Integer\nbyte --> Byte\nshort --> Short\nlong --> Long\nchar --> Character\ndouble --> Double\nfloat --> Float\nboolean --> Boolean\njdk5以前基本数据类型和包装类之间需要互转：\n基本---引用   Integer x = new Integer(x);\n引用---基本   int num = x.intValue();\n1)、Integer x = 1; x = x + 1; 经历了什么过程？装箱 à 拆箱 à 装箱；\n2)、为了优化，虚拟机为包装类提供了缓冲池，Integer池的大小 -128~127 一个字节的大小；\n3)、String池：Java为了优化字符串操作 提供了一个缓冲池；\n面向对象中,子类转父类是一定可以成功的,但泛型中:子类泛型不可以转换为父类泛型.\n泛型\njdk1.5版本以后出现的一个安全机制。表现格式：< >\n好处：\n1：将运行时期的问题ClassCastException问题转换成了编译失败，体现在编译时期，程序员就可以解决问题。\n2：避免了强制转换的麻烦。\n只要带有<>的类或者接口，都属于带有类型参数的类或者接口，在使用这些类或者接口时，必须给<>中传递一个具体的引用数据类型。\n泛型技术：其实应用在编译时期，是给编译器使用的技术，到了运行时期，泛型就不存在了。\n为什么? 因为泛型的擦除：也就是说，编辑器检查了泛型的类型正确后，在生成的类文件中是没有泛型的。\n在运行时，如何知道获取的元素类型而不用强转呢？\n泛型的补偿：因为存储的时候，类型已经确定了是同一个类型的元素，所以在运行时，只要获取到该元素的类型，在内部进行一次转换即可，所以使用者不用再做转换动作了。\n什么时候用泛型类呢？泛型在集合框架中很常见\n当类中的操作的引用数据类型不确定的时候，以前用的Object来进行扩展的，现在可以用泛型来表示。这样可以避免强转的麻烦，而且将运行问题转移到的编译时期。\n----------------------------------------------------------\n泛型在程序定义上的体现：\n//泛型类：将泛型定义在类上。\nclass Tool<Q> {\n   private Q obj;\n   public  void setObject(Q obj) {\n       this.obj = obj;\n   }\n   public Q getObject() {\n       return obj;\n   }\n}\n//当方法操作的引用数据类型不确定的时候，可以将泛型定义在方法上。位置在返回值类型的前面,修饰符类型的后面.\n泛型类定义的泛型在整个类中有效\n当类被确定下来后,其引用数据类型也被确定,故要使用其他类型则需新建泛型类对象.也可将泛型定义在方法上.\n   public <W> void method(W w) {\n       System.out.println(\"method:\"+w);\n   }\n//静态方法上的泛型：静态方法无法访问类上定义的泛型。如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。\n   public static <Q> void function(Q t) {//注意位置\n       System.out.println(\"function:\"+t);\n   }\n//泛型接口.\ninterface Inter<T> {\n   void show(T t);\n}\nclass InterImpl<R> implements Inter<R> {//该情况为该类也不确定类型时使用\n   public void show(R r) {\n       System.out.println(\"show:\"+r);\n   }\n}\n\n\n泛型中的通配符\n可以解决当具体类型不确定的时候，这个通配符就是 ?  ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。用T,则可以对类型进行操作.\n泛型限定：\n   上限：？extends E：可以接收E类型或者E的子类型对象。\n   下限：？super E：可以接收E类型或者E的父类型对象。\n上限什么时候用：往集合中添加元素时，既可以添加E类型对象，又可以添加E的子类型对象。为什么？因为取的时候，E类型既可以接收E类对象，又可以接收E的子类型对象。\n下限什么时候用：当从集合中获取元素进行操作的时候，可以用当前元素的类型接收，也可以用当前元素的父类型接收。\n\n总结: 如果希望只取出,不插入,就使用 ? extends Hero.\n        如果希望只插入,不取出,就是用 ? extends Hero.\n\n泛型的细节：\n1）、泛型到底代表什么类型取决于调用者传入的类型，如果没传，默认是Object类型；\n2）、使用带泛型的类创建对象时，等式两边指定的泛型必须一致；\n  原因：编译器检查对象调用方法时只看变量，然而程序运行期间调用方法时就要考虑对象具体类型了；\n3）、等式两边可以在任意一边使用泛型，在另一边不使用(考虑向后兼容)；\nArrayList<String> al = new ArrayList<Object>(); //错\n\n//要保证左右两边的泛型具体类型一致就可以了，这样不容易出错。\nArrayList<? extends Object> al = new ArrayList<String>();\nal.add(\"aa\"); //错\n//因为集合具体对象中既可存储String，也可以存储Object的其他子类，所以添加具体的类型对象不合适，类型检查会出现安全问题。 ？extends Object 代表Object的子类型不确定，怎么能添加具体类型的对象呢？\npublic static void method(ArrayList<? extends Object> al) {\nal.add(\"abc\"); //错\n //只能对al集合中的元素调用Object类中的方法，具体子类型的方法都不能用，因为子类型不确定。\n}\n\n\nAPI--- java.lang.System: 属性和行为都是静态的。\nlong currentTimeMillis(); // 返回当前时间毫秒值\nexit();  // 退出虚拟机\nProperties getProperties() ;  // 获取当前系统的属性信息\nProperties prop = System.getProperties(); //获取系统的属性信息，并将这些信息存储到Properties集合中。\nSystem.setProperty(\"myname\",\"毕老师\"); //给系统属性信息集添加具体的属性信息\n//临时设置方式：运行jvm时，可以通过jvm的参数进行系统属性的临时设置，可以在java命令的后面加入 –D<name>=<value> 用法：java –Dmyname=小明 类名。\nString name = System.getProperty(\"os.name\");//获取指定属性的信息\n//想要知道该系统是否是该软件所支持的系统中的一个。\nSet<String> hs = new HashSet<String>();\nhs.add(\"Windows XP\");\nhs.add(\"Windows 7\");\nif(hs.contains(name))\n  System.out.println(\"可以支持\");\nelse\n  System.out.println(\"不支持\");\n\n\n\nAPI--- java.lang.Runtime: 类中没有构造方法，不能创建对象。\n但是有非静态方法。说明该类中应该定义好了对象，并可以通过一个static方法获取这个对象。用这个对象来调用非静态方法。这个方法就是 static Runtime getRuntime();\n这个Runtime其实使用单例设计模式进行设计。\nclass  RuntimeDemo {\n      public static void main(String[] args) throws Exception {\n             Runtime r = Runtime.getRuntime();\n             Process p = r.exec(\"notepad.exe SystemDemo.java\");      //运行指定的程序\n             Thread.sleep(4000);\n             p.destroy(); //杀掉进程\n      }\n}\n\n\n\nAPI--- java.util.Math: 用于数学运算的工具类，属性和行为都是静态的。该类是final不允许继承。\nstatic double ceil(double a) ; //返回大于指定数值的最小整数\nstatic double floor(double a) ; //返回小于指定数值的最大整数\nstatic long round(double a) ; //四舍五入成整数\nstatic double pow(double a, double b) ; //a的b次幂\nstatic double random(); //返回0~1的伪随机数\n      public static void main(String[] args) {\n             Random r = new Random();\n             for(int x=0; x<10; x++) {\n                    //double d = Math.floor(Math.random()*10+1);\n                    //int d  = (int)(Math.random()*10+1);\n                    int d = r.nextInt(10)+1;\n                    System.out.println(d);\n             }\n      }\n\n\nAPI--- java.util.Date：日期类，月份从0-11；\n\n    /*\n      日期对象和毫秒值之间的转换。\n      1，日期对象转成毫秒值。Date类中的getTime方法。\n      2，如何将获取到的毫秒值转成具体的日期呢？\n             Date类中的setTime方法。也可以通过构造函数。\n      */\n             //日期对象转成毫秒值\n             Date d = new Date();\n             long time1 = d.getTime();\n             long time2 = System.currentTimeMillis(); / /毫秒值。\n             \n             //毫秒值转成具体的日期\n             long time = 1322709921312l;\n             Date d = new Date();\n             d.setTime(time);\n/*\n      将日期字符串转换成日期对象：使用的就是DateFormat方法中的 Date parse(String source) ；\n      */\n      public static void method() throws Exception {\n             String str_time = \"2011/10/25\";\n             DateFormat df = new SimpleDateFormat(\"yyyy/MM/dd\"); //SimpleDateFormat作为可以指定用户自定义的格式来完成格式化。\n             Date d = df.parse(str_time);\n      }\n      /*\n      如果不需要使用特定的格式化风格，完全可以使用DateFormat类中的静态工厂方法获取具体的已经封装好风格的对象。getDateInstance();getDateTimeInstance();\n      */\n             Date d = new Date();\n             DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);\n             df = DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG);\n             String str_time = df.format(d);\n      //将日期对象转换成字符串的方式：DateFormat类中的format方法。\n          //创建日期格式对象。\n             DateFormat df = new SimpleDateFormat(); //该对象的建立内部会封装一个默认的日期格式。11-12-1 下午1:48\n             //如果想要自定义日期格式的话。可使用SimpleDateFormat的构造函数。将具体的格式作为参数传入到构造函数中。如何表示日期中年的部分呢？可以必须要参与格式对象文档。\n             df = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");\n             //调用DateFormat中的format方法。对已有的日期对象进行格式化。\n             String str_time = df.format(d);\n\n\nAPI--- java.util. Calendar：日历类\n\n     public static void method(){\n             Calendar c = Calendar.getInstance();\n             System.out.println(c.get(Calendar.YEAR)+\"年\"+(c.get(Calendar.MONTH)+1)+\"月\"\n                                         +getNum(c.get(Calendar.DAY_OF_MONTH))+\"日\"\n                                         +\"星期\"+getWeek(c.get(Calendar.DAY_OF_WEEK)));\n      }\n      public static String getNum(int num){\n             return num>9 ? num+\"\" : \"0\"+num;\n      }\n      public static String getWeek(int index){\n      /*\n      查表法：建立数据的对应关系.\n      最好：数据个数是确定的，而且有对应关系。如果对应关系的一方，是数字，而且可以作为角标，那么可以通过数组来作为表。\n      */\n             String[] weeks = {\"\",\"日\",\"一\",\"二\",\"三\",\"四\",\"五\",\"六\"};\n             return weeks[index];\n      }\n\n\nIO流：★★★★★，用于处理设备上数据。\n流：可以理解数据的流动，就是一个数据流。IO流最终要以对象来体现，对象都存在IO包中。\n流也进行分类：\n1：输入流（读）和输出流（写）。\n2：因为处理的数据不同，分为字节流和字符流。\n字节流\n处理字节数据的流对象。设备上的数据无论是图片或者dvd，文字，它们都以二进制存储的。二进制的最终都是以一个8位为数据单元进行体现，所以计算机中的最小数据单元就是字节。意味着，字节流可以处理设备上的所有数据，所以字节流一样可以处理字符数据。\n字符流\n因为字符每个国家都不一样，所以涉及到了字符编码问题，那么GBK编码的中文用unicode编码解析是有问题的，所以需要获取中文字节数据的同时+ 指定的编码表才可以解析正确数据。为了方便于文字的解析，所以将字节流和编码表封装成对象，这个对象就是字符流。只要操作字符数据，优先考虑使用字符流体系。\n注意：流的操作只有两种：读和写。\n流的体系因为功能不同，但是有共性内容，不断抽取，形成继承体系。该体系一共有四个基类，而且都是抽象类。\n字节流：InputStream  OutputStream\n字符流：Reader  Writer\n在这四个系统中，它们的子类，都有一个共性特点：子类名后缀都是父类名，前缀名都是这个子类的功能名称。\n\npublic static void main(String[] args) throws IOException { //读、写都会发生IO异常\n      /*\n      1：创建一个字符输出流对象，用于操作文件。该对象一建立，就必须明确数据存储位置，是一个文件。\n      2：对象产生后，会在堆内存中有一个实体，同时也调用了系统底层资源，在指定的位置创建了一个存储数据的文件。\n      3：如果指定位置，出现了同名文件，文件会被覆盖。\n      */\n      FileWriter fw = new FileWriter(\"demo.txt\"); // FileNotFoundException\n      /*\n      调用Writer类中的write方法写入字符串。字符串并未直接写入到目的地中，而是写入到了流中，(其实是写入到内存缓冲区中)。怎么把数据弄到文件中？\n      */\n      fw.write(\"abcde\");\n      fw.flush(); // 刷新缓冲区，将缓冲区中的数据刷到目的地文件中。\n      fw.close(); // 关闭流，其实关闭的就是java调用的系统底层资源。在关闭前，会先刷新该流。\n}\n\n\nclose()和flush()的区别：\nflush()：将缓冲区的数据刷到目的地中后，流可以使用。\nclose()：将缓冲区的数据刷到目的地中后，流就关闭了，该方法主要用于结束调用的底层资源。这个动作一定做。\n\n\nio异常的处理方式：io一定要写finally；\nFileWriter写入数据的细节：\n1：window中的换行符：\\r\\n两个符号组成。 linux：\\n。\n2：续写数据，只要在构造函数中传入新的参数true。\n3：目录分割符：window \\\\  /\npublic static void main(String[] args) {\n             FileWriter fw = null;\n             try {\n                    fw = new FileWriter(\"demo.txt\",true);\n                    fw.write(\"abcde\");\n             }\n             catch (IOException e ){\n                    System.out.println(e.toString()+\"....\");\n             }\n             finally{\n                    if(fw!=null)//可能在try中创建对象抛出异常\n                           try{\n                                  fw.close();\n                           }\n                           catch (IOException e){\n                                  System.out.println(\"close:\"+e.toString());\n                           }\n             }\n}\n\n\nFileReader\n使用Reader体系，read()方法,读取一个文本文件中的数据。返回 -1 ，标志读到结尾。\nimport java.io.*;\nclass  FileReaderDemo {\n      public static void main(String[] args) throws IOException {\n             /*\n             创建可以读取文本文件的流对象，FileReader让创建好的流对象和指定的文件相关联。\n             */\n             FileReader fr = new FileReader(\"demo.txt\");\n             int ch = 0;\n             while((ch = fr.read())!= -1) { //条件是没有读到结尾\n                    System.out.println((char)ch); //调用读取流的read方法，读取一个字符。\n             }\n             fr.close();//关闭该流并释放与之关联的所有资源\n      }\n}\n\n\n读取数据的第二种方式：第二种方式较为高效，自定义缓冲区。\nimport java.io.*;\nclass FileReaderDemo2 {\n      public static void main(String[] args) throws IOException {\n             FileReader fr = new FileReader(\"demo.txt\"); //创建读取流对象和指定文件关联。\n             //因为要使用read(char[])方法，将读取到字符存入数组。所以要创建一个字符数组，一般数组的长度都是1024的整数倍。\n             char[] buf = new char[1024];\n             int len = 0;\n             while(( len=fr.read(buf)) != -1) {\n                    System.out.println(new String(buf,0,len));\n             }\n             fr.close();\n      }\n}\n\n\nIO中的使用到了一个设计模式：装饰设计模式。灵活性较强\n装饰设计模式解决：对一组类进行功能的增强。\n包装：写一个类(包装类)对被包装对象进行包装；\n* 1、包装类和被包装对象要实现同样的接口；\n* 2、包装类要持有一个被包装对象；\n* 3、包装类在实现接口时，大部分方法是靠调用被包装对象来实现的，对于需要修改的方法我们自己实现；\n字符流：\nReader\n用于读取字符流的抽象类。子类必须实现的方法只有 read(char[], int, int) 和 close()。\n    |---BufferedReader：从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。 可以指定缓冲区的大小，或者可使用默认的大小。大多数情况下，默认值就足够大了。\n      |---LineNumberReader：跟踪行号的缓冲字符输入流。此类定义了方法 setLineNumber(int) 和 getLineNumber()，它们可分别用于设置和获取当前行号。\n    |---InputStreamReader：是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集。\n      |---FileReader：用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的。要自己指定这些值，可以先在 FileInputStream 上构造一个 InputStreamReader。\n    |---CharArrayReader：\n    |---StringReader：\n\n\nWriter\n写入字符流的抽象类。子类必须实现的方法仅有 write(char[], int, int)、flush() 和 close()。\n    |---BufferedWriter：将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。\n    |---OutputStreamWriter：是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集。\n      |---FileWriter：用来写入字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是可接受的。要自己指定这些值，可以先在 FileOutputStream 上构造一个 OutputStreamWriter。\n    |---PrintWriter：\n    |---CharArrayWriter：\n    |---StringWriter：\n\n\n字节流：\nInputStream\n是表示字节输入流的所有类的超类。\n    |--- FileInputStream：从文件系统中的某个文件中获得输入字节。哪些文件可用取决于主机环境。FileInputStream 用于读取诸如图像数据之类的原始字节流。要读取字符流，请考虑使用 FileReader。\n    |--- FilterInputStream：包含其他一些输入流，它将这些流用作其基本数据源，它可以直接传输数据或提供一些额外的功能。\n      |--- BufferedInputStream：该类实现缓冲的输入流。\n      |--- Stream：\n    |--- ObjectInputStream：\n    |--- PipedInputStream：\n-----------------------------------------------\nOutputStream\n此抽象类是表示输出字节流的所有类的超类。\n    |--- FileOutputStream：文件输出流是用于将数据写入 File 或 FileDescriptor 的输出流。\n    |--- FilterOutputStream：此类是过滤输出流的所有类的超类。\n      |--- BufferedOutputStream：该类实现缓冲的输出流。\n      |--- PrintStream：\n      |--- DataOutputStream：\n    |--- ObjectOutputStream：\n    |--- PipedOutputStream：\n\n\n缓冲区是提高效率用的，给谁提高呢？\nBufferedWriter\n是给字符输出流提高效率用的，那就意味着，缓冲区对象建立时，必须要先有流对象。明确要提高具体的流对象的效率。\n   FileWriter fw = new FileWriter(\"bufdemo.txt\");\n   BufferedWriter bufw = new BufferedWriter(fw);//让缓冲区和指定流相关联。\n   for(int x=0; x<4; x++){\n       bufw.write(x+\"abc\");\n       bufw.newLine(); //写入一个换行符，这个换行符可以依据平台的不同写入不同的换行符。\n       bufw.flush();//对缓冲区进行刷新，可以让数据到目的地中。\n   }\n   bufw.close();//关闭缓冲区，其实就是在关闭具体的流。\n\n\nBufferedReader：\n   FileReader fr = new FileReader(\"bufdemo.txt\");\n   BufferedReader bufr  = new BufferedReader(fr);\n   String line = null;\n   while((line=bufr.readLine())!=null){ //readLine方法返回的时候是不带换行符的。\n       System.out.println(line);\n   }\n   bufr.close();\n-----------------------------\n//记住，只要一读取键盘录入，就用这句话。\nBufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));\nBufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));//输出到控制台\nString line = null;\nwhile((line=bufr.readLine())!=null){\n   if(\"over\".equals(line))\n       break;\n   bufw.write(line.toUpperCase());//将输入的字符转成大写字符输出\n   bufw.newLine();\n   bufw.flush();\n   }\nbufw.close();\nbufr.close();\n\n\n\n\n流对象\n其实很简单，就是读取和写入。但是因为功能的不同，流的体系中提供N多的对象。那么开始时，到底该用哪个对象更为合适呢？这就需要明确流的操作规律。\n流的操作规律：\n1，明确源和目的。\n      数据源：就是需要读取，可以使用两个体系：InputStream、Reader；输入流\n      数据汇：就是需要写入，可以使用两个体系：OutputStream、Writer；输出流\n2，操作的数据是否是纯文本数据？\n      如果是(字符流)：数据源：Reader\n                数据汇：Writer\n      如果不是(字节流)：数据源：InputStream\n                  数据汇：OutputStream\n3，虽然确定了一个体系，但是该体系中有太多的对象，到底用哪个呢？\n      明确操作的数据设备。\n      数据源对应的设备：硬盘(File)，内存(数组)，键盘(System.in)\n      数据汇对应的设备：硬盘(File)，内存(数组)，控制台(System.out)。\n4，需要在基本操作上附加其他功能吗？比如缓冲。(提高效率)\n      如果需要就进行装饰。\n转换流特有功能\n转换流可以将字节转成字符，原因在于，将获取到的字节通过查编码表获取到指定对应字符。\n转换流的最强功能就是基于 字节流 + 编码表 。没有转换，没有字符流。\n发现转换流有一个子类就是操作文件的字符流对象：\nInputStreamReader\n      |--FileReader\nOutputStreamWriter\n      |--FileWrier\n想要操作文本文件，必须要进行编码转换，而编码转换动作转换流都完成了。所以操作文件的流对象只要继承自转换流就可以读取一个字符了。\n但是子类有一个局限性，就是子类中使用的编码是固定的，是本机默认的编码表，对于简体中文版的系统默认码表是GBK。\nFileReader fr = new FileReader(\"a.txt\");\nInputStreamReader isr = new InputStreamReader(new FileInputStream(\"a.txt\"),\"gbk\");\n以上两句代码功能一致，\n如果仅仅使用平台默认码表，就使用FileReader fr = new FileReader(\"a.txt\"); //因为简化。\n如果需要制定码表，必须用转换流。\n转换流 = 字节流+编码表。\n转换流的子类File = 字节流 + 默认编码表。\n凡是操作设备上的文本数据，涉及编码转换，必须使用转换流。\n\n\nFile类\n将文件系统中的文件和文件夹封装成了对象。提供了更多的属性和行为可以对这些文件和文件夹进行操作。这些是流对象办不到的，因为流只操作数据。\nFile类常见方法：\n1：创建。\n   boolean createNewFile()：在指定目录下创建文件，如果该文件已存在，则不创建。而对操作文件的输出流而言，输出流对象已建立，就会创建文件，如果文件已存在，会覆盖。除非续写。不同于输出流.\n   boolean mkdir()：创建此抽象路径名指定的目录。\n   boolean mkdirs()：创建多级目录。\n2：删除。\n   boolean delete()：删除此抽象路径名表示的文件或目录。\n   void deleteOnExit()：在虚拟机退出时删除。\n注意：在删除文件夹时，必须保证这个文件夹中没有任何内容，才可以将该文件夹用delete删除。\n   window的删除动作，是从里往外删。注意：java删除文件不走回收站。要慎用。\n3：获取.\n   long length()：获取文件大小。\n   String getName()：返回由此抽象路径名表示的文件或目录的名称。\n   String getPath()：将此抽象路径名转换为一个路径名字符串。你封装成什么就获取什么\n   String getAbsolutePath()：返回此抽象路径名的绝对路径名字符串。无论封装成什么都获取绝对路径\n   String getParent()：返回此抽象路径名父目录的抽象路径名，如果此路径名没有指定父目录，则返回 null。\nlong lastModified()：返回此抽象路径名表示的文件最后一次被修改的时间。\nFile.pathSeparator：返回当前系统默认的路径分隔符，windows默认为 “；”。\nFile.Separator：返回当前系统默认的目录分隔符，windows默认为 “\\”。\n4：判断：\n   boolean exists()：判断文件或者文件夹是否存在。\n   boolean isDirectory()：测试此抽象路径名表示的文件是否是一个目录。\n   boolean isFile()：测试此抽象路径名表示的文件是否是一个标准文件。\n   boolean isHidden()：测试此抽象路径名指定的文件是否是一个隐藏文件。\n   boolean isAbsolute()：测试此抽象路径名是否为绝对路径名。即使文件不存在也可判断\n5：重命名。\n    boolean renameTo(File dest)：可以实现移动的效果。剪切+重命名。//两个操作对象都是文件\nString[] list()：列出指定目录下的当前的文件和文件夹的名称。包含隐藏文件。\n如果调用list方法的File 对象中封装的是一个文件，那么list方法返回数组为null。如果封装的对象不存在也会返回null。只有封装的对象存在并且是文件夹时，这个方法才有效。根据FilenameFilter类的accept方法的返回值判定是否需要过滤文件\n\n\n递归：就是函数自身调用自身。\n\n什么时候用递归呢？\n当一个功能被重复使用，而每一次使用该功能时的参数不确定，都由上次的功能元素结果来确定。\n简单说：功能内部又用到该功能，但是传递的参数值不确定。(每次功能参与运算的未知内容不确定)。\n递归的注意事项：\n1：一定要定义递归的条件。\n2：递归的次数不要过多。容易出现 StackOverflowError 栈内存溢出错误。\n其实递归就是在栈内存中不断的加载同一个函数。\n------------------------------------------------------------------------------------------------\nJava.util.Properties\n\n一个可以将键值进行持久化存储的对象。Map--Hashtable的子类。\nMap\n      |--Hashtable\n             |--Properties：用于属性配置文件，键和值都是字符串类型。\n特点：1：可以持久化存储数据。2：键值都是字符串。3：一般用于配置文件。\n|-- load()：将流中的数据加载进集合。\n原理：其实就是将读取流和指定文件相关联，并读取一行数据，因为数据是规则的key=value，所以获取一行后，通过 = 对该行数据进行切割，左边就是键，右边就是值，将键、值存储到properties集合中。\n|-- store()：写入各个项后，刷新输出流。\n|-- list()：将集合的键值数据列出到指定的目的地。\n-------------------------------------------------------------------------------------------------\n以下介绍IO包中扩展功能的流对象：基本都是装饰设计模式。\nJava.io.outputstream.PrintStream：打印流\n1：提供了更多的功能，比如打印方法。可以直接打印任意类型的数据。(不修改类型)\n2：它有一个自动刷新机制，创建该对象，指定参数，对于指定方法可以自动刷新。\n3：它使用的本机默认的字符编码.\n4：该流的print方法不抛出IOException。\n该对象的构造函数。\nPrintStream(File file)  ：创建具有指定文件且不带自动行刷新的新打印流。\nPrintStream(File file, String csn) ：创建具有指定文件名称和字符集且不带自动行刷新的新打印流。\nPrintStream(OutputStream out) ：创建新的打印流。\nPrintStream(OutputStream out, boolean autoFlush) ：创建新的打印流。\nPrintStream(OutputStream out, boolean autoFlush, String encoding) ：创建新的打印流。\nPrintStream(String fileName) ：创建具有指定文件名称且不带自动行刷新的新打印流。\nPrintStream(String fileName, String csn)\nPrintStream可以操作目的：1：File对象。2：字符串路径。3：字节输出流。\n前两个都JDK1.5版本才出现。而且在操作文本文件时，可指定字符编码了。\n当目的是一个字节输出流时，如果使用的println方法，可以在printStream对象上加入一个true参数。这样对于println方法可以进行自动的刷新，而不是等待缓冲区满了再刷新。最终print方法都将具体的数据转成字符串，而且都对IO异常进行了内部处理。\n既然操作的数据都转成了字符串，那么使用PrintWriter更好一些。因为PrintWrite是字符流的子类，可以直接操作字符数据，同时也可以指定具体的编码。\n--------------------------------------------------------\nPrintWriter：具备了PrintStream的特点同时，还有自身特点：\n该对象的目的地有四个：1：File对象。2：字符串路径。3：字节输出流。4：字符输出流。\n开发时尽量使用PrintWriter。\n方法中直接操作文件的第二参数是编码表。\n直接操作输出流的，第二参数是自动刷新。\n//读取键盘录入将数据转成大写显示在控制台.\nBufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));//源：键盘输入\n//目的：把数据写到文件中，还想自动刷新。\nPrintWriter out = new PrintWriter(new FileWriter(\"out.txt\"),true);//设置true后自动刷新\nString line = null;\nwhile((line=bufr.readLine())!=null){\n   if(\"over\".equals(line))\n       break;\n   out.println(line.toUpperCase());//转大写输出\n}\n   //注意：System.in，System.out这两个标准的输入输出流，在jvm启动时已经存在了。随时可以使用。当jvm结束了，这两个流就结束了。但是，当使用了显示的close方法关闭时，这两个流在提前结束了。\nout.close();\nbufr.close();\n\n\n\n\nSequenceInputStream：序列流\n作用就是将多个读取流合并成一个读取流。实现数据合并。\n表示其他输入流的逻辑串联。它从输入流的有序集合开始，并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末尾为止。\n这样做，可以更方便的操作多个读取流，其实这个序列流内部会有一个有序的集合容器，用于存储多个读取流对象。\n该对象的构造函数参数是枚举，想要获取枚举，需要有Vector集合，但不高效。需用ArrayList，但ArrayList中没有枚举，只有自己去创建枚举对象。\n但是方法怎么实现呢？因为枚举操作的是具体集合中的元素，所以无法具体实现，但是枚举和迭代器是功能一样的，所以，可以用迭代替代枚举。\n合并原理：多个读取流对应一个输出流。\n切割原理：一个读取流对应多个输出流。\nimport java.io.*;\nimport java.util.*;\nclass  SplitFileDemo{\n   private static final String CFG = \".properties\";\n   private static final String SP = \".part\";\n   public static void main(String[] args) throws IOException{\n       File file = new File(\"c:\\\\0.bmp\");\n       File dir = new File(\"c:\\\\partfiles\");\n       meger(dir);\n   }\n   //数据的合并。\n   public static void meger(File dir)throws IOException{\n       if(!(dir.exists() && dir.isDirectory()))\n           throw new RuntimeException(\"指定的目录不存在，或者不是正确的目录\");\n       File[] files = dir.listFiles(new SuffixFilter(CFG));\n       if(files.length==0)\n           throw new RuntimeException(\"扩展名.proerpties的文件不存在\");\n       //获取到配置文件\n       File config = files[0];\n       //获取配置文件的信息。\n       Properties prop = new Properties();\n       FileInputStream fis = new FileInputStream(config);\n       prop.load(fis);\n       String fileName = prop.getProperty(\"filename\");\n       int partcount = Integer.parseInt(prop.getProperty(\"partcount\"));\n       //--------------------------\n       File[] partFiles = dir.listFiles(new SuffixFilter(SP));\n       if(partFiles.length!=partcount)\n           throw new RuntimeException(\"缺少碎片文件\");\n       //---------------------\n       ArrayList<FileInputStream> al = new ArrayList<FileInputStream>();\n       for(int x=0; x<partcount; x++){\n           al.add(new FileInputStream(new File(dir,x+SP)));\n       }\n       Enumeration<FileInputStream> en = Collections.enumeration(al);\n       SequenceInputStream sis = new SequenceInputStream(en);\n       File file = new File(dir,fileName);\n       FileOutputStream fos = new FileOutputStream(file);\n       byte[] buf = new byte[1024];\n       int len = 0;\n       while((len=sis.read(buf))!=-1){\n           fos.write(buf,0,len);\n       }\n       fos.close();\n       sis.close();\n   }\n   //带有配置信息的数据切割。\n   public static void splitFile(File file)throws IOException{\n       //用一个读取流和文件关联。\n       FileInputStream fis = new FileInputStream(file);\n       //创建目的地。因为有多个。所以先创建引用。\n       FileOutputStream fos = null;\n       //指定碎片的位置。\n       File dir = new File(\"c:\\\\partfiles\");\n       if(!dir.exists())\n           dir.mkdir();\n       //碎片文件大小引用。\n       File f = null;\n       byte[] buf = new byte[1024*1024];\n       //因为切割完的文件通常都有规律的。为了简单标记规律使用计数器。\n       int count = 0;\n       int len = 0;\n       while((len=fis.read(buf))!=-1){\n           f = new File(dir,(count++)+\".part\");\n           fos = new FileOutputStream(f);\n           fos.write(buf,0,len);\n           fos.close();\n       }\n       //碎片文件生成后，还需要定义配置文件记录生成的碎片文件个数。以及被切割文件的名称。\n       //定义简单的键值信息，可是用Properties。\n       String filename = file.getName();\n       Properties prop = new Properties();\n       prop.setProperty(\"filename\",filename);\n       prop.setProperty(\"partcount\",count+\"\");\n       File config = new File(dir,count+\".properties\");\n       fos = new FileOutputStream(config);\n       prop.store(fos,\"\");\n       fos.close();\n       fis.close();\n   }\n}\nclass SuffixFilter implements FileFilter{\n   private String suffix;\n   SuffixFilter(String suffix){\n       this.suffix  = suffix;\n   }\n   public boolean accept(File file){\n       return  file.getName().endsWith(suffix);\n   }\n}\n\n\nRandomAccessFile:\n特点：可实现数据的分段写入(运行多线程)\n1：该对象即可读取，又可写入。\n2：该对象中的定义了一个大型的byte数组，通过定义指针来操作这个数组。\n3：可以通过该对象的getFilePointer()获取指针的位置，通过seek()方法设置指针的位置。\n4：该对象操作的源和目的必须是文件。操作文件时还需要格式\n5：其实该对象内部封装了字节读取流和字节写入流。\n注意：实现随机访问，最好是数据有规律。\nclass RandomAccessFileDemo{\n   public static void main(String[] args) throws IOException{\n       write();\n       read();\n       randomWrite();\n   }\n   //随机写入数据，可以实现已有数据的修改。\n   public static void randomWrite()throws IOException{\n       RandomAccessFile raf = new RandomAccessFile(\"random.txt\",\"rw\");\n       raf.seek(8*4);\n       System.out.println(\"pos :\"+raf.getFilePointer());\n       raf.write(\"王武\".getBytes());\n       raf.writeInt(102);\n       raf.close();\n   }\n   public static void read()throws IOException{\n       RandomAccessFile raf = new RandomAccessFile(\"random.txt\",\"r\");//只读模式。\n       //指定指针的位置。\n       raf.seek(8*1);//实现随机读取文件中的数据。注意：数据最好有规律。\n       System.out.println(\"pos1 :\"+raf.getFilePointer());\n       byte[] buf = new byte[4];\n       raf.read(buf);\n       String name = new String(buf);\n       int age = raf.readInt();\n       System.out.println(name+\"::\"+age);\n       System.out.println(\"pos2 :\"+raf.getFilePointer());\n       raf.close();\n   }\n   public static void write()throws IOException{\n        //r: 不会创建文件,若不存在,则异常\n       //rw：当这个文件不存在，会创建该文件。当文件已存在，不会创建。所以不会像输出流一样覆盖。\n       RandomAccessFile raf = new RandomAccessFile(\"random.txt\",\"rw\");//rw读写模式\n       //往文件中写入人的基本信息，姓名，年龄。\n       raf.write(\"张三\".getBytes());\n       raf.writeInt(97);\n       raf.close();\n   }\n}\n\n\n\n管道流\n管道读取流和管道写入流可以像管道一样对接上，管道读取流就可以读取管道写入流写入的数据。\n注意：需要加入多线程技术，因为单线程，先执行read，会发生死锁，因为read方法是阻塞式的，没有数据的read方法会让线程等待。\npublic static void main(String[] args) throws IOException{\n   PipedInputStream pipin = new PipedInputStream();\n   PipedOutputStream pipout = new PipedOutputStream();\n   pipin.connect(pipout);\n   new Thread(new Input(pipin)).start();\n   new Thread(new Output(pipout)).start();\n}\n\n\n\n对象的序列化\n目的：将一个具体的对象进行持久化，写入到硬盘上。\n注意：静态数据不能被序列化，因为静态数据不在堆内存中，是存储在静态方法区中。\n如何将非静态的数据不进行序列化？用transient(保证其值在堆内存中存在,而不在文本文件中存在) 关键字修饰此变量即可。\nSerializable：用于启动对象的序列化功能，可以强制让指定类具备序列化功能，该接口中没有成员，这是一个标记接口。这个标记接口用于给序列化类提供UID。这个uid是依据类中的成员的数字签名进行运行获取的。如果不需要自动获取一个uid，可以在类中，手动指定一个名称为serialVersionUID id号。依据编译器的不同，或者对信息的高度敏感性。最好每一个序列化的类都进行手动显示的UID的指定。\nimport java.io.*;\nclass ObjectStreamDemo {\n   public static void main(String[] args) throws Exception{\n       writeObj();\n       readObj();\n   }\n   public static void readObj()throws Exception{\n       ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"obj.txt\"));\n       Object obj = ois.readObject();//读取一个对象。\n       System.out.println(obj.toString());\n   }\n   public static void writeObj()throws IOException{\n       ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"obj.txt\"));\n       oos.writeObject(new Person(\"lisi\",25)); //写入一个对象。\n       oos.close();\n   }\n}\nclass Person implements Serializable{\n   private static final long serialVersionUID = 42L;\n   private transient String name;//用transient修饰后name将不会进行序列化\n   public int age;\n   Person(String name,int age){\n       this.name = name;\n       this.age = age;\n   }\n   public String toString(){\n       return name+\"::\"+age;\n   }\n}\n\n\n\nDataOutputStream、DataInputStream\n专门用于操作基本数据类型数据的对象。\nDataOutputStream dos =  new DataOutputStream(new FileOutputStream(\"data.txt\"));\n   dos.writeInt(256);\n   dos.close();\n   DataInputStream dis = new DataInputStream(new FileInputStream(\"data.txt\"));\n   int num = dis.readInt();\n   System.out.println(num);\n   dis.close();\n\n\nByteArrayInputStream：源：内存    ArrayStream\nByteArrayOutputStream：目的：内存。\n这两个流对象不涉及底层资源调用，操作的都是内存中数组，所以不需要关闭。\n直接操作字节数组就可以了，为什么还要把数组封装到流对象中呢？因为数组本身没有方法，只有一个length属性。为了便于数组的操作，将数组进行封装，对外提供方法操作数组中的元素。\n对于数组元素操作无非两种操作：设置（写）和获取（读），而这两操作正好对应流的读写操作。这两个对象就是使用了流的读写思想来操作数组。\n//创建源：\n   ByteArrayInputStream bis = new ByteArrayInputStream(\"abcdef\".getBytes());将字符串转换成Byte数组\n   //创建目的：\n   ByteArrayOutputStream bos = new ByteArrayOutputStream();\n   int ch = 0;\n   while((ch=bis.read())!=-1){\n       bos.write(ch);\n   }\n   System.out.println(bos.toString());\n\n\n网络编程\nIP找主机,端口找程序\n端口：\n物理端口：\n逻辑端口：用于标识进程的逻辑地址，不同进程的标识；有效端口：0~65535，其中0~1024系统使用或保留端口。\njava 中ip对象：InetAddress.\nimport java.net.*;\nclass  IPDemo{\n   public static void main(String[] args) throws UnknownHostException{\n       //通过名称(ip字符串or主机名)来获取一个ip对象。\n       InetAddress ip = InetAddress.getByName(\"www.baidu.com\");//java.net.UnknownHostException\n       System.out.println(\"addr:\"+ip.getHostAddress());\n       System.out.println(\"name:\"+ip.getHostName());\n   }\n}\n\n\nSocket：★★★★，套接字，通信的端点。\n就是为网络服务提供的一种机制，通信的两端都有Socket，网络通信其实就是Socket间的通信，数据在两个Socket间通过IO传输。\nUDP传输：\n1，只要是网络传输，必须有socket 。\n2，数据一定要封装到数据包中，数据包中包括目的地址、端口、数据等信息。\n直接操作udp不可能，对于java语言应该将udp封装成对象，易于我们的使用，这个对象就是DatagramSocket. 封装了udp传输协议的socket对象。\n因为数据包中包含的信息较多，为了操作这些信息方便，也一样会将其封装成对象。这个数据包对象就是：DatagramPacket.通过这个对象中的方法，就可以获取到数据包中的各种信息。\nDatagramSocket具备发送和接受功能，在进行udp传输时，需要明确一个是发送端，一个是接收端。\nudp的发送端：\n1，建立udp的socket服务，创建对象时如果没有明确端口，系统会自动分配一个未被使用的端口。\n2，明确要发送的具体数据。\n3，将数据封装成了数据包。\n4，用socket服务的send方法将数据包发送出去。\n5，关闭资源。\n\nimport java.net.*;\nclass  UdpSend{\n   public static void main(String[] args)throws Exception {\n//      1，建立udp的socket服务。\n       DatagramSocket ds = new DatagramSocket(8888);//指定发送端口，不指定系统会随机分配。\n//      2，明确要发送的具体数据。\n       String text = \"udp传输演示 哥们来了\";\n       byte[] buf = text.getBytes();\n//      3，将数据封装成了数据包。\n       DatagramPacket dp = new DatagramPacket(buf,\nbuf.length,InetAddress.getByName(\"10.1.31.127\"),10000);\n//      4，用socket服务的send方法将数据包发送出去。\n       ds.send(dp);\n//      5，关闭资源。\n       ds.close();\n   }\n}\n\n\n\nudp的接收端：\n1，创建udp的socket服务，必须要明确一个端口，作用在于，只有发送到这个端口的数据才是这个接收端可以处理的数据。\n2，定义数据包，用于存储接收到数据。\n3，通过socket服务的接收方法将收到的数据存储到数据包中。\n4，通过数据包的方法获取数据包中的具体数据内容，比如ip、端口、数据等等。\n5，关闭资源。\nclass UdpRece {\n   public static void main(String[] args) throws Exception{\n//      1，创建udp的socket服务。\n       DatagramSocket ds = new DatagramSocket(10000);\n//      2，定义数据包，用于存储接收到数据。先定义字节数组，数据包会把数据存储到字节数组中。\n       byte[] buf = new byte[1024];\n       DatagramPacket dp = new DatagramPacket(buf,buf.length);\n//      3，通过socket服务的接收方法将收到的数据存储到数据包中。\n       ds.receive(dp);//该方法是阻塞式方法。\n//      4，通过数据包的方法获取数据包中的具体数据内容，比如ip，端口，数据等等。\n       String ip = dp.getAddress().getHostAddress();\n       int port = dp.getPort();\n       String text = new String(dp.getData(),0,dp.getLength());//将字节数组中的有效部分转成字符串。\n       System.out.println(ip+\":\"+port+\"--\"+text);\n//      5，关闭资源。\n       ds.close();\n   }\n}\n\n\nTCP传输：两个端点的建立连接后会有一个传输数据的通道，这通道称为流，而且是建立在网络基础上的流，称之为socket流。该流中既有读取，也有写入。\ntcp的两个端点：一个是客户端，一个是服务端。\n客户端：对应的对象，Socket\n服务端：对应的对象，ServerSocket\nTCP客户端：应先启动服务端\n1，建立tcp的socket服务，最好明确具体的地址和端口。这个对象在创建时，就已经可以对指定ip和端口进行连接(三次握手)。\n2，如果连接成功，就意味着通道建立了，socket流就已经产生了。只要获取到socket流中的读取流和写入流即可，只要通过getInputStream和getOutputStream就可以获取两个流对象。\n3，关闭资源。\nimport java.net.*;\nimport java.io.*;\n//需求：客户端给服务器端发送一个数据。\nclass  TcpClient{\n   public static void main(String[] args) throws Exception{\n       Socket s = new Socket(\"10.1.31.69\",10002);\n       OutputStream out = s.getOutputStream();//获取了socket流中的输出流对象。\n       out.write(\"tcp演示，哥们又来了!\".getBytes());\n       s.close();\n   }\n}\n\n\nTCP服务端：\n1，创建服务端socket服务，并监听一个端口。\n2，服务端为了给客户端提供服务，获取客户端的内容，可以通过accept方法(阻塞式)获取连接过来的客户端对象。\n3，可以通过获取到的socket对象中的socket流和具体的客户端进行通讯。\n4，如果通讯结束，关闭资源。注意：要先关客户端，再关服务端。\nclass  TcpServer{\n   public static void main(String[] args) throws Exception{\n       ServerSocket ss = new ServerSocket(10002);//建立服务端的socket服务\n       Socket s = ss.accept();//获取客户端对象\n       String ip = s.getInetAddress().getHostAddress();\n       System.out.println(ip+\".....connected\");\n//      可以通过获取到的socket对象中的socket流和具体的客户端进行通讯。\n       InputStream in = s.getInputStream();//读取客户端的数据，使用客户端对象的socket读取流\n       byte[] buf = new byte[1024];\n       int len = in.read(buf);\n       String text = new String(buf,0,len);\n       System.out.println(text);\n//      如果通讯结束，关闭资源。注意：要先关客户端，在关服务端。\n       s.close();\n       ss.close();\n   }\n}\n\n\n反射技术\n其实就是动态加载一个指定的类，并获取该类中的所有的内容。而且将字节码文件封装成对象，并将字节码文件中的内容都封装成对象，这样便于操作这些成员。简单说：反射技术可以对一个类进行解剖。\n反射的好处：大大的增强了程序的扩展性。\n反射的基本步骤：\n1、获得Class对象，就是获取到指定的名称的字节码文件对象。\n2、实例化对象，获得类的属性、方法或构造函数。\n3、访问属性、调用方法、调用构造函数创建对象。\n获取这个Class对象，有三种方式：\n1：通过每个对象都具备的方法getClass来获取。弊端：必须要创建该类对象，才可以调用getClass方法。\n2：每一个数据类型(基本数据类型和引用数据类型)都有一个静态的属性class。弊端：必须要先明确该类。\n    前两种方式不利于程序的扩展，因为都需要在程序使用具体的类来完成。\n3：使用的Class类中的方法，静态的forName方法。\n    指定什么类名，就获取什么类字节码文件对象，这种方式的扩展性最强，只要将类名的字符串传入即可。\n// 1. 根据给定的类名来获得  用于类加载\nString classname = \"cn.itcast.reflect.Person\";// 来自配置文件\nClass clazz = Class.forName(classname);// 此对象代表Person.class\n// 2. 如果拿到了对象，不知道是什么类型   用于获得对象的类型\nObject obj = new Person();\nClass clazz1 = obj.getClass();// 获得对象具体的类型\n// 3. 如果是明确地获得某个类的Class对象  主要用于传参\nClass clazz2 = Person.class;\n\n\n反射的用法：\n1）、需要获得java类的各个组成部分，首先需要获得类的Class对象，获得Class对象的三种方式：\n      Class.forName(classname) 用于做类加载\n      obj.getClass()                      用于获得对象的类型\n      类名.class                       用于获得指定的类型，传参用\n2)、反射类的成员方法：\n      Class clazz = Person.class;\n      Method method = clazz.getMethod(methodName, new Class[]{paramClazz1, paramClazz2});\n      method.invoke();\n     \n3)、反射类的构造函数：\n      Constructor con = clazz.getConstructor(new Class[]{paramClazz1, paramClazz2,...})\n      con.newInstance(params...)\n4)、反射类的属性：\n      Field field = clazz.getField(fieldName);\n      field.setAccessible(true);\n      field.setObject(value);\n\n\n获取了字节码文件对象后，最终都需要创建指定类的对象：\n创建对象的两种方式(其实就是对象在进行实例化时的初始化方式)：\n1，调用空参数的构造函数：使用了Class类中的newInstance()方法。\n2，调用带参数的构造函数：先要获取指定参数列表的构造函数对象，然后通过该构造函数的对象的newInstance(实际参数) 进行对象的初始化。\n综上所述，第二种方式，必须要先明确具体的构造函数的参数类型，不便于扩展。所以一般情况下，被反射的类，内部通常都会提供一个公有的空参数的构造函数。\n   // 如何生成获取到字节码文件对象的实例对象。\n       Class clazz = Class.forName(\"cn.itcast.bean.Person\");//类加载\n// 直接获得指定的类型\n      clazz = Person.class;\n      // 根据对象获得类型\n      Object obj = new Person(\"zhangsan\", 19);\n      clazz = obj.getClass();\n       Object obj = clazz.newInstance();//该实例化对象的方法调用就是指定类中的空参数构造函数，给创建对象进行初始化。当指定类中没有空参数构造函数时，该如何创建该类对象呢？请看method_2();\n   public static void method_2() throws Exception {\n       Class clazz = Class.forName(\"cn.itcast.bean.Person\");\n       //既然类中没有空参数的构造函数,那么只有获取指定参数的构造函数,用该函数来进行实例化。\n       //获取一个带参数的构造器。\n       Constructor constructor = clazz.getConstructor(String.class,int.class);\n       //想要对对象进行初始化，使用构造器的方法newInstance();\n       Object obj = constructor.newInstance(\"zhagnsan\",30);\n       //获取所有构造器。\n       Constructor[] constructors = clazz.getConstructors();//只包含公共的\n       constructors = clazz.getDeclaredConstructors();//包含私有的\n       for(Constructor con : constructors) {\n           System.out.println(con);\n       }\n   }\n\n\n反射指定类中的方法：\n   //获取类中所有的方法。\n   public static void method_1() throws Exception {\n       Class clazz = Class.forName(\"cn.itcast.bean.Person\");\n       Method[] methods = clazz.getMethods();//获取的是该类中的公有方法和父类中的公有方法。\n       methods = clazz.getDeclaredMethods();//获取本类中的方法，包含私有方法。\n       for(Method method : methods) {\n           System.out.println(method);\n       }\n   }\n   //获取指定方法；\n   public static void method_2() throws Exception {\n       Class clazz = Class.forName(\"cn.itcast.bean.Person\");\n       //获取指定名称的方法。\n       Method method = clazz.getMethod(\"show\", int.class,String.class);\n       //想要运行指定方法，当然是方法对象最清楚，为了让方法运行，调用方法对象的invoke方法即可，但是方法运行必须要明确所属的对象和具体的实际参数。\n       Object obj = clazz.newInstance();\n       method.invoke(obj, 39,\"hehehe\");//执行一个方法\n   }\n   //想要运行私有方法。\n   public static void method_3() throws Exception {\n       Class clazz = Class.forName(\"cn.itcast.bean.Person\");\n       //想要获取私有方法。必须用getDeclearMethod();\n       Method method = clazz.getDeclaredMethod(\"method\", null);\n       // 私有方法不能直接访问，因为权限不够。非要访问，可以通过暴力的方式。\n       method.setAccessible(true);//一般很少用，因为私有就是隐藏起来，所以尽量不要访问。\n   }\n   //反射静态方法。\n   public static void method_4() throws Exception {\n       Class clazz = Class.forName(\"cn.itcast.bean.Person\");\n       Method method = clazz.getMethod(\"function\",null);\n       method.invoke(null,null);\n   }\n\n\n正则表达式：★★★☆，其实是用来操作字符串的一些规则。\n好处：正则的出现，对字符串的复杂操作变得更为简单。\n特点：将对字符串操作的代码用一些符号来表示。只要使用了指定符号，就可以调用底层的代码对字符串进行操作。符号的出现，简化了代码的书写。\n弊端：符号的出现虽然简化了书写，但是却降低了阅读性。\n其实更多是用正则解决字符串操作的问题。\n组\n用小括号标示，每定义一个小括号，就是一个组，而且有自动编号，从1开始。\n   只要使用组，对应的数字就是使用该组的内容。别忘了，数组要加\\\\。\n   (aaa(wwww(ccc))(eee))技巧，从左括号开始数即可。有几个左括号就是几组。\n常见操作：\n1，匹配：其实用的就是String类中的matches方法。\nString reg = \"[1-9][0-9]{4,14}\";\n   boolean b = qq.matches(reg);//将正则和字符串关联对字符串进行匹配。\n2，切割：其实用的就是String类中的split方法。\n3，替换：其实用的就是String类中的replaceAll();\n4，获取：\n  1），先要将正则表达式编译成正则对象。使用的是Pattern中静态方法 compile(regex);\n  2），通过Pattern对象获取Matcher对象。\n      Pattern用于描述正则表达式，可以对正则表达式进行解析。\n      而将规则操作字符串，需要从新封装到匹配器对象Matcher中。\n      然后使用Matcher对象的方法来操作字符串。\n      如何获取匹配器对象呢？\n      通过Pattern对象中的matcher方法。该方法可以正则规则和字符串想关联。并返回匹配器对象。\n  3），使用Matcher对象中的方法即可对字符串进行各种正则操作。\n","tags":["java"],"categories":["MyTech","Java"]},{"title":"工具使用-Git笔记","url":"/posts/1415913582/","content":"# 工具使用 | Git 笔记\n\n@[toc]\n## **1、git提交文件到仓库——多次add,一次commit**\n<!-- more -->\n为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：\n\n```shell\ngit add file1.txt\ngit add file2.txt file3.txt\ngit commit -m \"add 3 files.\"\n```\n\n**小结**\n\n现在总结一下今天学的两点内容：\n\n初始化一个Git仓库，使用git init命令。\n\n添加文件到Git仓库，分两步：\n\n使用命令git add ，注意，可反复多次使用，添加多个文件；\n\n使用命令git commit -m ，完成。\n\n------\n\n##  **2、当本地修改了文件时候，如何提交与版本控制** \n\n```shell\ngit status #查看当前状态\ngit diff readme.txt # 查看文件readme.txt哪几行发生了增减\n```\n\n**小结**\n\n要随时掌握工作区的状态，使用git status命令。\n\n如果git status告诉你有文件被修改过，用git diff可以查看修改内容。\n\n------\n\n## **3、穿梭未来–回到过去**\n\n`HEAD`指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令`git reset --hard commit_id`。\n\n穿梭前，用`git log`可以查看提交历史，以便确定要回退到哪个版本。\n\n要重返未来，用`git reflog`查看命令历史，以便确定要回到未来的哪个版本。\n\n------\n\n## **4、git工作区与缓存区**\n\n工作区是当前的目录，缓冲区是可以保存多次文件修改的地方，使用`git add <file>`将工作区的修改内容提交到缓冲区。\n\n版本库是`.git`文件，利用`git commit -m \"comment\"`可以将缓冲区的所有修改一次性全部提交到版本库`.git`中。\n\n在Git中，用`HEAD`表示版本库当前版本，也就是最新的提交`1094adb...`\n(**实际上HEAD指向的master分支，master指向最新的一次提交1094adb...**)，注意我的提交ID和你的肯定不一样，上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，当然往上100个版本写100个^比较容易数不过来，所以写成`HEAD~100`。\n\n------\n\n## **5、管理修改**\n\n用`git diff HEAD -- readme.txt`命令可以查看版本库里面最新版本和工作区的区别\n\n**小结**\n\n第一次修改 -> `git add`-> 第二次修改 -> `git add`-> `git commit`\n好，现在，把第二次修改提交了，\n\n然后开始小结。\n理解了Git是如何跟踪修改的，每次修改，如果不用git add到暂存区，那就不会加入到commit中。\n\n------\n\n## **6、撤销修改**\n\n命令`git checkout -- readme.txt`意思就是，把`readme.txt`文件在工作区的修改全部撤销，这里有两种情况：\n\n一种是`readme.txt`自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库[一模一样](https://www.baidu.com/s?wd=%E4%B8%80%E6%A8%A1%E4%B8%80%E6%A0%B7&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)的状态；\n\n一种是`readme.txt`已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n\n总之，就是让这个文件回到最近一次`git commit`或`git add`时的状态。\n\n**小结**\n\n`git checkout -- file`命令中的`--`很重要，没有`--`，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git `checkout`命令。\n\n------\n\n## **7、删除本地文件后如何与版本库同步**\n\n现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令`git rm`删掉，并且`git commit`：\n\n```shell\n$ git rm test.txt\nrm 'test.txt'\n$ git commit -m \"remove test.txt\"\n[master d46f35e] remove test.txt\n 1 file changed, 1 deletion(-)\n delete mode 100644 test.txt\n```\n\n**小结**\n\n命令`git rm <file>`用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。\n\n------\n\n## **8、远程仓库**\n\n**1.添加远程库**\n\n要将**本地的版本库**关联一个**远程库(一般用origin表示远程库)**，使用命令`git remote add origin git@server-name:path/repo-name.git`；\n\n关联后，使用命令`git push -u origin master`第一次推送本地版本库`master`分支的所有内容；\n\n说明：我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n此后，每次本地提交后，只要有必要，就可以使用命令`git push origin master`推送最新修改。\n\n**2.从远程库克隆**\n\nGit支持多种协议，包括`https`，但通过`ssh`支持的原生`git`协议速度最快。\n\n如：`git clone git@github.com:michaelliao/gitskills.git`即可。\n\n------\n\n## **9、分支管理**\n\n**1.创建与合并分支**\n\n首先，我们创建dev分支，然后切换到dev分支：\n\n```shell\ngit checkout -b dev\n\nSwitched to a new branch 'dev'\n\ngit checkout命令加上-b参数表示创建并切换，相当于以下两条命令：\n\n$ git branch dev\n$ git checkout dev\nSwitched to branch 'dev'\n然后，用git branch命令查看当前分支：\n\n$ git branch\n* dev\n  master\ngit branch命令会列出所有分支，当前分支前面会标一个*号。\n\n然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：\nCreating a new branch is quick.\n\n然后提交：\n$ git add readme.txt \n$ git commit -m \"branch test\"\n[dev b17d20e] branch test\n 1 file changed, 1 insertion(+)\n \n现在，dev分支的工作完成，我们就可以切换回master分支：\n$ git checkout master\nSwitched to branch 'master'\n\n切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：\n\n现在，我们把dev分支的工作成果合并到master分支上：\n$ git merge dev\nUpdating d46f35e..b17d20e\nFast-forward\n readme.txt | 1 +\n 1 file changed, 1 insertion(+)\ngit merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。\n\n注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。\n\n当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。\n\n合并完成后，就可以放心地删除dev分支了：\n$ git branch -d dev\nDeleted branch dev (was b17d20e).\n删除后，查看branch，就只剩下master分支了：\n\n$ git branch\n* master\n因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。\n```\n\n**小结**\n\nGit鼓励大量使用分支：\n\n查看分支：`git branch`\n\n创建分支：`git branch <name>`\n\n切换分支：`git checkout <name>`\n\n创建+切换分支：`git checkout -b <name>`\n\n合并某分支到当前分支：`git merge <name>`\n\n删除分支：`git branch -d <name>`\n\n------\n\n**2.解决冲突**\n\n我们可以直接查看readme.txt的内容：\n\n```shell\nGit is a distributed version control system.\nGit is free software distributed under the GPL.\nGit has a mutable index called stage.\nGit tracks changes of files.\n<<<<<<< HEAD\nCreating a new branch is quick & simple.\n=======\nCreating a new branch is quick AND simple.\n>>>>>>> feature1\n```\n\nGit用`<<<<<<<，=======，>>>>>>>`标记出不同分支的内容，我们修改如下后保存：\n\n`Creating a new branch is quick and simple.`\n\n再提交：\n\n```shell\n$ git add readme.txt \n$ git commit -m \"conflict fixed\"\n[master cf810e4] conflict fixed\n```\n\n现在，master分支和feature1分支使用下面命令查看：\n`git log --graph --pretty=oneline --abbrev-commit`\n\n或者是`git log --graph`查看解决矛盾图。\n\n------\n\n**3.分支合并策略**\n\n`--no-ff`表示普通合并，合并后可以看得到分支，而 fast-farwaef模式看不到分支，\n\n格式：`git merge --no-ff -m \"merge with no-ff\" dev`\n\n------\n\n**4.bug分支**\n\n```shell\nBug分支\n软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。\n\n当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：\n\n$ git status\nOn branch dev\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n    new file:   hello.py\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   readme.txt\n并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？\n\n幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：\n\n$ git stash\nSaved working directory and index state WIP on dev: f52c633 add merge\n现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。\n\n首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：\n\n$ git checkout master\nSwitched to branch 'master'\nYour branch is ahead of 'origin/master' by 6 commits.\n  (use \"git push\" to publish your local commits)\n\n\n$ git checkout -b issue-101\nSwitched to a new branch 'issue-101'\n现在修复bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交：\n\n\n$ git add readme.txt \n$ git commit -m \"fix bug 101\"\n[issue-101 4c805e2] fix bug 101\n 1 file changed, 1 insertion(+), 1 deletion(-)\n修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：\n\n\n$ git checkout master\nSwitched to branch 'master'\nYour branch is ahead of 'origin/master' by 6 commits.\n  (use \"git push\" to publish your local commits)\n\n$ git merge --no-ff -m \"merged bug fix 101\" issue-101\nMerge made by the 'recursive' strategy.\n readme.txt | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！\n\n$ git checkout dev\nSwitched to branch 'dev'\n\n\n$ git status\nOn branch dev\nnothing to commit, working tree clean\n工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：\n\n\n$ git stash list\nstash@{0}: WIP on dev: f52c633 add merge\n工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：\n```\n\n```shell\n一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；\n\n\n另一种方式是用git stash pop，恢复的同时把stash内容也删了：\n\n$ git stash pop\nOn branch dev\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    new file:   hello.py\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   readme.txt\n\nDropped refs/stash@{0} (5d677e2ee266f39ea296182fb2354265b91b3b2a)\n再用git stash list查看，就看不到任何stash内容了：\n\n$ git stash list\n你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：\n\n$ git stash apply stash@{0}\n```\n\n-  ​\n\n**小结**\n\n修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n\n当手头工作没有完成时，先把工作现场`git stash`一下，然后去修复bug，修复后，再`git stash pop`，\n\n------\n\n**5.feature 分支**\n\n```shell\n添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。\n\n现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。\n\n于是准备开发：~~++*此时我们是在dev分支上进行的开发*++~~。\n\n$ git checkout -b feature-vulcan\nSwitched to a new branch 'feature-vulcan'\n5分钟后，开发完毕：\n\n$ git add vulcan.py\n\n$ git status\nOn branch feature-vulcan\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n  \n    new file:   vulcan.py\n\n$ git commit -m \"add feature vulcan\"\n[feature-vulcan 287773e] add feature vulcan\n 1 file changed, 2 insertions(+)\n create mode 100644 vulcan.py\n切回dev，准备合并：\n\n$ git checkout dev\n一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。\n\n\n但是！\n\n就在此时，接到上级命令，因经费不足，新功能必须取消！\n虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：\n\n$ git branch -d feature-vulcan\nerror: The branch 'feature-vulcan' is not fully merged.\nIf you are sure you want to delete it, run 'git branch -D feature-vulcan'.\n销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。\n\n\n现在我们强行删除：\n\n\n$ git branch -D feature-vulcan\nDeleted branch feature-vulcan (was 287773e).\n终于删除成功！\n```\n\n**小结**\n\n开发一个新`feature`，最好新建一个分支；\n\n如果要丢弃一个没有被合并过的分支，可以通过`git branch -D <name>`强行删除。\n\n------\n\n## **10、多人协作**\n\n多人协作的工作模式通常是这样：\n\n1.首先，可以试图用`git push origin <branch-name>`推送自己的修改；\n\n2如果推送失败，则因为远程分支比你的本地更新，需要先用`git pull`试图合并；\n\n3如果合并有冲突，则解决冲突，并在本地提交；\n\n4没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！\n\n如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to origin/。\n\n这就是多人协作的工作模式，一旦熟悉了，就非常简单。\n\n**小结**\n\n1查看远程库信息，使用`git remote -v`；\n\n2本地新建的分支如果不推送到远程，对其他人就是不可见的；\n\n3从本地推送分支，使用`git push origin branch-name`，如果推送失败，先用`git pull`抓取远程的新提交；\n\n4在本地创建和远程分支对应的分支，使用`git checkout -b branch-name origin/branch-name`，本地和远程分支的名称最好一致；\n\n5建立本地分支和远程分支的关联，使用`git branch --set-upstream branch-name origin/branch-name`；\n\n6从远程抓取分支，使用`git pull`，如果有冲突，要先处理冲突。\n\n------\n\n## **11、多人协作-rebase**\n[link](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0015266568413773c73cdc8b4ab4f9aa9be10ef3078be3f000)\n\n**小结**\n\nrebase操作可以把本地未push的分叉提交历史整理成直线；\n\nrebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比\n\n------\n\n## **12、打tag以及修改tag**\n\n**1.打标签tag**\n\n命令`git tag <tagname>`用于新建一个标签，默认为HEAD，也可以指定一个`commit id`；\n\n命令`git tag -a <tagname> -m \"blablabla...\"`可以指定标签信息；\n\n命令`git tag`可以查看所有标签。\n\n标签不是按时间顺序列出，而是按字母排序的。可以用`git show <tagname>`查看标签信息。\n\n注意：标签总是和某个`commit`挂钩。如果这个`commit`既出现在````master`分支，又出现`在dev```分支，那么在这两个分支上都可以看到这个标签.\n\n**2.修改tag**\n\n删除标签 `git tag -d v0.1`\n\n如果要推送某个标签到远程，使用命令`git push origin <tagname>`：\n\n```shell\n$ git push origin v1.0\nTotal 0 (delta 0), reused 0 (delta 0)\nTo github.com:michaelliao/learngit.git\n * [new tag]         v1.0 -> v1.0\n或者，一次性推送全部尚未推送到远程的本地标签：\n\n\n$ git push origin --tags\nTotal 0 (delta 0), reused 0 (delta 0)\nTo github.com:michaelliao/learngit.git\n * [new tag]         v0.9 -> v0.9\n如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：\n\n\n$ git tag -d v0.9\nDeleted tag 'v0.9' (was f52c633)\n然后，从远程删除。删除命令也是push，但是格式如下：\n\n\n$ git push origin :refs/tags/v0.9\nTo github.com:michaelliao/learngit.git\n - [deleted]         v0.9\n```\n\n要看看是否真的从远程库删除了标签，可以登陆GitHub查看。\n\n**小结**\n\n命令`git push origin <tagname>`可以推送一个本地标签；\n\n命令`git push origin --tags`可以推送全部未推送过的本地标签；\n\n命令`git tag -d <tagname>`可以删除一个本地标签；\n\n命令`git push origin :refs/tags/<tagname>`可以删除一个远程标签。\n\n------\n\n## **13、github使用**\n\n在GitHub上，可以任意Fork开源仓库；\n\n自己拥有Fork后的仓库的读写权限；\n\n可以推送pull request给官方仓库来贡献代码","tags":["Git","工具"],"categories":["MyTech","工具"]},{"title":"分治 芯片测试","url":"/posts/2307581756/","content":"# 1. 芯片测试\n在讲解具体的芯片测试的分治策略算法之前，先来了芯片测试的意思\n<!-- more -->\n## 1.1 一次测试的过程\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200429173027710.png)\n\n如上图，A、B为芯片。测试方法为：将2片芯片（A和B）置于测试台上，互相进行测试，测试报告是“好”或者“坏”，只取其一。\n\n- 假设：好芯片的报告一定是正确的，坏芯片的报告是不确定的（可能会出错）\n\n那么上述测试的结果有四种可能,如下图:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200429173041111.png)\n\n> 上面的结果应该不难理解\n\n那么现在问题来了:\n\n- 输入：n片芯片，其中好芯片，至少比坏芯片多一片\n- 问题：设计一种测试方法，通过测试从n片中挑出1片好芯片\n- 要求：使用最少的测试次数\n## 1.2 如何测试一块芯片的好坏\n> 针对上述问题，现在先来研究一下，如何在上述n片芯片中，测试出A是好芯片还是坏芯片？\n> - 问题：给定芯片A，判定A的好坏\n> - 方法：用其他n-1片芯片对A进行测试。\n\n假设：n=7:好芯片数>=4\n\n1. A好，6个芯片中至少3个报“好”\n2. A坏，6个芯片中至少4个报坏\n\n所以对于n是奇数情况下：好芯片数>=（n+1）/2\nA好，至少有(n-1)/2个报“好”\nA坏，至少有(n+1)/2个报“坏”\n\n> 结论：\n至少一半报好，A是好芯片\n超过一半报坏，A是坏芯片\n\n假设: n=8:好芯片数>=5\n\n1. A好，7个芯片中至少4个报“好”\n2. A坏，7个芯片中至少5个报“坏”\n\n所以对于n是偶数：好芯片数 >= n/2+1.\nA 好, 至少有 n/2个报告“好”\nA 坏, 至少有 n/2+1个报告“坏”\n\n> 结论：n-1份报告中\n至少一半报好，A是好芯片\n至少一半报坏，A是坏芯片\n\n上面的分析，已经很清晰，我们已经知道如何测试一块芯片的好坏。那么人们最拿手的方法就是：暴力算法（蛮力算法）可以直接写代码了。。。\n\n## 1.3 蛮力算法\n测试算法：任取 1片测试，如果是好芯片，测试结束；如果是坏芯片，抛弃，再从剩下芯片中任取 1片测试，直到得到 1片好芯片\n\n时间估计：\n\n第一片是坏芯片，最多测试n-2次\n第二片是坏芯片，最多测试n-3次\n…\n\n**总计：Θ(n^2 )**\n```cpp\n#include<iostream>\n#include<cmath>\n#include <stdio.h>\n#include <time.h>\n#include <stdlib.h>\n#include <cstring>\n#define MAX 100\nusing namespace std;\n\nint main(){\n    int n;\n    int a[MAX];\n    while(cin>>n){\n        srand(time(NULL));\n        memset(a,0,sizeof(a));\n        for(int i=1;i<=n;i++){   /*芯片编号为数组下标，从1开始*/\n             cin>>a[i];             /*数组值代表芯片好坏，1为真0为假*/\n        }\n        int cnt=0;                  /*查找次数*/\n        for(int i=1;i<=n;i++){\n            int sum=0;\n            for(int j=1;j<=n;j++){\n                cnt++;\n                if(i!=j&&a[i]==1&&a[j]==1)   /*两片芯片都是好的*/\n                    sum++;\n                    if(i!=j&&a[i]==1&&a[j]==0)   /*测试芯片是坏的*/\n                        sum+=rand()%2;\n                    if(i!=j&&a[i]==0&&a[j]==0)   /*两片芯片都是坏的*/\n                        sum+=rand()%2;\n                }\n                if(sum>=n/2){\n                    cout<<\"查找次数：\"<<cnt<<endl;\n                    break;\n                }\n            }\n        }\n        return 0;\n}\n```\n可见时间复杂度之高，数据量一多，肯定会超时。\n\n## 1.4 分治算法设计思想\n在分析分治算法的正确性之前，我们先给出这个算法的描述：\n\n假设n为偶数，将n片芯片两两一组做测试淘汰，剩下芯片构成子问题，进入下一轮分组淘汰。\n\n淘汰规则为：\n\n- “好，好” ==> 任留1片，进入下轮\n- 其他情况 ==> 全部抛弃\n\n**递归截止条件：n<=3**\n3片芯片，一次测试可得到好芯片\n1或者2片芯片，不需要再测试，他们都为好芯片。\n\n上述算法过程就是我们给出的分治策略的设计。那么为什么上述的策略是正确的呢？\n\n回忆一下，前面的文章，要保证分治策略的正确性的基本条件是：子问题与原问题性质相同。下面我们就来证明，上述分治策略的子问题与原问题性质相同。\n\n### 1.41 分治算法的正确性证明\n原问题：n片芯片，其中好芯片，至少比坏芯片多一片\n\n> 那么子问题，命题1：当 n 是偶数时，在上述淘汰规则下，经过一轮淘汰，剩下的好芯片比坏芯片至少多1片\n\n我们需要证明上述子问题的命题1是正确的。\n\n证明：假设原问题中A，B都好的芯片有i组，A与B一好一坏的有j组，A与B都坏的有k组。那么经过一轮淘汰后，好芯片还剩i片，坏芯片还剩k片。\n\n因为\n\n- 初始芯片总数 2i+2j+2k = n\n- 初始好芯片多于坏芯片：2i+j > 2k+j\n\n得出：i>k\n\n所以，剩余的芯片好芯片比坏芯片，至少多1片。命题1 是正确的。即证明了上述分治算法的正确性。\n\n> 当n为奇数时，特殊处理。当n是奇数时，可能会出现问题，如图：\n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200429173514882.png)\n> 可见淘汰后的子问题并不满足于原问题性质相同，此时无法继续测试。\n>- 处理办法是：当n为奇数时，增加一轮对轮空芯片的单独测试，如果该轮空芯片为好芯片则算法结束，如果是坏芯片，则淘汰该芯片。\n\n下面给出上述分治算法的伪码描述：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200429173538122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n补充说明：\n1. 第6点：`if(1好1坏) `，则说明测试的两个至少一个为坏，所以未参加测试的一定为好的\n2. 第7点：由于题目**初始条件**，好的芯片一定比坏的芯片多\n\n\n### 1.42 时间复杂度分析\n设输入规模为n，，每轮淘汰后，芯片数至少减半，测试次数（含轮空处理）：O(n)\n\n时间复杂度：\n\nW(n) = W(n/2) + O(n)\nW(3)=1,W(2)=W(1)=0\n\n解上述方程的得：W(n) = O(n)\n\n> 结果很振奋人心，你已经将一个O(n^2)级别的算法优化为了O(n)O(n)O(n)级别!!!\n\n# 2. 总结\n最大的需要注意的地方就是：如何保证子问题与原问题性质相同:\n可以：\n1. 增加额外处理（比如上述n为奇数时对轮空数据的处理）\n2. 额外处理的工作量，不改变函数的阶\n```cpp\n  #include<iostream>\n  #include <cmath>\n  #include <stdio.h>\n  #include <time.h>\n  #include <stdlib.h>\n  #include <cstring>\n  #define MAX 100\n  using namespace std;\n\n  int main(){\n      int n;\n      int num1,num2,sum;\n      int a[MAX],b[MAX];\n      while(cin>>n){            \n          srand(time(NULL));\n          memset(a,0,sizeof(a));\n          memset(b,0,sizeof(b));\n          /*a数组标记芯片好坏，b数组记录被保留芯片编号*/\n          for(int i=1;i<=n;i++){                    \n              cin>>a[i];\n              b[i]=i;\n          }\n          num1=n;\n          num2=1;\n          sum=0; \n          while(1){\n              /*芯片只剩一片或两片则可以直接得到结果，结束循环*/\n              if(num1<=2)                   \n                  break;\n              else if(num1%2){     /*芯片个数为奇数*/\n                  for(int i=1;i<num1;i+=2){\n                      sum++;            /*记录查找次数*/\n                      if(a[b[i]]==1&&a[b[i+1]]==1)   /*两片芯片都是好的*/\n                          b[num2++]=b[i+rand()%2];\n                      /*两片芯片是坏的，rand模拟结果是好的这一随机现象*/\n                      if(a[b[i]]==0&&a[b[i+1]]==0&&rand()%2)                                               \n                        b[num2++]=b[i+rand()%2];\n                    }\n                    b[num2++]=b[num1];      /*最后一块芯片保留*/\n               }\n               else{                      /*芯片个数为偶数*/\n                   for(int i=1;i<=num1;i+=2){\n                      sum++;\n                      if(a[b[i]]==1&&a[b[i+1]]==1)   /*两片芯片都是好的*/\n                          b[num2++]=b[i+rand()%2];\n                      if(a[b[i]]==0&&a[b[i+1]]==0&&rand()%2)  /*两片芯片是坏的*/\n                         b[num2++]=b[i+rand()%2];\n                    }\n               }\n               num1=num2-1;     /*一次比较后保留芯片的个数*/\n               num2=1;          /*下一次查找的开始位置*/\n          }\n          cout<<\"查找次数：\"<<sum<<endl; \n          cout<<\"找到的芯片编号：\"<<b[1]<<endl; \n      }\n      return 0;\n  }\n```\n\n> 参考链接：https://www.jianshu.com/p/1cec17bfb2d5\n> 参考链接：https://blog.csdn.net/qq_37375427/article/details/102529005\n","tags":["算法","快速幂"],"categories":["MyTech","算法","分治"]},{"title":"分治 斐波那契矩阵快速幂","url":"/posts/2601188585/","content":"斐波那契数列通过矩阵快速幂递推关系如下：\n<!-- more -->\n![斐波那契数列](https://img-blog.csdnimg.cn/20200429190211691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200429191850697.png)\n不理解可以计算一遍，验证其正确性\n```cpp\n#include<iostream>\nusing namespace std;\n//定义矩阵结构体，同时定义两个全局变量\nstruct matrix{\n    int m[2][2];\n}ans,base;\n//矩阵的乘法\nmatrix multi(matrix a,matrix b){\n    matrix tmp;\n    for(int i=0;i<2;i++)\n        for(int j=0;j<2;j++){\n            tmp.m[i][j]=0;\n            for(int k=0;k<2;k++)\n                tmp.m[i][j] += a.m[i][k] * b.m[k][j];\n        }\n    return tmp;\n}\nint matrix_pow(int n){\n    // 1 1\n    // 1 0\n    // 基矩阵\n    base.m[0][0] = base.m[0][1] = base.m[1][0] = 1;\n    base.m[1][1] = 0;\n    ans.m[0][0] = ans.m[1][1] = 1;\n    ans.m[0][1] = ans.m[1][0] = 0;\n    while(n){\n        if(n&1){\n            ans = multi(ans,base);\n        }\n        base = multi(base,base);\n        n >>= 1;\n    }\n    return ans.m[1][0];\n}\nint main(){\n    int n;\n    while(cin>>n){\n        cout<<\"第\"<<n<<\"个斐波那契数列的值为：\"<<matrix_pow(n)<<\"\\n\";\n    }\n    return 0;\n}\n```\n代码**正确性**验证如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200429191724734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n\n---\n码字不易，觉得写的可以还请麻烦**关注**一下","tags":["算法","快速幂"],"categories":["MyTech","算法","分治"]},{"title":"王小波语录","url":"/posts/3453314697/","content":"\n1. 不愿清醒，宁愿一直沉迷放纵。\n  不知归路，宁愿一世无悔追逐。\n<!-- more -->\n2. 人的一切痛苦，本质上都是对自己的无能的愤怒。\n\n3. 我思故我在，既然我存在，就不能装作不存在。\n  无论如何，我要为自己负起责任。\n\n4. 一个人只有今生今世是不够的。\n  他还应当有诗意的世界。\n\n5. 我的勇气和你的勇气加起来，对付这个世界总够了吧？\n  去向世界发出我们的声音，我一个人是不敢的，有了你，我就敢。\n\n6. 什么样的灵魂就要什么样的养料，越悲怆的时候我越想嬉皮。\n\n7. 你要是愿意，我就永远爱你。\n  你要是不愿意，我就永远相思。\n\n8. 从话语中，你很少能学到人性，从沉默中却能。\n  假如还想学得更多，那就要继续一声不吭。\n\n9. 不管我本人多么平庸，我总觉得对你的爱很美。\n\n10. 深思熟虑的结果往往就是说不清楚。\n\n11. 人在年轻时，最头疼的一件事就是决定自己这一生要做什么。\n\n12. 活下去的诀窍是：保持愚蠢，又不能知道自己有多蠢。\n\n13. 一个人倘若需要从思想中得到快乐，那么他的第一个欲望就是学习。\n\n14. 一想起你，我这张丑脸上就泛起微笑。\n\n15. 我时常回到童年，用一片童心来思考问题，很多烦恼的问题就变得易解。\n\n16. 我对自己的要求很低：我活在世上，无非想要明白些道理，遇见些有趣的事。倘能如我愿，我的一生就算成功。\n\n17. 不相信世界就是这样，在明知道有的时候必须低头，有的人必将失去，有的东西命中注定不能长久的时候，依然要说，在第一千个选择之外，还有第一千零一个可能，有一扇窗等着我打开，然后有光透进来。\n\n18. 人在年轻的时候，觉得到处都是人，别人的事就是你的事，\n   到了中年以后，才觉得世界上除了家人已经一无所有。\n\n19. 人走茶凉伤感吗？不伤感！\n   真正伤感的是：人走了，却把我的茶杯也骗走了。\n\n20. 真实就是无法醒来。不管怎么哭喊怎么大闹，\n   就是无法从那样的梦中清醒过来，这就是现实！\n\n21. 绝望是无限的美好。\n\n22. 只有那些知道自己智慧一文不值的人，才是最有智慧的人。\n\n23. 所有无聊的事情都会衍生出很多细节让你觉得它复杂而有趣，\n\n   投入其中而浑然不知其无聊的本质。\n\n24. 你知道什么是天才的诀窍吗？\n\n    那就是永远只做一件事。\n\n25. 我相信这不是我一个人的经历：傍晚时分，你坐在屋檐下，\n    看着天慢慢的黑下去，心里寂寞而凄凉，感到自己的生命被剥夺了。\n    当时我是个年轻人，但我害怕这样生活下去，衰老下去。\n    在我看来，这是比死亡更可怕的事。\n\n    ​\n    ​\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["生活","读书"],"categories":["MyLife","阅读"]},{"title":"杀死一只知更鸟摘抄","url":"/posts/2715346686/","content":"\n1. 勇敢是，当你还未开始就已知道自己会输，可你依然要去做，而且无论如何都要把它坚持到底。\n<!-- more -->\n2. 你不可能真正了解谁，除非你进入他的鞋子，陪他走上一段。\n2. 我想让你见识一下什么是真正的勇敢，而不要错误地认为一个人手握枪支就是勇敢 。勇敢是：当你还未开始就已知道自己会输，可你依然要去做，而且无论如何都要把它坚持到底。你很少能赢，但有时也会。\n1. 去掉那些形容词剩下的就是真实了\n1. 我长大了要去当小丑，我对这世上的人除了大笑没什么可做的，干脆我就加入马戏团，笑他个痛快。\n1. 你太年轻，品不出我的话的味道。\n1. 有一种东西不能遵循从众原则，那就是人的良心。\n1. 我伸出舌头接住了一片雪，觉得它很烫。\n1. 追踪猎物时最好要沉着，什么话也不说，他肯定会感到奇怪而走出来的。\n1. 道理很简单，不能因为我们在此之前已经失败了一百年，就认为我们没有理由去争取胜利。\n1. 人之所以要呼吸是不得已，我读书也是这样。\n1. 我说很喜欢，其实是谎话，可是人在某种情况下不得不撒谎，而在无能为力的情况下老得撒谎。\n1. 可是，在这个国家里，有一种方式能够让一切人生来平等——有一种社会机构可以让乞丐平等于洛克菲勒，让蠢人平等于爱因斯坦，让无知的人平等于任何大学的校长。这种机构，先生们，就是法庭。\n1. 我从不喜欢阅读，直到我开始担心我会无法阅读。就像一个人从来不在意呼吸这件事。\n1. 大多数人都是好人，在你终于了解他们以后。\n1. 永远都不要从别人的口中去认识一个人，不要相信流言蜚语。\n1. 直到你亲自去接触他的时候，你才能够看见事实。\n1. 希望读完这本书的你，也能够告诉自己的孩子，要保持敬畏，那种男人对女人的敬畏，文明对自然的敬畏，有权力的人对没有权力的人的敬畏。\n1. 真正的勇敢不是你手握权力和武器，而是你知道什么是正义，并坚持不做不义的事。\n1. 孩子，被人加上有人认为是很难听的称号并不是侮辱。这只说明那个人太可怜了，对你并无损害。\n1. 知更鸟什么坏事都不做，只是衷心的唱歌给我们听，这就是为什么说杀死一只知更鸟就是罪恶。\n1. 我敢保证，在这个法庭上，没有谁没有撒过谎，没有谁没有做过不道德的事情！在这个世界上，没有一个男人不曾带着肉欲瞧过女人。\n1. 但是，在处理好与他人的关系之前，我首先得处理好与自己的关系。大多数人公认的准则是应当遵守的，但如果这样做违背了一个人的良心，就不应当遵守。只有在这种情况下才可以不遵守。\n1. 但是在我能和别人过得去之前，我首先要和自己过得去。有一种东西不能遵循从众原则，那就是人的良心。\n1. 我想让你了解了解她，让你见识见识真正的勇敢是什么，而不要总认为男子手里拿支枪才是勇敢。真正的勇敢是，在行动之前就知道要失败，但还是要行动，不管怎样，要进行到底。你往往失败，但有时候你也能取得胜利。\n1. “一个人没必要把自己懂的东西都展现出来。这不是淑女的做派——再说了，人们不喜欢他们身边有什么人比他们懂得多。这会让他们气不打一处来。你使用的语言再标准，也改变不了他们。除非他们自己想学，否则一点儿办法也没有。你要么闭上嘴巴，要么跟他们说一样的话。”\n1. 你只要明白这一件事，斯科特，你与形形色色的人都会交往得更好。你永远也无法真正理解一个人，直到你用他的眼睛来看世界……直到你钻进他的皮肤，和他一起走路。\n","tags":["生活","读书"],"categories":["MyLife","阅读"]},{"title":"高精度","url":"/posts/1237449692/","content":"\n\n[TOC]\n\n## 高精度\n\n### 高精度加法\n<!-- more -->\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nint a[10000],b[100000],c[100000],la,lb,lc;\n//1.字符串读入\n//2.字符串转数组\n//3.竖式加法\n//4.消前导0\n//5.倒序输出\nint main(){\n    cin>>x>>y;\n    la = x.length();\n    lb = y.length();\n    for(int i=0;i<la;i++){\n        a[la-i]=x[i]-'0';\n    }\n    for(int i=0;i<lb;i++){\n        b[lb-i]=y[i]-'0';\n    }\n    lc = max(la,lb);\n    for(int i=1;i<=lc;i++){\n        c[i]+=a[i]+b[i];\n        c[i+1] = c[i]/10;\n        c[i] %= 10;\n    }\n    if(c[lc+1]>0) lc++;\n    for(int i=lc;i>=1;i--)\n        cout<<c[i];\n}\n```\n\n### 高精度减法\n\n```c++\n#include<iostream>\nusing namespace std;\nstring x,y;\nint a[100005],b[100005],c[100005],la,lb;\nint main(){\n    cin>>x>>y;\n    la = x.length();\n    lb = y.length();\n    if(la<lb||la==lb&&x<y){\n        swap(x,y);\n        swap(la,lb);\n        cout<<'-';\n    }\n    for(int i=0;i<la;i++)\n        a[la-i] = x[i] - '0';\n    \n    for(int i=0;i<lb;i++)\n        b[lb-i] = y[i] - '0';\n    \n    for(int i=1;i<=la;i++){\n        if(a[i]<b[i]){\n            a[i]+=10;\n            a[i+1]--;\n        }\n        c[i]=a[i]-b[i];\n    }\n    while(c[la]==0&&la>1)\n        la--;\n    for(int i=la;i>=1;i--)\n        cout<<c[i];\n    return 0;\n}\n```\n\n### 高精度乘法\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nstring x,y;\nint a[100005],b[100005],c[100005],la,lb,lc;\nint main(){\n    cin>>x>>y;\n    la = x.length();\n    lb = y.length();\n    for(int i=0;i<la;i++){\n        a[la-i]=x[i]-'0';\n    }\n    for(int i=0;i<lb;i++){\n        b[lb-i]=y[i]-'0';\n    }\n    for(int i=1;i<=la;i++){\n        for(int j=1;j<=lb;j++){\n\t\t\tc[i+j-1] += a[i]*b[j];\n\t\t\tc[i+j] += c[i+j-1] / 10;\n\t\t\tc[i+j-1] %= 10;\n        }\n    }\n    lc = la+lb;\n    while(c[lc]==0&&lc>1){\n        lc--;\n    }\n    for(int i=lc;i>=1;i--){\n        cout<<c[i];\n    }\n    return 0;\n}\n```\n\n\n\n### B进制星球\n[原文题目](https://www.luogu.com.cn/problem/P1604)\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nstring x,y;\nint a[100005],b[100005],c[100005],la,lb,lc;\nint main(){\n    cin>>n>>x>>y;\n    la = x.length;\n    lb = y.length;\n    for(int i=0;i<la;i++){\n        if(x[i]>='A')\n            a[la-i]=x[i]-'A'+10;\n        else\n        \ta[la-i]=x[i]-'0';\n    }\n    for(int i=0;i<lb;i++){\n        if(y[i]>='A')\n            b[lb-i]=y[i]-'A'+10;\n        else\n        \tb[lb-i]=y[i]-'0';\n    }\n    lc = max(la,lb);\n    for(int i=1;i<=lc;i++){\n        c[i]+=a[i]+b[i];\n        //c[i+1]+=c[i]/10;\n        c[i+1]+=c[i]/n;\n        //c[i]%=10;\n        c[i]%=n;\n    }\n    if(c[lc+1]>0)lc++;\n    for(int i=lc;i>=1;i--){\n        if(c[i]>=10)\n            cout>>char(c[i]-10+'A');\n        else\n        \tcout>>c[i];\n    }\n    return 0;\n}\n```\n\n### 求余操作\n\n**题目描述**\n\n给你三个整数 b,p,k，求 b^p mod k。\n\n**输入格式**\n\n一行三个整数 b,p,kb,p,k\n\n**输出格式**\n\n输出 `b^p mod k=s`\n\ns 为运算结果\n\n**输入 #1**\n\n```\n 2 10 9\n\n```\n\n **输出 #1**\n\n```\n 2^10 mod 9=7\n```\n\n```c++\nint main()\n{\n    long long a,b,c;\n\tcin>>a>>b>>c;\n\tcout<<a<<\"^\"<<b<<\" mod \"<<c<<\"=\";\n\tint res = 1;\n\twhile(b){\n    \tif(b&1){\n        \tres = res*a%c;\n    \t}\n    \tb>>=1;\n    \ta = a*a%c;\n\t}\n\tcout<<res%c<<endl;\n}\n```\n\n### 迫害\n[题目原文](https://www.luogu.com.cn/problem/P6195)\n**题目描述**\n\n有 k个人，X 要对这 k 个人进行迫害。这 k 个人，每一个人都拥有一个数字，分别从 1 至 k。X 拥有 n+m 个数字，这些数字为 n 个 1 和 m 个大小可由 X 决定的数字（每个数字定好之后不能更换）。X 能对这些人进行迫害，当且仅当他能用手中若干个数的加和等于被迫害人的数字，一次迫害就成功了（不会消耗数字）。\n\n由于 X 的权利极大，又十分邪恶，他想要从第 11 个人开始**一个一个**进行迫害行动。由于小 Z 也在这个被迫害的行列里，他十分的慌张，希望你来告诉他 X 能最多能从第一个人开始连续迫害多少个人。由于被迫害的人太多了，所以请将答案对 1000000007 取模。\n\n**输入格式**\n\n第一行两个整数 n,m，表示 X 有 n个 1，有 m 个大小可自定的数。\n\n**输出格式**\n\n请你告诉小 Z，X 能迫害多少个人。\n\n**输入 #1**\n\n```\n1 2\n```\n\n**输出 #1**\n\n```\n7\n```\n\n**输入 #2**\n\n```\n2 2\n```\n\n**输出 #2** \n\n```\n11\n```\n\n```java\n/*题目是有规律的，答案是(n+1)(2^m-1)+n*/\nimport java.util.Scanner;\npublic class Main{\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n1 = sc.nextInt();\n        int n2 = sc.nextInt();\n        f(n1,n2);\n    }\n    public static void f(int n,int m){ \n        if(m==0){\n            System.out.println(n);\n            return ;\n        }\n        if(m==1){\n            System.out.println((2*n+1)%1000000007);\n            return ;\n        }\n        long tmp=2;//底数\n        long sum=1;\n        //求出2^m，快速幂\n        while(m!=0){\n            if((m&1)==1){\n                sum *= tmp;\n                sum%=1000000007;\n            }\n            tmp = (tmp*tmp)%1000000007;//tmp也需要%，否则可能会超出范围\n            m = m>>1;\n        }\n        sum = (sum-1)*(n+1)+n;\n        sum%=1000000007;\n        System.out.println(sum);\n    }\n}\n```","tags":["算法","高精度"],"categories":["MyTech","算法","高精度"]}]