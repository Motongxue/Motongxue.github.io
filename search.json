[{"title":"BF算法的实际应用 套汇","url":"/posts/69415872/","content":"如果**没接触过bf算法**，先看看它的介绍吧？\n[bellman ford算法百度百科介绍](https://baike.baidu.com/item/Bellman-Ford%E7%AE%97%E6%B3%95/1089090?fr=aladdin)\n<!-- more -->\n图中的加权有向边代表汇率，我们可以发现如果把 100 单位的货币 A 换成 B，再换成 C，最后换回 A，就可以得到 100×0.9×0.8×1.4 = 100.8 单位的 A！\n如果交易的金额大一些的话，赚的钱是很可观的，这种空手套白狼的操作就是套汇。\n现实中交易会有种种限制，而且市场瞬息万变，但是套汇的利润还是很高的，关键就在于如何快速找到这种套汇机会呢？\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200426112503124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n\n借助图的抽象，我们发现套汇机会其实就是一个环，且这个环上的权重之积大于 1，只要在顺着这个环交易一圈就能空手套白狼。\n图论中有一个经典算法叫做 **Bellman-Ford** 算法，可以用于**寻找负权重环**。对于我们说的套汇问题，可以先把所有边的权重 w 替换成 **-ln(w)**，这样「寻找权重乘积大于 1 的环」就转化成了「寻找权重和小于 0 的环」\n就可以使用 Bellman-Ford 算法在 O(EV) 的时间内寻找负权重环，也就是寻找套汇机会。\n\n---\n**Bellman-Ford 伪代码理解**\n```cpp\nbool Bellman-Ford(G,w,s)        //图G ，边集 函数 w ，s为源点\n  for each vertex v ∈ V(G):     //初始化距离源点距离均为无穷大\n    d[v] ←+∞\n  d[s] ←0                       //源点距离自身为0\n  for i = 1 → |V|:              //松弛操作需要重复多次\n    for each edge (u,v) ∈ E(G):\n      if d[v] > d[u] + w(u,v):\n        d[v] = d[u] + w(u,v)\n  for each edge(u,v) ∈ E(G):    //判断是否存在负权环路\n    if d[v] > d[u] + w(u,v):\n      return false\n  return true\n```\nSPFA实际上是用队列对bf的*优化*，思路差不多\n```cpp\nint SPFA(int s) {\n     queue<int> q; \n     bool inq[maxn] = {false}; \n     for(int i = 1; i <= N; i++) dis[i] = 2147483647; \n     dis[s] = 0; \n     q.push(s); inq[s] = true; \n     while(!q.empty()) { \n         int x = q.front(); q.pop(); \n         inq[x] = false;\n         for(int i = front[x]; i !=0 ; i = e[i].next) {\n             int k = e[i].v;\n             if(dis[k] > dis[x] + e[i].w) {\n                 dis[k] = dis[x] + e[i].w;\n                 if(!inq[k]) {\n                     inq[k] = true;\n                     q.push(k);\n                 }\n             }\n         }\n     }\n     for(int i =  1; i <= N; i++) cout << dis[i] << ' ';\n     cout << endl;\n     return 0;\n }\n```","tags":["图论","算法"],"categories":["mytech"]},{"title":"蓝桥杯 蚂蚁感冒","url":"/posts/1665851491/","content":"**蚂蚁感冒**\n时间限制：1000 ms  |  内存限制：65535 KB\n\n难度：2\n<!-- more -->\n**描述**\n\n长100厘米的细长直杆子上有n只蚂蚁。它们的头有的朝左，有的朝右。 每只蚂蚁都只能沿着杆子向前爬，速度是1厘米/秒。 当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。 这些蚂蚁中，有1只蚂蚁感冒了。并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。 请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。\n\n**输入**\n\n第一行输入一个整数n (1 < n < 50), 表示蚂蚁的总数。\n\n\n接着的一行是n个用空格分开的整数 Xi (-100 < Xi < 100), Xi的绝对值，表示蚂蚁离开杆子左边端点的距离。正值表示头朝右，负值表示头朝左，数据中不会出现0值，也不会出现两只蚂蚁占用同一位置。其中，第一个数据代表的蚂蚁感冒了。\n\n**输出**\n\n要求输出1个整数，表示最后感冒蚂蚁的数目。\n\n**样例输入**\n\n3\n5 -2 8\n5\n-10 8 -20 12 25\n**样例输出**\n\n1\n3\n\n\n乍一看还以为是一道模拟题，但是仔细想想可以发现出题者的小陷阱：蚂蚁碰面后会掉头。首先，哪有这么傻的蚂蚁，其次，这个掉头动作会让我们的逻辑变得混乱，因为谁也不知道什么时候会碰面，表面上看会无从下手，那么我们分析一下蚂蚁碰面后的状态。\n\n1.两只健康蚂蚁碰面后，两个方向都会有一只健康的蚂蚁在行走\n\n2.至少一只蚂蚁有病，两个方向都会有一只有病的蚂蚁在行走\n\n看出端倪了吧，其实蚂蚁碰面后根本没有必要掉头，或者说即使掉头，效果也是和不掉头一样的。\n\n明白了上面的，我知道，每只蚂蚁都会坚定不移的朝一个固定的方向走，下面看看第一只有病的蚂蚁，如果它初始向左走，那是不是它左边所有的向右走的蚂蚁都会遭殃？同样，当左边遭了秧的蚂蚁遇到了其右边向左走的蚂蚁，那么它们也会遭殃。\n\n存在一种特殊的情况，即所有的蚂蚁都朝一个方向走，那谁也不会被传染，最终只有一只蚂蚁有病。\n\n假设有病的蚂蚁是A，A左边向右走的蚂蚁数量为lf，A右边向左走的蚂蚁数量为rg，那么\n\n1.A向右走，且rg==0,；或者A向左走，且lf==0，ans=1；\n\n2.ans=lf+rg+1；\n```C++\n#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n \nstruct Ant\n{\n\tint pos;\n\tint dir;\n\tint cold;\t\n};\n \n \nint n,ans,lf,rg;\nAnt ant[60];\n \nbool cmp(const Ant a,const Ant b)\n{\n\treturn a.pos<b.pos;\n}\n \nint main()\n{\n\tint i,j;\n\tint len;\n\tint cold_ant;\n\twhile(~scanf(\"%d\",&n))\n\t{\n\t\tfor(i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&len);\n\t\tant[i].pos=abs(len);\n\t\tant[i].dir=len<0?-1:1;\n\t\tant[i].cold=0;\n\t}\n\tant[0].cold=1;\n\tlf=rg=0;\n\tsort(ant,ant+n,cmp);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tif(ant[i].cold==1)\n\t\t\tbreak;\n\t\tif(ant[i].dir>0)\n\t\t\tlf++;\n\t}\n\tcold_ant=i;\n\tfor(i=i+1;i<n;i++)\n\t{\n\t\tif(ant[i].dir<0)\n\t\t\trg++;\n\t}\n\tif((ant[cold_ant].dir>0&&rg==0)||(ant[cold_ant].dir<0&&lf==0))\n\t\tans=1;\n\telse\n\t\tans=lf+rg+1;\n\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}\n```\n\n","tags":["算法","蓝桥杯"],"categories":["mytech"]},{"title":"毕向东Java基础","url":"/posts/1544453252/","content":"Table of Contents\n\nJava基础知识精华部分\n<!-- more -->\n一：java概述：\n\n1，JDK：Java Development Kit，java的开发和运行环境，java的开发工具和jre。\n\n2，JRE：Java Runtime Environment，java程序的运行环境，java运行的所需的类库+JVM(java虚拟机)。\n\n3，配置环境变量：让java jdk\\bin目录下的工具，可以在任意目录下运行，原因是，将该工具所在目录告诉了系统，当使用该工具时，由系统帮我们去找指定的目录。\n\n4，javac命令和java命令做什么事情呢？\n\n二：java语法基础：\n\n1，关键字：其实就是某种语言赋予了特殊含义的单词。\n\n2，标示符：其实就是在程序中自定义的名词。比如类名，变量名，函数名。包含 0-9、a-z、$、_ ；\n\n3，常量：是在程序中的不会变化的数据。\n\n4，变量：其实就是内存中的一个存储空间，用于存储常量数据。\n\n什么时候定义变量？只要是数据不确定的时候，就定义变量。\n\n变量空间的开辟需要什么要素呢？\n\n变量的作用域和生存期:\n\n数据类型：\n\n运算符号：\n\n   5）、位运算符:用于操作二进制位的运算符。\n\n        5.1 移位操作符：\n\n        5.2 按位操作符\n\n   练习：对两个变量的数据进行互换。不需要第三方变量。\n\n5，语句。\n\n工作原理：用小括号中的变量的值依次和case后面的值进行对比，和哪个case后面的值相同了\n\n   while和for可以进行互换。\n\nbreak:作用于switch ，和循环语句，用于跳出，或者称为结束。\n\ncontinue:只作用于循环结构，继续循环用的。\n\n6，函 数：为了提高代码的复用性，可以将其定义成一个单独的功能，该功能的体现就是java中的函数。函数就是体现之一。\n\njava中的函数的定义格式：\n\nreturn的作用：结束函数。结束功能。\n\n如何定义一个函数？\n\n函数的作用：\n\n主函数：\n\n函数定义名称是为什么呢？\n\n重载\n\n7，数 组：\n\njava分了5片内存。\n\n三：面向对象：★★★★★\n\n特点：\n\n匿名对象使用场景：\n\nprivate\n\n类中怎么没有定义主函数呢？\n\n主函数的解释：保证所在类的独立运行，是程序的入口，被jvm调用。\n\n成员变量和局部变量的区别：\n\n构造函数：\n\n构造函数和一般函数有什么区别呢？\n\n什么时候使用构造函数呢？\n\n构造代码块和构造函数有什么区别？\n\n创建一个对象都在内存中做了什么事情？\n\n封 装（面向对象特征之一）：\n\nstatic：\n\n什么时候定义静态成员呢？或者说：定义成员时，到底需不需要被静态修饰呢？\n\n成员变量和静态变量的区别：\n\n静态的注意：静态的生命周期很长。\n\n生成Java帮助文档：\n\n设计模式\n\n单例设计模式：★★★★★\n\n继 承（面向对象特征之一）\n\n为什么不支持多继承呢？\n\n子父类出现后，类中的成员都有了哪些特点：\n\n发现子类构造函数运行时，先运行了父类的构造函数。为什么呢?\n\n为什么子类对象初始化时，都需要调用父类中的函数？(为什么要在子类构造函数的第一行加入这个super()?)\n\nsuper()或者this():为什么一定要定义在第一行？\n\n继承的细节：\n\n在方法覆盖时，注意两点：\n\nfinal特点：\n\n抽象类: abstract\n\n接 口：★★★★★\n\n接口都用于设计上，设计上的特点：（可以理解主板上提供的接口）\n\n抽象类与接口：\n\n多 态★★★★★（面向对象特征之一）\n\n多态的前提：\n\n多态在子父类中的成员上的体现的特点：\n\njava.lang.Object\n\n具体方法：\n\n1，boolean equals(Object obj)\n\n2，String toString()\n\n3，Class getClass()\n\n4，int hashCode()\n\n内部类\n\n当内部类定义在外部类中的成员位置上，可以使用一些成员修饰符修饰 private、static。\n\n为什么内部类可以直接访问外部类中的成员呢？\n\n匿名内部类的使用场景：\n\n异 常：★★★★\n\nthrow 和throws关键字的区别：\n\n异常分两种：\n\n编译时被检查的异常和运行时异常的区别：\n\n定义异常处理时，什么时候定义try，什么时候定义throws呢？\n\n自定义异常的步骤：\n\ntry  catch  finally的几种结合方式：\n\n常见异常：\n\n包：定义包用package关键字。包中可以还有包\n\n总结java中的四种权限：\n\n常见的软件包:\n\n多线程：★★★★\n\n进程\n\n线程\n\n随机性的原理\n\nstart方法：1）、启动了线程；2）、让jvm调用了run方法。\n\n创建线程的第一种方式：继承Thread ，由子类复写run方法。\n\n线程状态：\n\n创建线程的第二种方式：实现一个接口Runnable。\n\n为什么要有Runnable接口的出现？\n\n多线程安全问题的原因：\n\n解决安全问题的原理：\n\n同步：★★★★★\n\n同步函数是用的哪个锁呢？\n\n当同步函数被static修饰时，这时的同步用的是哪个锁呢？\n\n同步代码块和同步函数的区别？\n\n同步死锁\n\n线程间通信\n\n等待唤醒机制\n\n注意：\n\nwait和sleep区别\n\n线程的停止\n\nLock接口\n\nAPI\n\n--< java.lang >-- String字符串：★★★☆\n\n字符串的方法：\n\n--< java.lang >-- StringBuffer字符串缓冲区：★★★☆\n\n容器通常具备一些固定的方法：\n\n--< java.lang >-- StringBuilder字符串缓冲区：★★★☆//建议使用\n\n基本数据类型对象包装类\n\nInteger对象： ★★★☆\n\n集合框架：★★★★★，用于存储数据的容器。\n\n--< java.util >-- Collection接口：\n\n--< java.util >-- Iterator接口：\n\n--< java.util >-- List接口：\n\n可变长度数组的原理：\n\n--< java.util >-- Set接口：Set中的元素不能重复\n\n哈希表的原理：\n\nTreeSet:\n\nMap集合\n\nMap集合存储和Collection有着很大不同：\n\n访问map集合中所有元素\n\n有关于 map.entrySet() 和 keySet():\n\n使用集合的技巧：\n\nArrays：\n\n高级for循环可以遍历map集合吗\n\n可变参数（...）\n\n枚举：关键字 enum\n\n自动拆装箱\n\n泛型\n\n泛型中的通配符\n\n泛型限定：\n\n泛型的细节：\n\nAPI--- java.lang.System: 属性和行为都是静态的。\n\nAPI--- java.lang.Runtime: 类中没有构造方法，不能创建对象。\n\nAPI--- java.util.Math: 用于数学运算的工具类，属性和行为都是静态的。该类是final不允许继承。\n\nAPI--- java.util.Date：日期类，月份从0-11；\n\nAPI--- java.util. Calendar：日历类\n\nIO流：★★★★★，用于处理设备上数据。\n\n字节流\n\n字符流\n\nclose()和flush()的区别：\n\nFileWriter写入数据的细节：\n\nFileReader\n\nIO中的使用到了一个设计模式：装饰设计模式。灵活性较强\n\n字符流：\n\nReader\n\nWriter\n\n字节流：\n\nInputStream\n\nOutputStream\n\n缓冲区是提高效率用的，给谁提高呢？\n\nBufferedWriter\n\nBufferedReader：\n\n流对象\n\n转换流特有功能\n\nFile类\n\nFile类常见方法：\n\nJava.io.outputstream.PrintStream：打印流\n\nPrintWriter：具备了PrintStream的特点同时，还有自身特点：\n\nSequenceInputStream：序列流\n\nRandomAccessFile:\n\n管道流\n\n对象的序列化\n\nDataOutputStream、DataInputStream\n\nByteArrayInputStream：源：内存    ArrayStream\n\nByteArrayOutputStream：目的：内存。\n\n网络编程\n\nSocket：★★★★，套接字，通信的端点。\n\nUDP传输：\n\nudp的发送端：\n\nudp的接收端：\n\nTCP客户端：应先启动服务端\n\nTCP服务端：\n\n反射技术\n\n反射的基本步骤：\n\n反射的用法：\n\n正则表达式：★★★☆，其实是用来操作字符串的一些规则。\n\n组\n\n常见操作：\n\nJava基础知识精华部分\n写代码：\n1，明确需求。我要做什么？\n2，分析思路。我要怎么？1,2,3。\n3，确定步骤。每一个思路部分用到哪些语句，方法，和对象。\n4，代码实现。用具体的java语言代码把思路体现出来。\n学习新技术的四点：\n1，该技术是什么？\n2，该技术有什么特点(使用注意)：\n3，该技术怎么使用。demo\n4，该技术什么时候用？test。\n-----------------------------------------------------------------------------------------------\n一：java概述：\n1991 年Sun公司的James Gosling等人开始开发名称为 Oak 的语言，希望用于控制嵌入在有线电视交换盒、PDA等的微处理器；\n1994年将Oak语言更名为Java；\nJava的三种技术架构:\nJAVAEE：Java Platform Enterprise Edition，开发企业环境下的应用程序，主要针对web程序开发；\nJAVASE：Java Platform Standard Edition，完成桌面应用程序的开发，是其它两者的基础；\nJAVAME：Java Platform Micro Edition，开发电子消费产品和嵌入式设备，如手机中的程序；\n1，JDK：Java Development Kit，java的开发和运行环境，java的开发工具和jre。\n2，JRE：Java Runtime Environment，java程序的运行环境，java运行的所需的类库+JVM(java虚拟机)。\n3，配置环境变量：让java jdk\\bin目录下的工具，可以在任意目录下运行，原因是，将该工具所在目录告诉了系统，当使用该工具时，由系统帮我们去找指定的目录。\n环境变量的配置：\n   1）：永久配置方式：JAVA_HOME=%安装路径%\\Java\\jdk\n                     path=%JAVA_HOME%\\bin\n   2）：临时配置方式：set path=%path%;C:\\Program Files\\Java\\jdk\\bin\n特点：系统默认先去当前路径下找要执行的程序，如果没有，再去path中设置的路径下找。\nclasspath的配置:\n   1）：永久配置方式：classpath=.;c:\\;e:\\\n   2）：临时配置方式：set classpath=.;c:\\;e:\\\n注意：在定义classpath环境变量时，需要注意的情况\n如果没有定义环境变量classpath，java启动jvm后，会在当前目录下查找要运行的类文件；\n如果指定了classpath，那么会在指定的目录下查找要运行的类文件。\n还会在当前目录找吗？两种情况：\n   1）：如果classpath的值结尾处有分号，在具体路径中没有找到运行的类，会默认在当前目录再找一次。\n   2）：如果classpath的值结果出没有分号，在具体的路径中没有找到运行的类，不会再当前目录找。\n   一般不指定分号，如果没有在指定目录下找到要运行的类文件，就报错，这样可以调试程序。\n4，javac命令和java命令做什么事情呢？\n   要知道java是分两部分的：一个是编译，一个是运行。\n   javac：负责的是编译的部分，当执行javac时，会启动java的编译器程序。对指定扩展名的.java文件进行编译。 生成了jvm可以识别的字节码文件。也就是class文件，也就是java的运行程序。\n   java：负责运行的部分.会启动jvm.加载运行时所需的类库,并对class文件进行执行.\n   一个文件要被执行,必须要有一个执行的起始点,这个起始点就是main函数.\n\n\n二：java语法基础：\n1，关键字：其实就是某种语言赋予了特殊含义的单词。\n   保留字：其实就是还没有赋予特殊含义，但是准备日后要使用过的单词。\n2，标示符：其实就是在程序中自定义的名词。比如类名，变量名，函数名。包含 0-9、a-z、$、_ ；\n   注意：\n   1），数字不可以开头。\n   2），不可以使用关键字。\n3，常量：是在程序中的不会变化的数据。\n4，变量：其实就是内存中的一个存储空间，用于存储常量数据。\n   作用：方便于运算。因为有些数据不确定。所以确定该数据的名词和存储空间。\n   特点：变量空间可以重复使用。\n什么时候定义变量？只要是数据不确定的时候，就定义变量。\n变量空间的开辟需要什么要素呢？\n   1，这个空间要存储什么数据？数据类型。\n   2，这个空间叫什么名字啊？变量名称。\n   3，这个空间的第一次的数据是什么？ 变量的初始化值。\n变量的作用域和生存期:\n变量的作用域：\n   作用域从变量定义的位置开始，到该变量所在的那对大括号结束；\n生命周期：\n   变量从定义的位置开始就在内存中活了；\n   变量到达它所在的作用域的时候就在内存中消失了；\n数据类型：\n   1）：基本数据类型：byte、short、int、long、float、double、char、boolean\n   2）：引用数据类型: 数组、类、接口。\n级别从低到高为：byte,char,short(这三个平级)-->int-->float-->long-->double\n自动类型转换：从低级别到高级别，系统自动转的；\n强制类型转换：什么情况下使用?把一个高级别的数赋给一个别该数的级别低的变量；\n运算符号：\n   1）、算术运算符。\n       + - * / %   %:任何整数模2不是0就是1，所以只要改变被模数就可以实现开关运算。\n       +:连接符。\n       ++,--\n   2）、赋值运算符。\n       =  += -= *= /= %=\n   3）、比较运算符。\n       特点：该运算符的特点是：运算完的结果，要么是true，要么是false。\n   4）、逻辑运算符。\n       &  |  ^  !   &&   ||\n       逻辑运算符除了 !  外都是用于连接两个boolean类型表达式。\n       &: 只有两边都为true结果是true。否则就是false。\n       |:只要两边都为false结果是false，否则就是true\n       ^:异或：和或有点不一样。\n            两边结果一样，就为false。\n            两边结果不一样，就为true.\n       & 和 &&区别： & ：无论左边结果是什么，右边都参与运算。\n                    &&:短路与，如果左边为false，那么右边不参数与运算。\n       | 和|| 区别：|：两边都运算。\n                  ||：短路或，如果左边为true，那么右边不参与运算。\n   5）、位运算符:用于操作二进制位的运算符。\n       &  |  ^\n       <<  >>   >>>(无符号右移)\n\n        5.1 移位操作符：\n        \n                >>:右移，移出的高位补符号位\n            <<:左移，移出的低位补0\n            >>> :无符号右移，高位补0\n            int i = 13\n            00000000 00000000 00000000 00001101\n            13>>1 右移一位，高位补符号位，结果得6\n             0 00000000 00000000 00000000 0000110\n            13<<1 左移一位，低位直接补0，结果得26\n            0000000 00000000 00000000 00001101 0\n            int i =-13\n            先求：-13的补码\n            00000000 00000000 00000000 00001101 （绝对值的二进制）\n            取反加1后\n            11111111 11111111 11111111 11110011（-13的补码）\n            -13>>1 右移一位，高位补符号位.  \n             1 11111111 11111111 11111111 1111001\n            减1取反后（符号位不变）\n            1 00000000 00000000 00000000 0000111\n            最终结果得：-7\n            如果：-13>>>1 无符号右移一位，高位补0.  \n            0 11111111 11111111 11111111 1111001\n            ---------------------\n            面试题：\n            以最快的速度算出8*2或者8/2的结果?\n            8<<1\n            8>>1\n            int r = 8*2 //用到很多块内存，所以慢。\n        5.2 按位操作符\n            \n            &:按位与 ： 见0为0，全1为1\n            |:按位或，见1为1，全0为0\n            ^:按位异或，相同为0，相异为1\n            ~:取反，原来为1变为0，原来为0变为1\n\n            \n            使用的一些例子：\n            1 任何一个数异或同一个数2次得到自身，可以用做简单加密器\n\n\n   练习：对两个变量的数据进行互换。不需要第三方变量。\n           int a  = 3,b = 5;-->b = 3,a = 5;\n           a = a + b; a = 8;\n           b = a - b; b = 3;c\n           a = a - b; a = 5;\n           a = a ^ b;//\n           b = a ^ b;//b = a ^ b ^ b = a\n           a = a ^ b;//a = a ^ b ^ a = b;\n       练习：高效的算出 2*8 = 2<<3;\n5，语句。\n   If  switch  do while   while  for\n   这些语句什么时候用？\n   1）、当判断固定个数的值的时候，可以使用if，也可以使用switch。\n   但是建议使用switch，效率相对较高。\nswitch(变量){\n  case 值:要执行的语句;break;\n  …\n  default:要执行的语句;\n}\n工作原理：用小括号中的变量的值依次和case后面的值进行对比，和哪个case后面的值相同了\n          就执行哪个case后面的语句，如果没有相同的则执行default后面的语句；\n细节：1）：break是可以省略的，如果省略了就一直执行到遇到break为止；\n      2）：switch 后面的小括号中的变量应该是byte,char,short,int四种类型中的一种；\n      3）：default可以写在switch结构中的任意位置；如果将default语句放在了第一行，则不管expression与case中的value是否匹配，程序会从default开始执行直到第一个break出现。\n   2）、当判断数据范围，获取判断运算结果boolean类型时，需要使用if。\n   3）、当某些语句需要执行很多次时，就用循环结构。\n   while和for可以进行互换。\n   区别在于：如果需要定义变量控制循环次数。建议使用for。因为for循环完毕，变量在内存中释放。\nbreak:作用于switch ，和循环语句，用于跳出，或者称为结束。\nbreak语句单独存在时，下面不要定义其他语句，因为执行不到，编译会失败。当循环嵌套时，break只跳出当前所在循环。要跳出嵌套中的外部循环，只要给循环起名字即可，这个名字称之为标号。\ncontinue:只作用于循环结构，继续循环用的。\n作用：结束本次循环，继续下次循环。该语句单独存在时，下面不可以定义语句，执行不到。\n6，函 数：为了提高代码的复用性，可以将其定义成一个单独的功能，该功能的体现就是java中的函数。函数就是体现之一。\njava中的函数的定义格式：\n   修饰符 返回值类型 函数名(参数类型 形式参数1，参数类型 形式参数1，…){\n      执行语句；\n      return 返回值；\n   }\n当函数没有具体的返回值时，返回的返回值类型用void关键字表示。\n如果函数的返回值类型是void时，return语句可以省略不写的，系统会帮你自动加上。\nreturn的作用：结束函数。结束功能。\n如何定义一个函数？\n   函数其实就是一个功能，定义函数就是实现功能，通过两个明确来完成：\n   1）、明确该功能的运算完的结果，其实是在明确这个函数的返回值类型。\n   2）、在实现该功能的过程中是否有未知内容参与了运算，其实就是在明确这个函数的参数列表(参数类型&参数个数)。\n函数的作用：\n1）、用于定义功能。\n2）、用于封装代码提高代码的复用性。\n注意：函数中只能调用函数，不能定义函数。\n主函数：\n   1）、保证该类的独立运行。\n   2）、因为它是程序的入口。\n   3）、因为它在被jvm调用。\n函数定义名称是为什么呢？\n答：1）、为了对该功能进行标示，方便于调用。\n   2）、为了通过名称就可以明确函数的功能，为了增加代码的阅读性。\n重载\n定义是：在一个类中，如果出现了两个或者两个以上的同名函数，只要它们的参数的个数，或者参数的类型不同，即可称之为该函数重载了。\n如何区分重载：\n当函数同名时，只看参数列表。和返回值类型没关系。\n7，数 组：\n用于存储同一类型数据的一个容器。好处：可以对该容器中的数据进行编号，从0开始。数组用于封装数据，就是一个具体的实体。\n如何在java中表现一个数组呢？两种表现形式。\n1）、元素类型[] 变量名 = new 元素类型[元素的个数]；\n2）、元素类型[] 变量名 = {元素1，元素2...}；\n元素类型[] 变量名 = new 元素类型[]{元素1，元素2...}；\n\n//二分查找法。必须有前提：数组中的元素要有序。\n   public static int halfSeach_2(int[] arr,int key){\n       int min,max,mid;//定义最小，最大，中间数\n       min = 0;//最小为0\n       max = arr.length-1;// 最大为数组的长度-1\n       mid = (max+min)>>1; //(max+min)/2;//中间数为最大加最小除以2\n       while(arr[mid]!=key){//如果数组中間值不等于key\n           if(key>arr[mid]){//如果key>中間值\n               min = mid + 1;\n           }\n           else if(key<arr[mid])\n               max = mid - 1;\n           if(max<min)\n               return -1;\n           mid = (max+min)>>1;\n       }\n       return mid;\n   }\n\n\n\njava分了5片内存。\n1：寄存器。2：本地方法区。3：方法区。4：栈。5：堆。\n栈：存储的都是局部变量 ( 函数中定义的变量，函数上的参数，语句中的变量 )；\n   只要数据运算完成所在的区域结束，该数据就会被释放。\n堆：用于存储数组和对象，也就是实体。啥是实体啊？就是用于封装多个数据的。\n1：每一个实体都有内存首地址值。\n2：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。\n3：垃圾回收机制。\n\n\n\n三：面向对象：★★★★★\n特点：\n1：将复杂的事情简单化。\n2：面向对象将以前的过程中的执行者，变成了指挥者。\n3：面向对象这种思想是符合现在人们思考习惯的一种思想。\n过程和对象在我们的程序中是如何体现的呢？过程其实就是函数；对象是将函数等一些内容进行了封装。\n匿名对象使用场景：\n1：当对方法只进行一次调用的时候，可以使用匿名对象。\n2：当对象对成员进行多次调用时，不能使用匿名对象。必须给对象起名字。\n在类中定义其实都称之为成员。成员有两种：\n1：成员变量：其实对应的就是事物的属性。\n2：成员函数：其实对应的就是事物的行为。\n\n所以，其实定义类，就是在定义成员变量和成员函数。但是在定义前，必须先要对事物进行属性和行为的分析，才可以用代码来体现。\n\nprivate\nint age;//私有的访问权限最低，只有在本类中的访问有效。\n注意：私有仅仅是封装的一种体现形式而已。\n私有的成员：其他类不能直接创建对象访问，所以只有通过本类对外提供具体的访问方式来完成对私有的访问，可以通过对外提供函数的形式对其进行访问。\n好处：可以在函数中加入逻辑判断等操作，对数据进行判断等操作。\n总结：开发时，记住，属性是用于存储数据的，直接被访问，容易出现安全隐患，所以，类中的属性通常被私有化，并对外提供公共的访问方法。\n这个方法一般有两个，规范写法：对于属性 xxx，可以使用setXXX(),getXXX()对其进行操作。\n类中怎么没有定义主函数呢？\n注意：主函数的存在，仅为该类是否需要独立运行，如果不需要，主函数是不用定义的。\n主函数的解释：保证所在类的独立运行，是程序的入口，被jvm调用。\n成员变量和局部变量的区别：\n1：成员变量直接定义在类中。\n  局部变量定义在方法中，参数上，语句中。\n2：成员变量在这个类中有效。\n局部变量只在自己所属的大括号内有效，大括号结束，局部变量失去作用域。\n3：成员变量存在于堆内存中，随着对象的产生而存在，消失而消失。\n局部变量存在于栈内存中，随着所属区域的运行而存在，结束而释放。\n\n构造函数：\n用于给对象进行初始化，是给与之对应的对象进行初始化，它具有针对性，函数中的一种。\n特点：\n1：该函数的名称和所在类的名称相同。\n2：不需要定义返回值类型。\n3：该函数没有具体的返回值。\n记住：所有对象创建时，都需要初始化才可以使用。\n注意事项：一个类在定义时，如果没有定义过构造函数，那么该类中会自动生成一个空参数的构造函数，为了方便该类创建对象，完成初始化。如果在类中自定义了构造函数，那么默认的构造函数就没有了。\n一个类中，可以有多个构造函数，因为它们的函数名称都相同，所以只能通过参数列表来区分。所以，一个类中如果出现多个构造函数。它们的存在是以重载体现的。\n构造函数和一般函数有什么区别呢？\n1：两个函数定义格式不同。\n2：构造函数是在对象创建时，就被调用，用于初始化，而且初始化动作只执行一次。\n   一般函数，是对象创建后，需要调用才执行，可以被调用多次。\n\n什么时候使用构造函数呢？\n分析事物时，发现具体事物一出现，就具备了一些特征，那就将这些特征定义到构造函数内。\n构造代码块和构造函数有什么区别？\n构造代码块：是给所有的对象进行初始化，也就是说，所有的对象都会调用一个代码块。只要对象一建立。就会调用这个代码块。\n构造函数：是给与之对应的对象进行初始化。它具有针对性。\nPerson p = new Person();\n创建一个对象都在内存中做了什么事情？\n    1：先将硬盘上指定位置的Person.class文件加载进内存。\n    2：执行main方法时，在栈内存中开辟了main方法的空间(压栈-进栈)，然后在main方法的栈区分配了一个变量p。\n    3：在堆内存中开辟一个实体空间，分配了一个内存首地址值。new\n    4：在该实体空间中进行属性的空间分配，并进行了默认初始化。\n    5：对空间中的属性进行显示初始化。\n    6：进行实体的构造代码块初始化。\n    7：调用该实体对应的构造函数，进行构造函数初始化。（）\n    8：将首地址赋值给p ，p变量就引用了该实体。(指向了该对象)\n\n\n封 装（面向对象特征之一）：\n是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。\n好处：将变化隔离；便于使用；提高重用性；安全性。\n封装原则：将不需要对外提供的内容都隐藏起来，把属性都隐藏，提供公共方法对其访问。\nthis:代表对象。就是所在函数所属对象的引用。\nthis到底代表什么呢？哪个对象调用了this所在的函数，this就代表哪个对象，就是哪个对象的引用。\n开发时，什么时候使用this呢？\n在定义功能时，如果该功能内部使用到了调用该功能的对象，这时就用this来表示这个对象。\nthis 还可以用于构造函数间的调用。\n调用格式：this(实际参数)；\nthis对象后面跟上 .  调用的是成员属性和成员方法(一般方法)；\nthis对象后面跟上 () 调用的是本类中的对应参数的构造函数。\n注意：用this调用构造函数，必须定义在构造函数的第一行。因为构造函数是用于初始化的，所以初始化动作一定要执行。否则编译失败。\nstatic：\n★★★ 关键字，是一个修饰符，用于修饰成员(成员变量和成员函数)。\n特点：\n1，想要实现对象中的共性数据的对象共享。可以将这个数据进行静态修饰。\n2，被静态修饰的成员，可以直接被类名所调用。也就是说，静态的成员多了一种调用方式。类名.静态方式。\n3，静态随着类的加载而加载。而且优先于对象存在。\n弊端：\n1，有些数据是对象特有的数据，是不可以被静态修饰的。因为那样的话，特有数据会变成对象的共享数据。这样对事物的描述就出了问题。所以，在定义静态时，必须要明确，这个数据是否是被对象所共享的。\n2，静态方法只能访问静态成员，不可以访问非静态成员。\n因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。\n3，静态方法中不能使用this，super关键字。\n因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。\n4，主函数是静态的。\n什么时候定义静态成员呢？或者说：定义成员时，到底需不需要被静态修饰呢？\n成员分两种：\n1，成员变量。（数据共享时静态化）\n该成员变量的数据是否是所有对象都一样：\n如果是，那么该变量需要被静态修饰，因为是共享的数据。\n如果不是，那么就说这是对象的特有数据，要存储到对象中。\n2，成员函数。（方法中没有调用特有数据时就定义成静态）\n   如果判断成员函数是否需要被静态修饰呢？\n   只要参考，该函数内是否访问了对象中的特有数据：\n   如果有访问特有数据，那方法不能被静态修饰。\n   如果没有访问过特有数据，那么这个方法需要被静态修饰。\n成员变量和静态变量的区别：\n1，成员变量所属于对象。所以也称为实例变量。\n静态变量所属于类。所以也称为类变量。\n2，成员变量存在于堆内存中。\n静态变量存在于方法区中。\n3，成员变量随着对象创建而存在。随着对象被回收而消失。\n静态变量随着类的加载而存在。随着类的消失而消失。\n4，成员变量只能被对象所调用 。\n静态变量可以被对象调用，也可以被类名调用。\n所以，成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。\n静态的注意：静态的生命周期很长。\n静态代码块：就是一个有静态关键字标示的一个代码块区域。定义在类中。\n作用：可以完成类的初始化。静态代码块随着类的加载而执行，而且只执行一次（new 多个对象就只执行一次）。如果和主函数在同一类中，优先于主函数执行。\nPublic：访问权限最大。\nstatic：不需要对象，直接类名即可。\nvoid：主函数没有返回值。\nMain：主函数特定的名称。\n(String[] args)：主函数的参数，是一个字符串数组类型的参数，jvm调用main方法时，传递的实际参数是 new String[0]。\njvm默认传递的是长度为0的字符串数组，我们在运行该类时，也可以指定具体的参数进行传递。可以在控制台，运行该类时，在后面加入参数。参数之间通过空格隔开。jvm会自动将这些字符串参数作为args数组中的元素，进行存储。\n静态代码块、构造代码块、构造函数同时存在时的执行顺序：静态代码块 à 构造代码块 à 构造函数；\n生成Java帮助文档：\n命令格式：javadoc –d 文件夹名 –auther –version *.java\n/**     //格式\n*类描述\n*@author 作者名\n*@version 版本号\n*/\n/**\n*方法描述\n*@param  参数描述\n*@return  返回值描述\n*/\n\n\n\n\n设计模式\n解决问题最行之有效的思想。是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。\njava中有23种设计模式：\n单例设计模式：★★★★★\n解决的问题：保证一个类在内存中的对象唯一性。\n比如：多程序读取一个配置文件时，建议配置文件封装成对象。会方便操作其中数据，又要保证多个程序读到的是同一个配置文件对象，就需要该配置文件对象在内存中是唯一的。\nRuntime()方法就是单例设计模式进行设计的。\n如何保证对象唯一性呢？\n思想：\n1，不让其他程序创建该类对象。\n2，在本类中创建一个本类对象。\n3，对外提供方法，让其他程序获取这个对象。\n步骤：\n1，因为创建对象都需要构造函数初始化，只要将本类中的构造函数私有化，其他程序就无法再创建该类对象；\n2，就在类中创建一个本类的对象；\n3，定义一个方法，返回该对象，让其他程序可以通过方法就得到本类对象。（作用：可控）\n代码体现：\n1，私有化构造函数；\n2，创建私有并静态的本类对象；\n3，定义公有并静态的方法，返回该对象。\n//饿汉式\nclass Single{\n   private Single(){} //私有化构造函数。\nprivate static Single s = new Single(); //创建私有并静态的本类对象。\n   public static Single getInstance(){ //定义公有并静态的方法，返回该对象。\n       return s;\n   }\n}\n---------------------------------------------\n//懒汉式:延迟加载方式。\nclass Single2{\n   private Single2(){}\nprivate static Single2 s = null;\n   public static Single2 getInstance(){\n       if(s==null)\n           s = new Single2();\n       return s;\n   }\n}\n继 承（面向对象特征之一）\n好处：\n1：提高了代码的复用性。\n2：让类与类之间产生了关系，提供了另一个特征多态的前提。\n父类的由来：其实是由多个类不断向上抽取共性内容而来的。\njava中对于继承，java只支持单继承。java虽然不直接支持多继承，但是保留了这种多继承机制，进行改良。\n单继承：一个类只能有一个父类。\n多继承：一个类可以有多个父类。\n为什么不支持多继承呢？\n因为当一个类同时继承两个父类时，两个父类中有相同的功能，那么子类对象调用该功能时，运行哪一个呢？因为父类中的方法中存在方法体。\n但是java支持多重继承。A继承B  B继承C  C继承D。\n多重继承的出现，就有了继承体系。体系中的顶层父类是通过不断向上抽取而来的。它里面定义的该体系最基本最共性内容的功能。\n所以，一个体系要想被使用，直接查阅该系统中的父类的功能即可知道该体系的基本用法。那么想要使用一个体系时，需要建立对象。建议建立最子类对象，因为最子类不仅可以使用父类中的功能。还可以使用子类特有的一些功能。\n简单说：对于一个继承体系的使用，查阅顶层父类中的内容，创建最底层子类的对象。\n子父类出现后，类中的成员都有了哪些特点：\n1：成员变量。\n    当子父类中出现一样的属性时，子类类型的对象，调用该属性，值是子类的属性值。\n    如果想要调用父类中的属性值，需要使用一个关键字：super\n    This：代表是本类类型的对象引用。\n    Super：代表是子类所属的父类中的内存空间引用。\n    注意：子父类中通常是不会出现同名成员变量的，因为父类中只要定义了，子类就不用在定义了，直接继承过来用就可以了。\n2：成员函数。\n当子父类中出现了一模一样的方法时，建立子类对象会运行子类中的方法。好像父类中的方法被覆盖掉一样。所以这种情况，是函数的另一个特性：覆盖(复写，重写)\n什么时候使用覆盖呢？当一个类的功能内容需要修改时，可以通过覆盖来实现。\n3：构造函数。\n发现子类构造函数运行时，先运行了父类的构造函数。为什么呢?\n\n原因：子类的所有构造函数中的第一行，其实都有一条隐身的语句super();\nsuper(): 表示父类的构造函数，并会调用于参数相对应的父类中的构造函数。而super():是在调用父类中空参数的构造函数。\n为什么子类对象初始化时，都需要调用父类中的函数？(为什么要在子类构造函数的第一行加入这个super()?)\n\n因为子类继承父类，会继承到父类中的数据，所以必须要看父类是如何对自己的数据进行初始化的。所以子类在进行对象初始化时，先调用父类的构造函数，这就是子类的实例化过程。\n\n注意：子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super();\n如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。\n如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。\n问题：super()和this()是否可以同时出现的构造函数中。\n两个语句只能有一个定义在第一行，所以只能出现其中一个。\n\nsuper()或者this():为什么一定要定义在第一行？\n因为super()或者this()都是调用构造函数，构造函数用于初始化，所以初始化的动作要先完成。\n继承的细节：\n什么时候使用继承呢？\n当类与类之间存在着所属关系时，才具备了继承的前提。a是b中的一种。a继承b。狼是犬科中的一种。\n英文书中，所属关系：\" is a \"\n注意：不要仅仅为了获取其他类中的已有成员进行继承。\n所以判断所属关系，可以简单看，如果继承后，被继承的类中的功能，都可以被该子类所具备，那么继承成立。如果不是，不可以继承。\n细节二：\n在方法覆盖时，注意两点：\n1：子类覆盖父类时，必须要保证，子类方法的权限必须大于等于父类方法权限可以实现继承（public>protected>default>private）。否则，编译失败。\n2：覆盖时，要么都静态，要么都不静态。 (静态只能覆盖静态，或者被静态覆盖)\n继承的一个弊端：打破了封装性。对于一些类，或者类中功能，是需要被继承，或者复写的。\n这时如何解决问题呢？介绍一个关键字，final:最终。\nfinal特点：\n1：这个关键字是一个修饰符，可以修饰类，方法，变量。\n2：被final修饰的类是一个最终类，不可以被继承。\n3：被final修饰的方法是一个最终方法，不可以被覆盖。\n4：被final修饰的变量是一个常量，只能赋值一次。\n   其实这样的原因的就是给一些固定的数据起个阅读性较强的名称。\n   不加final修饰不是也可以使用吗？那么这个值是一个变量，是可以更改的。加了final，程序更为严谨。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 _ 连接。\n抽象类: abstract\n抽象：不具体，看不明白。抽象类表象体现。\n在不断抽取过程中，将共性内容中的方法声明抽取，但是方法不一样，没有抽取，这时抽取到的方法，并不具体，需要被指定关键字abstract所标示，声明为抽象方法。\n抽象方法所在类一定要标示为抽象类，也就是说该类需要被abstract关键字所修饰。\n抽象类的特点：\n1：抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。\n2：抽象方法只定义方法声明，并不定义方法实现。\n3：抽象类不可以被创建对象(实例化)。\n4：只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。\n抽象类的细节：\n1：抽象类中是否有构造函数？有，用于给子类对象进行初始化。\n2：抽象类中是否可以定义非抽象方法？\n   可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。只不过，比一般类多了一个抽象函数。而且比一般类少了一个创建对象的部分。\n3：抽象关键字abstract和哪些不可以共存？final ,   private , static\n4：抽象类中可不可以不定义抽象方法？可以。抽象方法目的仅仅为了不让该类创建对象。\n模板方法设计模式：\n解决的问题：当功能内部一部分实现时确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。\nabstract class GetTime{\n   public final void getTime(){ //此功能如果不需要复写，可加final限定\n       long start = System.currentTimeMillis();\n       code(); //不确定的功能部分，提取出来，通过抽象方法实现\n       long end = System.currentTimeMillis();\n       System.out.println(\"毫秒是：\"+(end-start));\n   }\n   public abstract void code(); //抽象不确定的功能，让子类复写实现\n}\nclass SubDemo extends GetTime{\n   public void code(){ //子类复写功能方法\n       for(int y=0; y<1000; y++){\n           System.out.println(\"y\");\n       }\n   }\n}\n接 口：★★★★★\n1：是用关键字interface定义的。\n2：接口中包含的成员，最常见的有全局常量、抽象方法。\n注意：接口中的成员都有固定的修饰符。\n\n   成员变量：public static final\n   成员方法：public abstract\ninterface Inter{\n   public static final int x = 3;\n   public abstract void show();\n}\n3：接口中有抽象方法，说明接口不可以实例化。接口的子类必须实现了接口中所有的抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。\n\n4：类与类之间存在着继承关系，类与接口中间存在的是实现关系。\n   继承用extends  ；实现用implements ；\n5：接口和类不一样的地方，就是，接口可以被多实现，这就是多继承改良后的结果。java将多继承机制通过多现实来体现。\n6：一个类在继承另一个类的同时，还可以实现多个接口。所以接口的出现避免了单继承的局限性。还可以将类进行功能的扩展。\n7：其实java中是有多继承的。接口与接口之间存在着继承关系，接口可以多继承接口。\n接口都用于设计上，设计上的特点：（可以理解主板上提供的接口）\n1：接口是对外提供的规则。\n2：接口是功能的扩展。\n3：接口的出现降低了耦合性。\n抽象类与接口：\n抽象类：一般用于描述一个体系单元，将一组共性内容进行抽取，特点：可以在类中定义抽象内容让子类实现，可以定义非抽象内容让子类直接使用。它里面定义的都是一些体系中的基本内容。\n接口：一般用于定义对象的扩展功能，是在继承之外还需这个对象具备的一些功能。\n抽象类和接口的共性：都是不断向上抽取的结果。\n抽象类和接口的区别：\n1：抽象类只能被继承，而且只能单继承。\n接口需要被实现，而且可以多实现。\n2：抽象类中可以定义非抽象方法，子类可以直接继承使用。\n接口中都有抽象方法，需要子类去实现。\n3：抽象类使用的是  is a 关系。\n接口使用的 like a 关系。\n4：抽象类的成员修饰符可以自定义。\n接口中的成员修饰符是固定的。全都是public的。在开发之前，先定义规则，A和B分别开发，A负责实现这个规则，B负责使用这个规则。至于A是如何对规则具体实现的，B是不需要知道的。这样这个接口的出现就降低了A和B直接耦合性。\n\n\n多 态★★★★★（面向对象特征之一）\n函数本身就具备多态性，某一种事物有不同的具体的体现。\n体现：父类引用或者接口的引用指向了自己的子类对象。//Animal a = new Cat();\n多态的好处：提高了程序的扩展性。\n多态的弊端：当父类引用指向子类对象时，虽然提高了扩展性，但是只能访问父类中具备的方法，不可以访问子类中特有的方法。(前期不能使用后期产生的功能，即访问的局限性)\n多态的前提：\n   1：必须要有关系，比如继承、或者实现。\n   2：通常会有覆盖操作。\n多态的出现思想上也做着变化：以前是创建对象并指挥对象做事情。有了多态以后，我们可以找到对象的共性类型，直接操作共性类型做事情即可，这样可以指挥一批对象做事情，即通过操作父类或接口实现。\nclass 毕姥爷{\n   void 讲课(){\n       System.out.println(\"企业管理\");\n   }\n   void 钓鱼(){\n       System.out.println(\"钓鱼\");\n   }\n}\nclass 毕老师 extends 毕姥爷{\n   void 讲课(){\n       System.out.println(\"JAVA\");\n   }\n   void 看电影(){\n       System.out.println(\"看电影\");\n   }\n}\nclass {\n   public static void main(String[] args) {\n       毕姥爷 x = new 毕老师(); //毕老师对象被提升为了毕姥爷类型。\n//      x.讲课();\n//      x.看电影(); //错误.\n       毕老师 y = (毕老师)x; //将毕姥爷类型强制转换成毕老师类型。\n       y.看电影();//在多态中，自始自终都是子类对象在做着类型的变化。\n   }\n}\n如果想用子类对象的特有方法，如何判断对象是哪个具体的子类类型呢？\n\n可以可以通过一个关键字 instanceof ;//判断对象是否实现了指定的接口或继承了指定的类\n格式：<对象 instanceof 类型> ，判断一个对象是否所属于指定的类型。\nStudent instanceof Person = true;//student继承了person类\n多态在子父类中的成员上的体现的特点：\n1，成员变量：在多态中，子父类成员变量同名。\n   在编译时期：参考的是引用型变量所属的类中是否有调用的成员。（编译时不产生对象，只检查语法错误）\n   运行时期：也是参考引用型变量所属的类中是否有调用的成员。\n   简单一句话：无论编译和运行，成员变量参考的都是引用变量所属的类中的成员变量。\n   再说的更容易记忆一些：成员变量 --- 编译运行都看 = 左边。\n2，成员函数。\n   编译时期：参考引用型变量所属的类中是否有调用的方法。\n   运行事情：参考的是对象所属的类中是否有调用的方法。\n   为什么是这样的呢？因为在子父类中，对于一模一样的成员函数，有一个特性：覆盖。\n   简单一句：成员函数，编译看引用型变量所属的类，运行看对象所属的类。\n   更简单：成员函数 --- 编译看 = 左边，运行看 = 右边。\n3，静态函数。\n   编译时期：参考的是引用型变量所属的类中是否有调用的成员。\n   运行时期：也是参考引用型变量所属的类中是否有调用的成员。\n   为什么是这样的呢？因为静态方法，其实不所属于对象，而是所属于该方法所在的类。\n   调用静态的方法引用是哪个类的引用调用的就是哪个类中的静态方法。   简单说：静态函数 --- 编译运行都看 = 左边。\n\n\njava.lang.Object\nObject：所有类的直接或者间接父类，Java认为所有的对象都具备一些基本的共性内容，这些内容可以不断的向上抽取，最终就抽取到了一个最顶层的类中的，该类中定义的就是所有对象都具备的功能。\n具体方法：\n1，boolean equals(Object obj)\n用于比较两个对象是否相等，其实内部比较的就是两个对象地址。\n而根据对象的属性不同，判断对象是否相同的具体内容也不一样。所以在定义类时，一般都会复写equals方法，建立本类特有的判断对象是否相同的依据。\n public boolean equals(Object obj){\n     if(!(obj instanceof Person))\n         return false;\n     Person p = (Person)obj;\n     return this.age == p.age;\n }\n2，String toString()\n将对象变成字符串；默认返回的格式：类名@哈希值 = getClass().getName() + '@' + Integer.toHexString(hashCode())\n如果直接打印对象的调用，会默认调用toString方法。\n 为了对象对应的字符串内容有意义，可以通过复写，建立该类对象自己特有的字符串表现形式。\n public String toString(){\n     return \"person : \"+age;\n }\n\n\n3，Class getClass()\n获取任意对象运行时的所属字节码文件对象。\n4，int hashCode()\n返回该对象的哈希码值。支持此方法是为了提高哈希表的性能。\n通常equals，toString，hashCode，在应用中都会被复写，建立具体对象的特有的内容。\n\n\n内部类\n如果A类需要直接访问B类中的成员，而B类又需要建立A类的对象。这时,为了方便设计和访问，直接将A类定义在B类中。就可以了。A类就称为内部类。内部类可以直接访问外部类中的成员。而外部类想要访问内部类，必须要建立内部类的对象。\nclass Outer{\n   int num = 4;    \n   class  Inner {\n       void show(){\n           System.out.println(\"inner show run \"+num);        \n       }\n   }\n   public void method(){\n       Inner in = new Inner();//创建内部类的对象。\n       in.show();//调用内部类的方法。\n   }\n}\n当内部类定义在外部类中的成员位置上，可以使用一些成员修饰符修饰 private、static。\n1：默认修饰符。\n直接访问内部类格式：外部类名.内部类名 变量名 =  外部类对象.内部类对象;\nOuter.Inner in = new Outer.new Inner();//这种形式很少用。\n 但是这种应用不多见，因为内部类之所以定义在内部就是为了封装。想要获取内部类对象通常都通过外部类的方法来获取。这样可以对内部类对象进行控制。\n2：私有修饰符。\n 通常内部类被封装，都会被私有化，因为封装性不让其他程序直接访问。\n3：静态修饰符。\n 如果内部类被静态修饰，相当于外部类，会出现访问局限性，只能访问外部类中的静态成员。\n 注意；如果内部类中定义了静态成员，那么该内部类必须是静态的。\n内部类编译后的文件名为：“外部类名$内部类名.java”；\n为什么内部类可以直接访问外部类中的成员呢？\n那是因为内部中都持有一个外部类的引用。这个是引用是 外部类名.this\n内部类可以定义在外部类中的成员位置上，也可以定义在外部类中的局部位置上。\n当内部类被定义在局部位置上，只能访问局部中被final修饰的局部变量。\n匿名内部类：没有名字的内部类。就是内部类的简化形式。一般只用一次就可以用这种形式。匿名内部类其实就是一个匿名子类对象。想要定义匿名内部类：需要前提，内部类必须继承一个类或者实现接口。\n匿名内部类的格式：new 父类名&接口名(){ 定义子类成员或者覆盖父类方法 }.方法。\n匿名内部类的使用场景：\n当函数的参数是接口类型引用时，如果接口中的方法不超过3个。可以通过匿名内部类来完成参数的传递。\n其实就是在创建匿名内部类时，该类中的封装的方法不要过多，最好两个或者两个以内。\n//面试\n       //1\n       new Object(){\n           void show(){\n               System.out.println(\"show run\");                \n           }\n       }.show();\n       //2\n       Object obj = new Object(){\n           void show(){\n               System.out.println(\"show run\");\n           }\n       };\n       obj.show();\n       \n       1和2的写法正确吗？有区别吗？说出原因。\n       写法是正确，1和2都是在通过匿名内部类建立一个Object类的子类对象。\n       区别：\n       第一个可是编译通过，并运行。\n       第二个编译失败，因为匿名内部类是一个子类对象，当用Object的obj引用指向时，就被提升为了\n       Object类型，而编译时检查Object类中是否有show方法，所以编译失败。\n-------------------------------------------------------\nclass InnerClassDemo6 {\n   +（static）class Inner{\n       void show(){}\n   }\n   public void method(){\n       this.new Inner().show();//可以\n   }\n   public static void main(String[] args) {//static不允许this\n       This.new Inner().show();//错误，Inner类需要定义成static\n   }\n}\n------------------------------------------------------\ninterface Inter{\n   void show();\n}\nclass Outer{//通过匿名内部类补足Outer类中的代码。\n   public static Inter method(){\n       return new Inter(){\n           public void show(){}\n       };\n   }\n}\nclass InnerClassDemo7 {\n   public static void main(String[] args) {\n       Outer.method().show();\n   /*\n       Outer.method():意思是：Outer中有一个名称为method的方法，而且这个方法是静态的。\n       Outer.method().show():当Outer类调用静态的method方法运算结束后的结果又调用了show方法，意味着：method()方法运算完一个是对象，而且这个对象是Inter类型的。\n   */\n       function (new Inter(){\n           public void show(){}\n       }); //匿名内部类作为方法的参数进行传递。\n   }\n   public static void function(Inter in){\n       in.show();\n   }\n}\n异 常：★★★★\n异常：就是不正常。程序在运行时出现的不正常情况。其实就是程序中出现的问题。这个问题按照面向对象思想进行描述，并封装成了对象。因为问题的产生有产生的原因、有问题的名称、有问题的描述等多个属性信息存在。当出现多属性信息最方便的方式就是将这些信息进行封装。异常就是java按照面向对象的思想将问题进行对象封装。这样就方便于操作问题以及处理问题。\n出现的问题有很多种，比如角标越界，空指针等都是。就对这些问题进行分类。而且这些问题都有共性内容比如：每一个问题都有名称，同时还有问题描述的信息，问题出现的位置，所以可以不断的向上抽取。形成了异常体系。\n--------java.lang.Throwable：\nThrowable：可抛出的。\n   |--Error：错误，一般情况下，不编写针对性的代码进行处理，通常是jvm发生的，需要对程序进行修正。\n   |--Exception：异常，可以有针对性的处理方式\n无论是错误还是异常，它们都有具体的子类体现每一个问题，它们的子类都有一个共性，就是都以父类名才作为子类的后缀名。\n这个体系中的所有类和对象都具备一个独有的特点；就是可抛性。\n可抛性的体现：就是这个体系中的类和对象都可以被throws和throw两个关键字所操作。\n\nclass  ExceptionDemo{\n   public static void main(String[] args) {\n//      byte[] buf = new byte[1024*1024*700];//java.lang.OutOfMemoryError内存溢出错误\n   }\n}\n在开发时，如果定义功能时，发现该功能会出现一些问题，应该将问题在定义功能时标示出来，这样调用者就可以在使用这个功能的时候，预先给出处理方式。\n\n如何标示呢？通过throws关键字完成，格式：throws 异常类名,异常类名...\n这样标示后，调用者，在使用该功能时，就必须要处理，否则编译失败。\n处理方式有两种：1、捕捉；2、抛出。\n对于捕捉：java有针对性的语句块进行处理。\ntry {\n   需要被检测的代码；\n}\ncatch(异常类 变量名){\n   异常处理代码；\n}\nfianlly{\n   一定会执行的代码；\n}\n--------------------------------------------------------\ncatch (Exception e) { //e用于接收try检测到的异常对象。\n   System.out.println(\"message:\"+e.getMessage());//获取的是异常的信息。\n   System.out.println(\"toString:\"+e.toString());//获取的是异常的名字+异常的信息。\n   e.printStackTrace();//打印异常在堆栈中信息；异常名称+异常信息+异常的位置。\n}\n\n\n异常处理原则：功能抛出几个异常，功能调用如果进行try处理，需要与之对应的catch处理代码块，这样的处理有针对性，抛几个就处理几个。\n特殊情况：try对应多个catch时，如果有父类的catch语句块，一定要放在下面。\nthrow 和throws关键字的区别：\nthrow用于抛出异常对象，后面跟的是异常对象；throw用在函数内。\nthrows用于抛出异常类，后面跟的异常类名，可以跟多个，用逗号隔开。throws用在函数上。\n通常情况：函数内容如果有throw，抛出异常对象，并没有进行处理，那么函数上一定要声明，否则编译失败。但是也有特殊情况。\n异常分两种：\n1：编译时被检查的异常，只要是Exception及其子类都是编译时被检测的异常。\n2：运行时异常，其中Exception有一个特殊的子类RuntimeException，以及RuntimeException的子类是运行异常，也就说这个异常是编译时不被检查的异常。\n编译时被检查的异常和运行时异常的区别：\n编译被检查的异常在函数内被抛出，函数必须要声明，否编译失败。\n声明的原因：是需要调用者对该异常进行处理。\n运行时异常如果在函数内被抛出，在函数上不需要声明。\n不声明的原因：不需要调用者处理，运行时异常发生，已经无法再让程序继续运行，所以，不让调用处理的，直接让程序停止，由调用者对代码进行修正。\n定义异常处理时，什么时候定义try，什么时候定义throws呢？\n功能内部如果出现异常，如果内部可以处理，就用try；\n如果功能内部处理不了，就必须声明出来，让调用者处理。\n自定义异常：当开发时，项目中出现了java中没有定义过的问题时，这时就需要我们按照java异常建立思想，将项目的中的特有问题也进行对象的封装。这个异常，称为自定义异常。\n对于除法运算，0作为除数是不可以的。java中对这种问题用ArithmeticException类进行描述。对于这个功能，在我们项目中，除数除了不可以为0外，还不可以为负数。可是负数的部分java并没有针对描述。所以我们就需要自定义这个异常。\n自定义异常的步骤：\n1：定义一个子类继承Exception或RuntimeException，让该类具备可抛性。\n2：通过throw 或者throws进行操作。\n异常的转换思想：当出现的异常是调用者处理不了的，就需要将此异常转换为一个调用者可以处理的异常抛出。\ntry  catch  finally的几种结合方式：\n1，\ntry\ncatch\nfinally\n2,\ntry\ncatch\n3,\ntry\nfinally\n\n\n这种情况，如果出现异常，并不处理，但是资源一定关闭，所以try  finally集合只为关闭资源。\n记住：finally很有用，主要用户关闭资源。无论是否发生异常，资源都必须进行关闭。\nSystem.exit(0); //退出jvm，只有这种情况finally不执行。\n当异常出现后，在子父类进行覆盖时，有了一些新的特点：\n1：当子类覆盖父类的方法时，如果父类的方法抛出了异常，那么子类的方法要么不抛出异常要么抛出父类异常或者该异常的子类，不能抛出其他异常。\n2：如果父类抛出了多个异常，那么子类在覆盖时只能抛出父类的异常的子集。\n注意：\n如果父类或者接口中的方法没有抛出过异常，那么子类是不可以抛出异常的，如果子类的覆盖的方法中出现了异常，只能try不能throws。\n如果这个异常子类无法处理，已经影响了子类方法的具体运算，这时可以在子类方法中，通过throw抛出RuntimeException异常或者其子类，这样，子类的方法上是不需要throws声明的。\n常见异常：\n1、脚标越界异常（IndexOutOfBoundsException）包括数组、字符串；\n空指针异常（NullPointerException）\n2、类型转换异常：ClassCastException\n3、没有这个元素异常：NullPointerException\n4、不支持操作异常；\n异常要尽量避免，如果避免不了，需要预先给出处理方式。比如家庭备药，比如灭火器。\n\n\n包：定义包用package关键字。包中可以还有包\n1：对类文件进行分类管理。\n2：给类文件提供多层名称空间。\n如果生成的包不在当前目录下，需要最好执行classpath，将包所在父目录定义到classpath变量中即可。\n一般在定义包名时，因为包的出现是为了区分重名的类。所以包名要尽量唯一。怎么保证唯一性呢？可以使用url域名来进行包名称的定义。url域名倒序\npackage pack;//定义了一个包，名称为pack。 注意：包名的写法规范：所有字母都小写。\n//package cn.itcast.pack.demo;\n类的全名称是 包名.类名\n   编译命令：javac –d 位置（.当前路径） java源文件 （就可以自动生成包）\n包是一种封装形式，用于封装类，想要被包以外的程序访问，该类必须public；\n类中的成员，如果被包以外访问，也必须public；\n包与包之间访问可以使用的权限有两种：\n1：public\n2：protected：只能是不同包中的子类可以使用的权限。\n总结java中的四种权限：\n  范围       public protected(保护)       default（默认）       private\n同一个类中       ok            ok              ok              ok\n同一包中         ok             ok              ok      \n子类             ok        \n不同包中         ok             ok\n\n\nImport - 导入：类名称变长，写起来很麻烦。为了简化，使用了一个关键字：import，可以使用这个关键字导入指定包中的类。记住：实际开发时,到的哪个类就导入哪个类，不建议使用*.\nimport packa.*;//这个仅仅是导入了packa当前目录下的所有的类。不包含子包。\nimport packa.abc.*;//导入了packa包中的子包abc下的当前的所有类。\n如果导入的两个包中存在着相同名称的类。这时如果用到该类，必须在代码中指定包名。\n常见的软件包:\njava.lang : language java的核心包，Object System  String Throwable jdk1.2版本后，该包中的类自动被导入。\njava.awt : 定义的都是用于java图形界面开发的对象。\njavax.swing: 提供所有的windows桌面应用程序包括的控件,比如：Frame , Dialog, Table, List 等等,就是java的图形界面库。\njava.net : 用于java网络编程方面的对象都在该包中。\njava.io : input  output 用于操作设备上数据的对象都在该包中。比如：读取硬盘数据，往硬盘写入数据。\njava.util : java的工具包，时间对象，集合框架。\njava.applet: application+let 客户端java小程序。server+let  -->  servlet 服务端java小程序。\njar ：java的压缩包，主要用于存储类文件，或者配置文件等。\n命令格式：jar –cf 包名.jar 包目录\n  解压缩：jar –xvf 包名.jar\n将jar包目录列表重定向到一个文件中：jar –tf 包名.jar >c:\\1.txt\n\n\n多线程：★★★★\n进程\n正在进行中的程序。其实进程就是一个应用程序运行时的内存分配空间。\n线程\n其实就是进程中一个程序执行控制单元(进程由线程组成)，一条执行路径。进程负责的是应用程序的空间的标示。线程负责的是应用程序的执行顺序。\n一个进程至少有一个线程在运行，当一个进程中出现多个线程时，就称这个应用程序是多线程应用程序，每个线程在栈区中都有自己的执行空间，自己的方法区、自己的变量。\njvm在启动的时，首先有一个主线程，负责程序的执行，调用的是main函数。主线程执行的代码都在main方法中。JavaVM启动的时候会有一个进程java.exe\n当产生垃圾时，收垃圾的动作，是不需要主线程来完成，因为这样，会出现主线程中的代码执行会停止，会去运行垃圾回收器代码，效率较低，所以由单独一个线程来负责垃圾回收。故至少有两个进程。\n随机性的原理\n因为cpu的快速切换造成，哪个线程获取到了cpu的执行权，哪个线程就执行。//我们可以形象把多线程的运行行为认为在互相抢夺cpu的执行权。\n返回当前线程的名称：Thread.currentThread().getName()//Thread.currentThread()返回的是线程对象\n\n线程的名称是由：Thread-编号定义的。编号从0开始。\n线程要运行的代码都统一存放在了run方法中。\n线程要运行必须要通过类中指定的方法开启。start方法。（启动后，就多了一条执行路径）\nstart方法：1）、启动了线程；2）、让jvm调用了run方法。\n创建线程的第一种方式：继承Thread ，由子类复写run方法。\n步骤：\n1，定义类继承Thread类；\n2，目的是复写run方法，将要让线程运行的代码都存储到run方法中；\n3，通过创建Thread类的子类对象，创建线程对象；\n4，调用线程的start方法，开启线程，并执行run方法。若仅调用run方法，则仅用对象调用方法，线程创建了，但未运行。\n线程状态：\n被创建：start()\n运行：具备执行资格，同时具备执行权；\n冻结：sleep(time),wait()—notify()唤醒；线程释放了执行权，同时释放执行资格；\n临时阻塞状态：线程具备cpu的执行资格，没有cpu的执行权；\n消亡：stop()\n\n创建线程的第二种方式：实现一个接口Runnable。\n步骤：\n1，定义类实现Runnable接口。\n2，覆盖接口中的run方法（用于封装线程要运行的代码）。\n3，通过Thread类创建线程对象；\n4，将实现了Runnable接口的子类对象作为实际参数传递给Thread类中的构造函数。\n为什么要传递呢？因为要让线程对象明确要运行的run方法所属的对象。\n5，调用Thread对象的start方法。开启线程，并运行Runnable接口子类中的run方法。\n       Ticket t = new Ticket();\n       /*\n       直接创建Ticket对象，并不是创建线程对象。\n       因为创建对象只能通过new Thread类，或者new Thread类的子类才可以。\n       所以最终想要创建线程。既然没有了Thread类的子类，就只能用Thread类。\n       */\n       Thread t1 = new Thread(t); //创建线程。\n       /*\n       只要将t作为Thread类的构造函数的实际参数传入即可完成线程对象和t之间的关联\n       为什么要将t传给Thread类的构造函数呢？其实就是为了明确线程要运行的代码run方法。\n       */\n       t1.start();\n       \n\n为什么要有Runnable接口的出现？\n1：通过继承Thread类的方式，可以完成多线程的建立。但是这种方式有一个局限性，如果一个类已经有了自己的父类，就不可以继承Thread类，因为java单继承的局限性。\n可是该类中的还有部分代码需要被多个线程同时执行。这时怎么办呢？\n只有对该类进行额外的功能扩展，java就提供了一个接口Runnable。这个接口中定义了run方法，其实run方法的定义就是为了存储多线程要运行的代码。\n所以，通常创建线程都用第二种方式。\n因为实现Runnable接口可以避免单继承的局限性。\n2：其实是将不同类中需要被多线程执行的代码进行抽取。将多线程要运行的代码的位置单独定义到接口中。为其他类进行功能扩展提供了前提。\n所以Thread类在描述线程时，内部定义的run方法，也来自于Runnable接口。\n实现Runnable接口可以避免单继承的局限性。而且，继承Thread，是可以对Thread类中的方法，进行子类复写的。但是不需要做这个复写动作的话，只为定义线程代码存放位置，实现Runnable接口更方便一些。所以Runnable接口将线程要执行的任务封装成了对象。\n-------------------------------------------------------\n//面试\n       new Thread(new Runnable(){  //匿名\n           public void run(){\n               System.out.println(\"runnable run\");    \n           }\n       }\n       {\n           public void run(){\n               System.out.println(\"subthread run\");\n           }\n       }.start();  //结果：subthread run\n---------------------------------------------------------\nTry {\nThread.sleep(10);\n}catch(InterruptedException e){}// 当刻意让线程稍微停一下，模拟cpu切换情况。\n\n\n多线程安全问题的原因：\n通过图解：发现一个线程在执行多条语句时，并运算同一个数据时，在执行过程中，其他线程参与进来，并操作了这个数据。导致到了错误数据的产生。\n涉及到两个因素：\n1，多个线程在操作共享数据。\n2，有多条语句对共享数据进行运算。\n原因：这多条语句，在某一个时刻被一个线程执行时，还没有执行完，就被其他线程执行了。\n解决安全问题的原理：\n只要将操作共享数据的语句在某一时段让一个线程执行完，在执行过程中，其他线程不能进来执行就可以解决这个问题。\n如何进行多句操作共享数据代码的封装呢？\njava中提供了一个解决方式：就是同步代码块。\n格式：\nsynchronized(对象) { // 任意对象都可以。这个对象就是锁。\n   需要被同步的代码；//没有持有锁的进程，即使获取cpu的执行权，也进不去，因为没有获取锁。\n}                                 //案例：火车上的卫生间\n---------------------------------------------------------------\n同步：★★★★★\n好处：解决了线程安全问题。\n弊端：相对降低性能，因为判断锁需要消耗资源，产生了死锁。\n定义同步是有前提的：\n1，必须要有两个或者两个以上的线程，才需要同步。\n2，多个线程必须保证使用的是同一个锁。\n同步的第二种表现形式：\n同步函数：其实就是将同步关键字定义在函数上，让函数具备了同步性。\n同步函数是用的哪个锁呢？\n通过验证，函数都有自己所属的对象this，所以同步函数所使用的锁就是this锁。\n当同步函数被static修饰时，这时的同步用的是哪个锁呢？\n静态函数在加载时所属于类，这时有可能还没有该类产生的对象，但是该类的字节码文件加载进内存就已经被封装成了对象，这个对象就是该类的字节码文件对象。\n所以静态加载时，只有一个对象存在，那么静态同步函数就使用的这个对象。\n这个对象就是 类名.class\n同步代码块和同步函数的区别？\n同步代码块使用的锁可以是任意对象。\n同步函数使用的锁是this，静态同步函数的锁是该类的字节码文件对象。反射技术\n在一个类中只有一个同步，可以使用同步函数。如果有多同步，必须使用同步代码块，来确定不同的锁。所以同步代码块相对灵活一些。\n\n\n★考点问题：请写一个延迟加载的单例模式？写懒汉式；当出现多线程访问时怎么解决？加同步，解决安全问题；效率高吗？不高；怎样解决？通过双重判断的形式解决。\n//懒汉式：延迟加载方式。\n当多线程访问懒汉式时，因为懒汉式的方法内对共性数据进行多条语句的操作。所以容易出现线程安全问题。为了解决，加入同步机制，解决安全问题。但是却带来了效率降低。\n为了效率问题，通过双重判断的形式解决。\nclass Single{\n   private static Single s = null;\n   private Single(){}\n   public static Single getInstance(){ //锁是谁？字节码文件对象；\n       if(s == null){\n          synchronized(Single.class){\n             if(s == null)\n                 s = new Single();\n          }\n      }\n       return s;\n   }\n}\n\n\n同步死锁\n通常只要将同步进行嵌套，就可以看到现象。同步函数中有同步代码块，同步代码块中还有同步函数。\n线程间通信\n思路：多个线程在操作同一个资源，但是操作的动作却不一样。\n1：将资源封装成对象。\n2：将线程执行的任务(任务其实就是run方法。)也封装成对象。\n等待唤醒机制\n涉及的方法：（FIFO）\nwait:将同步中的线程处于冻结状态。释放了执行权，释放了资格。同时将线程对象存储到线程池中。\nnotify：唤醒线程池中某一个等待线程。\nnotifyAll:唤醒的是线程池中的所有线程。\n注意：\n1：这些方法都需要定义在同步中。\n2：因为这些方法必须要标示所属的锁。\n   你要知道 A锁上的线程被wait了,那这个线程就相当于处于A锁的线程池中，只能A锁的notify唤醒。\n3：这三个方法都定义在Object类中。为什么操作线程的方法定义在Object类中？\n   因为这三个方法都需要定义同步内，并标示所属的同步锁，既然被锁调用，而锁又可以是任意对象，那么能被任意对象调用的方法一定定义在Object类中。\nwait和sleep区别\n分析这两个方法：从执行权和锁上来分析：\nwait：可以指定时间也可以不指定时间。不指定时间，只能由对应的notify或者notifyAll来唤醒。\nsleep：必须指定时间，时间到自动从冻结状态转成运行状态(临时阻塞状态)。\nwait：线程会释放执行权，而且线程会释放锁。\nSleep：线程会释放执行权，但不是不释放锁。\n\n线程的停止\n通过stop方法就可以停止线程。但是这个方式过时了。\n停止线程：原理就是：让线程运行的代码结束，也就是结束run方法。\n怎么结束run方法？一般run方法里肯定定义循环。所以只要结束循环即可。\n第一种方式：定义循环的结束标记。\n第二种方式：如果线程处于了冻结状态，是不可能读到标记的，这时就需要通过Thread类中的interrupt方法，将其冻结状态强制清除。让线程恢复具备执行资格的状态，让线程可以读到标记，并结束。\n---------< java.lang.Thread >----------\ninterrupt()：中断线程。\nsetPriority(int newPriority)：更改线程的优先级。\ngetPriority()：返回线程的优先级。\ntoString()：返回该线程的字符串表示形式，包括线程名称、优先级和线程组。\nThread.yield()：暂停当前正在执行的线程对象，并执行其他线程。\nsetDaemon(true)：将该线程标记为守护线程或用户线程。将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。该方法必须在启动线程前调用。\njoin：临时加入一个线程的时候可以使用join方法。\n\n当A线程执行到了B线程的join方式。A线程处于冻结状态，释放了执行权，B开始执行。A什么时候执行呢？只有当B线程运行结束后，A才从冻结状态恢复运行状态执行。\n\n\nLock接口\n多线程在JDK1.5版本升级时，推出一个接口Lock接口。\n解决线程安全问题使用同步的形式，(同步代码块，要么同步函数)其实最终使用的都是锁机制。\n到了后期版本，直接将锁封装成了对象。线程进入同步就是具备了锁，执行完，离开同步，就是释放了锁。\n在后期对锁的分析过程中，发现，获取锁，或者释放锁的动作应该是锁这个事物更清楚。所以将这些动作定义在了锁当中，并把锁定义成对象。\n所以同步是隐示的锁操作，而Lock对象是显示的锁操作，它的出现就替代了同步。//一个锁可以有多个对象\n\n在之前的版本中使用Object类中wait、notify、notifyAll的方式来完成的。那是因为同步中的锁是任意对象，所以操作锁的等待唤醒的方法都定义在Object类中。\n\n而现在锁是指定对象Lock。所以查找等待唤醒机制方式需要通过Lock接口来完成。而Lock接口中并没有直接操作等待唤醒的方法，而是将这些方式又单独封装到了一个对象中。这个对象就是Condition，将Object中的三个方法进行单独的封装。并提供了功能一致的方法 await()、signal()、signalAll()体现新版本对象的好处。\n< java.util.concurrent.locks > Condition接口：await()、signal()、signalAll()；\nclass BoundedBuffer {\n  final Lock lock = new ReentrantLock();\n  final Condition notFull  = lock.newCondition();\n  final Condition notEmpty = lock.newCondition();\n  final Object[] items = new Object[100];\n  int putptr, takeptr, count;\n  public void put(Object x) throws InterruptedException {\n    lock.lock();\n    try {\n      while (count == items.length)\n        notFull.await();\n      items[putptr] = x;\n      if (++putptr == items.length) putptr = 0;\n      ++count;\n      notEmpty.signal();//本方只唤醒对方\n    }\n   finally {\n      lock.unlock();\n    }\n  }\n  public Object take() throws InterruptedException {\n    lock.lock();\n    try {\n      while (count == 0)\n        notEmpty.await();\n      Object x = items[takeptr];\n      if (++takeptr == items.length) takeptr = 0;\n      --count;\n      notFull.signal();\n      return x;\n    }\nfinally {\n      lock.unlock();\n    }\n  }\n}\n\n\nAPI\n（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件的以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。\n--< java.lang >-- String字符串：★★★☆\njava中用String类进行描述。对字符串进行了对象的封装。这样的好处是可以对字符串这种常见数据进行方便的操作。对象封装后，可以定义N多属性和行为。\n如何定义字符串对象呢？String s = \"abc\";只要是双引号引起的数据都是字符串对象。\n特点：字符串一旦被初始化，就不可以被改变，存放在方法区中的常量池中。\nString s1 = \"abc\"; // s1指向的内存中只有一个对象abc。\nString s2 = new String(\"abc\"); // s2指向的内容中有两个对象abc、new 。\nSystem.out.println(s1==s2);//false ==比较的是地址值\nSystem.out.println(s1.equals(s2));//true ，字符串中equals比较的是字符串内容是否相同。\n\n\n而在Object中，equals比较的是两个对象的地址值，是否为相同。\n查API。\n\n字符串的方法：\n1：构造方法：将字节数组或者字符数组转成字符串。\nString s1 = new String();//创建了一个空内容的字符串。\nString s2 = null;//s2没有任何对象指向，是一个null常量值。\nString s3 = \"\";//s3指向一个具体的字符串对象，只不过这个字符串中没有内容。\n//一般在定义字符串时，不用new。会产生两个对象\nString s4 = new String(\"abc\");\nString s5 = \"abc\"; 一般用此写法\nnew String(char[]);//将字符数组转成字符串。\nnew String(char[],offset,count);//将字符数组中的一部分转成字符串。\n\n\n2：一般方法：\n   按照面向对象的思想：\n2.1 获取：\n   2.1.1：获取字符串的长度。length();//不包括\\n\n   2.1.2：指定位置的字符。char charAt(int index);//当访问到字符串中不存在的角标时会抛出StringIndexOutOfBandsException.\n   2.1.3：获取指定字符的位置。如果不存在返回-1，所以可以通过返回值-1来判断某一个字符不存在的情况。\n           int indexOf(int ch);//返回第一次找到的字符角标//从零开始\n           int indexOf(int ch,int fromIndex); //返回从指定位置开始第一次找到的角标\n           int indexOf(String str); //返回第一次找到的字符串角标\n           int indexOf(String str,int fromIndex);\n           int lastIndexOf(int ch);//由该对象表示的字符序列中的最后一次出现的索引，如果该字符不发生，-1 。\n           int lastIndexOf(int ch,int fromIndex);\n           int lastIndexOf(String str);\n           int lastIndexOf(String str,int fromIndex);\n   2.1.4：获取子串。\n           String substring(int start);//从start位开始，到length()-1为止.\n           String substring(int start,int end);//从start开始到end为止。//包含start位，不包含end位。\n           substring(0,str.length());//获取整串\n2.2 判断：\n   2.2.1：字符串中包含指定的字符串吗？\n           boolean contains(String substring);\n            indexOf(str) 也可以\n   2.2.2：字符串是否以指定字符串开头啊？\n           boolean startsWith(string);\n   2.2.3：字符串是否以指定字符串结尾啊？\n           boolean endsWith(string);\n   2.2.4：判断字符串是否相同\n           boolean equals(string);//覆盖了Object中的方法，判断字符串内容是否相同。\n   2.2.5：判断字符串内容是否相同，忽略大小写。\n           boolean equalsIgnoreCase(string) ;\n2.3 转换：\n   2.3.1：通过构造函数可以将字符数组或者字节数组转成字符串。\nnew String(char[]);//将字符数组转成字符串。\nnew String(char[],offset,count);//将字符数组中的一部分转成字符串。\n   2.3.2：可以通过字符串中的静态方法，将字符数组转成字符串。\n           static String copyValueOf(char[] );//字符串数组的后续修改不会影响返回的字符串\n           static String copyValueOf(char[],int offset,int count);\n           static String valueOf(char[]);\n           static String valueOf(char[],int offset,int count);\n   2.3.3：将基本数据类型或者对象转成字符串。\n           static String valueOf(char);\n           static String valueOf(boolean);\n           static String valueOf(double);\n           static String valueOf(float);\n           static String valueOf(int);\n           static String valueOf(long);\n           static String valueOf(Object);\n   2.3.4：将字符串转成大小写。\n           String toLowerCase();\n           String toUpperCase();\n   2.3.5：将字符串转成数组。\n           char[] toCharArray();//转成字符数组。\n           byte[] getBytes();//可以加入编码表。转成字节数组。\n   2.3.6：将字符串转成字符串数组。切割方法。\n           String[] split(分割的规则-字符串);//若切割符未找到则返回原串\n   2.3.7：将字符串进行内容替换。注意：修改后变成新字符串，并不是将原字符串直接修改。\n           String replace(oldChar,newChar);将符合的字符全部替换为新字符//若不存在则返回原串\n           String replace(oldstring,newstring);\n            * 注意与replaceAll：用给定的替换替换与给定的 regular expression匹配的此字符串的每个子字符串。\n\n   2.3.8： String concat(string); //对字符串进行追加。\n           String trim();//去除字符串两端的空格\n    int compareTo();//如果参数字符串等于此字符串，则返回值 0；如果此字符串按字典顺序小于字符串参数，则返回一个小于 0 （即不一定返回-1）的值；如果此字符串按字典顺序大于字符串参数，则返回一个大于 0（不一定为1） 的值。\n\n\n--< java.lang >-- StringBuffer字符串缓冲区：★★★☆\n构造一个其中不带字符的字符串缓冲区，初始容量为 16 个字符。\n特点：\n1：可以对字符串内容进行修改。\n2：是一个容器。\n3：是可变长度的。\n4：缓冲区中可以存储任意类型的数据。\n5：最终需要变成字符串。\n容器通常具备一些固定的方法：\n1，添加。\n   StringBuffer append(data):在缓冲区中追加数据。追加到尾部。\n   StringBuffer insert(index,data):在指定位置插入数据。//角标越界\n2，删除。\n   StringBuffer delete(start,end);删除从start至end-1范围的元素\n   StringBuffer deleteCharAt(index);删除指定位置的元素\n//sb.delete(0,sb.length());//清空缓冲区。\n3，修改。\n   StringBuffer replace(start,end,string);将start至end-1替换成string\n   void setCharAt(index,char);替换指定位置的字符\n   void setLength(len);将原字符串置为指定长度的字符串\n4，查找。（查不到返回-1）\n   int indexOf(string); 返回指定子字符串在此字符串中第一次出现处的索引。\n   int indexOf(string,int fromIndex);从指定位置开始查找字符串\n   int lastIndexOf(string); 返回指定子字符串在此字符串中最右边出现处的索引。\n   int lastIndexOf(string,int fromIndex); 从指定的索引开始反向搜索\n5，获取子串。\n   string substring(start); 返回start到结尾的子串\n   string substring(start,end); 返回start至end-1的子串\n6，反转。\n   StringBuffer reverse();字符串反转\n\n\n--< java.lang >-- StringBuilder字符串缓冲区：★★★☆//建议使用\nJDK1.5出现StringBuiler；构造一个其中不带字符的字符串生成器，初始容量为 16 个字符。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。\n方法和StringBuffer一样；\nStringBuffer 和 StringBuilder 的区别：\nStringBuffer线程安全。导致效率变慢\nStringBuilder线程不安全。\n单线程操作，使用StringBuilder 效率高。\n多线程操作，使用StringBuffer 安全。\n       StringBuilder sb = new StringBuilder(\"abcdefg\");\n       sb.append(\"ak\");  //abcdefgak\n       sb.insert(1,\"et\");//aetbcdefg\n       sb.deleteCharAt(2);//abdefg\n       sb.delete(2,4);//abefg\n       sb.setLength(4);//abcd\n       sb.setCharAt(0,'k');//kbcdefg\n       sb.replace(0,2,\"hhhh\");//hhhhcdefg\n       \n//想要使用缓冲区，先要建立对象。\n       StringBuffer sb = new StringBuffer();      \n       sb.append(12).append(\"haha\");//方法调用链。\n       String s = \"abc\"+4+'q';\n       s = new StringBuffer().append(\"abc\").append(4).append('q').toString();\n---------------------------------------------------------\nclass  Test{\n   public static void main(String[] args) {\n       String s1 = \"java\";\n       String s2 = \"hello\";\n       method_1(s1,s2);\n       System.out.println(s1+\"....\"+s2); //java....hello\n       \n       StringBuilder s11 = new StringBuilder(\"java\");\n       StringBuilder s22 = new StringBuilder(\"hello\");\n       method_2(s11,s22);\n       System.out.println(s11+\"-----\"+s22); //javahello-----hello\n   }\n   public static void method_1(String s1,String s2){\n       s1.replace('a','k');\n       s1 = s2;\n   }\n   public static void method_2(StringBuilder s1,StringBuilder s2){\n       s1.append(s2);\n       s1 = s2;\n   }\n}\n\n\n基本数据类型对象包装类\n是按照面向对象思想将基本数据类型封装成了对象。\n好处：\n1：可以通过对象中的属性和行为操作基本数据。\n2：可以实现基本数据类型和字符串之间的转换。\n关键字   对应的类名\nbyte    Byte\nshort   Short     paserShort(numstring);\nint     Integer   静态方法：parseInt(numstring)\nlong    Long\nfloat   Float\ndouble    Double\nchar   Character\nBoolean   Boolean\n基本数据类型对象包装类：都有 XXX parseXXX 方法\n只有一个类型没有parse方法：Character ；\n\n\nInteger对象： ★★★☆\n数字格式的字符串转成基本数据类型的方法：\n1：将该字符串封装成了Integer对象，并调用对象的方法intValue();\n2：使用Integer.parseInt(numstring):不用建立对象，直接类名调用；\n将基本类型转成字符串：\n1：Integer中的静态方法 String toString(int);\n2：int+\"\";\n将一个十进制整数转成其他进制：\n   转成二进制：toBinaryString\n   转成八进制：toOctalString\n   转成十六进制：toHexString\n   toString(int num,int radix);\n将其他进制转换十进制：\nparseInt(string,radix); //将给定的数转成指定的基数进制；\n在jdk1.5版本后，对基本数据类型对象包装类进行升级。在升级中，使用基本数据类型对象包装类可以像使用基本数据类型一样，进行运算。\n   Integer i = new Integer(4); //1.5版本之前的写法；\n   Integer i = 4; //自动装箱，1.5版本后的写法；\n   i = i + 5;\n   //i对象是不能直接和5相加的，其实底层先将i转成int类型，在和5相加。而转成int类型的操作是隐式的。自动拆箱：拆箱的原理就是i.intValue();i+5运算完是一个int整数。如何赋值给引用类型i呢？其实有对结果进行装箱。\nInteger c = 127;\n   Integer d = 127;\n   System.out.println(c = = d); //true\n   //在装箱时，如果数值在byte范围之内，那么数值相同，不会产生新的对象，也就是说多个数值相同的引用指向的是同一个对象。\n集合框架：★★★★★，用于存储数据的容器。\n特点：\n1：对象封装数据，对象多了也需要存储。集合用于存储对象。\n2：对象的个数确定可以使用数组，但是不确定怎么办？可以用集合。因为集合是可变长度的。\n集合和数组的区别：\n1：数组是固定长度的；集合可变长度的。\n2：数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。\n3：数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。\n数据结构：就是容器中存储数据的方式。\n对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。\n集合容器在不断向上抽取过程中。出现了集合体系。\n在使用一个体系时，原则：参阅顶层内容。建立底层对象。\n\n\n--< java.util >-- Collection接口：\nCollection：若直接打印集合，则将集合中的对象封装到[]中打印出来。\n   |--List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。\n   |--Set：无序(存入和取出顺序有可能不一致)，不可以存储重复元素。必须保证元素唯一性。\n1，添加：\n   add(object)：添加一个元素//Object：以便接收任意类型对象\n   addAll(Collection) ：添加一个集合中的所有元素。\n2，删除：\n   clear()：将集合中的元素全删除，清空集合。\n   remove(obj) ：删除集合中指定的对象。注意：删除成功，集合的长度会改变。\n   removeAll(collection) ：删除部分元素。部分元素和传入Collection一致。\n3，判断：\n   boolean contains(obj) ：集合中是否包含指定元素 。\n   boolean containsAll(Collection) ：集合中是否包含指定的多个元素。\n   boolean isEmpty()：集合中是否有元素。\n4，获取：\n   int size()：集合中有几个元素。\n5，取交集：\n   boolean  retainAll(Collection) ：对当前集合中保留和指定集合中的相同的元素。如果两个集合元素相同，返回flase；如果retainAll修改了当前集合，返回true。//c1.retainAll(c2),c1集合的内容会变成c1和c2元素的交集\n6，获取集合中所有元素：\n   Iterator  iterator()：迭代器\n7，将集合变成数组：\n   toArray();\n--< java.util >-- Iterator接口：\n迭代器：是一个接口。作用：用于取集合中的元素。\n\nboolean\nhasNext() 如果仍有元素可以迭代，则返回 true。\nE\nnext()  返回迭代的下一个元素。\nvoid\nremove() 从迭代器指向的 collection 中移除迭代器返回的最后一个元素（可选操作）。\n迭代完成后若要重新使用需要显示指回.iterator()\n每一个集合都有自己的数据结构，都有特定的取出自己内部元素的方式。为了便于操作所有的容器，取出元素。将容器内部的取出方式按照一个统一的规则向外提供，这个规则就是Iterator接口。\n也就说，只要通过该接口就可以取出Collection集合中的元素，至于每一个具体的容器依据自己的数据结构，如何实现的具体取出细节，这个不用关心，这样就降低了取出元素和具体集合的耦合性。\nIterator it = coll.iterator();//获取容器中的迭代器对象，至于这个对象是是什么不重要。这对象肯定符合一个规则Iterator接口。\npublic static void main(String[] args) {\n       Collection coll = new ArrayList();\n       coll.add(\"abc0\");\n       coll.add(\"abc1\");\n       coll.add(\"abc2\");\n       //--------------方式1----------------------\n       Iterator it = coll.iterator();\n       while(it.hasNext()){\n           System.out.println(it.next());\n       }\n       //---------------方式2用此种----------------------\n       for(Iterator it = coll.iterator();it.hasNext(); ){//for循环结束会释放it\n           System.out.println(it.next());\n       }\n   }\n\n\n--< java.util >-- List接口：\nList本身是Collection接口的子接口，具备了Collection的所有方法。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。\nList：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。\n   |--ArrayList：底层的数据结构是数组,线程不同步，ArrayList替代了Vector，查询元素的速度非常快。\n   |--LinkedList：底层的数据结构是链表，线程不同步，增删元素的速度非常快。\n   |--Vector：底层的数据结构就是数组，线程同步的，Vector无论查询和增删都巨慢。\n1，添加：\n   add(index,element) ：在指定的索引位插入元素。\n   addAll(index,collection) ：在指定的索引位插入一堆元素。\n2，删除：\n   remove(index) ：删除指定索引位的元素。 返回被删的元素。  \n3，获取：\n   Object get(index) ：通过索引获取指定元素。\n   int indexOf(obj) ：获取指定元素第一次出现的索引位，如果该元素不存在返回-1；\n                    所以，通过-1，可以判断一个元素是否存在。\n   int lastIndexOf(Object o) ：反向索引指定元素的位置。\n   List subList(start,end) ：获取子列表。\n4，修改：\n   Object set(index,element) ：对指定索引位进行元素的修改。\n5，获取所有元素：\n   ListIterator listIterator()：list集合特有的迭代器。\nList集合支持对元素的增、删、改、查。\nList集合因为角标有了自己的获取元素的方式： 遍历。\nfor(int x=0; x<list.size(); x++){\n sop(\"get:\"+list.get(x));\n}\n在进行list列表元素迭代的时候，如果想要在迭代过程中，想要对元素进行操作的时候，比如满足条件添加新元素。会发生.ConcurrentModificationException并发修改异常。\n导致的原因是：\n集合引用和迭代器引用在同时操作元素，通过集合获取到对应的迭代器后，在迭代中，进行集合引用的元素添加，迭代器并不知道，所以会出现异常情况。\n如何解决呢？\n既然是在迭代中对元素进行操作,找迭代器的方法最为合适.可是Iterator中只有hasNext,next,remove方法.通过查阅的它的子接口,ListIterator,发现该列表迭代器接口具备了对元素的增、删、改、查的动作。\nListIterator是List集合特有的迭代器。\nListIterator it = list.listIterator;//取代Iterator it = list.iterator;\n\n方法摘要\nvoid\nadd( e) 将指定的元素插入列表（可选操作）。\nboolean\nhasNext() 以正向遍历列表时，如果列表迭代器有多个元素，则返回 true（换句话说，如果 next 返回一个元素而不是抛出异常，则返回 true）。\nboolean\nhasPrevious() 如果以逆向遍历列表，列表迭代器有多个元素，则返回 true。\nE\nnext() 返回列表中的下一个元素。\nint\nnextIndex() 返回对 next 的后续调用所返回元素的索引。\nE\nprevious() 返回列表中的前一个元素。\nint\npreviousIndex() 返回对 previous 的后续调用所返回元素的索引。\nvoid\nremove() 从列表中移除由 next 或 previous 返回的最后一个元素（可选操作）。\nvoid\nset(E e) 用指定元素替换 next 或 previous 返回的最后一个元素（可选操作）。\n\n可变长度数组的原理：\n当元素超出数组长度，会产生一个新数组，将原数组的数据复制到新数组中，再将新的元素添加到新数组中。\nArrayList：是按照原数组的50%延长。构造一个初始容量为 10 的空列表。\nVector：是按照原数组的100%延长。\n注意：对于list集合，底层判断元素是否相同，其实用的是元素自身的equals方法完成的。所以建议元素都要复写equals方法，建立元素对象自己的比较相同的条件依据。\nLinkedList：的特有方法。\n      addFirst();\n      addLast();\n在jdk1.6以后。\n      offerFirst();\n      offerLast();\n      getFirst():获取链表中的第一个元素。如果链表为空，抛出NoSuchElementException;\n      getLast();\n在jdk1.6以后均不会抛异常\n      peekFirst();获取链表中的第一个元素。如果链表为空，返回null。\n      peekLast();\n      removeFirst()：获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，抛出NoSuchElementException\n      removeLast();\n在jdk1.6以后。\n      pollFirst();获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，返回null。\n      pollLast();\n\n\n--< java.util >-- Set接口：Set中的元素不能重复\nSet接口中的方法和Collection中方法一致的。Set接口取出方式只有一种，迭代器。Set不提供get来获取位置的元素，所以遍历需要用到迭代器，或者增强型for循环。\n |--HashSet：底层数据结构是哈希表，线程是不同步的。无序，高效；\n     HashSet集合保证元素唯一性：通过元素的hashCode方法，和equals方法完成的。\n     当元素的hashCode值相同时，才继续判断元素的equals是否为true。\n     如果为true，那么视为相同元素，不存。如果为false，那么存储。\n     如果hashCode值不同，那么不判断equals，从而提高对象比较的速度。\n    |--LinkedHashSet：有序，hashset的子类。\n |--TreeSet：对Set集合中的元素的进行指定顺序的排序。不同步。TreeSet底层的数据结构就是二叉树。\n哈希表的原理：\n1，对对象元素中的关键字(对象中的特有数据)，进行哈希算法的运算，并得出一个具体的算法值，这个值 称为哈希值。\n2，哈希值就是这个元素的位置。\n3，如果哈希值出现冲突，再次判断这个关键字对应的对象是否相同。如果对象相同，就不存储，因为元素重复。如果对象不同，就存储，在原来对象的哈希值基础 +1顺延。\n4，存储哈希值的结构，我们称为哈希表。\n5，既然哈希表是根据哈希值存储的，为了提高效率，最好保证对象的关键字是唯一的。\n 这样可以尽量少的判断关键字对应的对象是否相同，提高了哈希表的操作效率。\n对于ArrayList集合，判断元素是否存在，或者删元素底层依据都是equals方法。\n对于HashSet集合，判断元素是否存在，或者删除元素，底层依据的是hashCode方法和equals方法。\nTreeSet:\n 用于对Set集合进行元素的指定顺序排序，排序需要依据元素自身具备的比较性。\n 如果元素不具备比较性，在运行时会发生ClassCastException异常。\n 所以需要元素实现Comparable接口，强制让元素具备比较性，复写compareTo方法。\n 依据compareTo方法的返回值，确定元素在TreeSet数据结构中的位置。\n TreeSet方法保证元素唯一性的方式：就是参考比较方法的结果是否为0，如果return 0，视为两个对象重复，不存。\n注意：在进行比较时，如果判断元素不唯一，比如，同姓名，同年龄，才视为同一个人。\n 在判断时，需要分主要条件和次要条件，当主要条件相同时，再判断次要条件，按照次要条件排序。\nTreeSet集合排序有两种方式，Comparable和Comparator区别：\n1：让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法。\n2：让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数。\n第二种方式较为灵活。\n用作键的对象必须实现HashCode的方法和equals方法\n\n\nMap集合\n当数据之间存在映射关系时，就要先想到Map集合\n|--Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。\n|--HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键（可为key或value的值），null值。替代了Hashtable.\n|--TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。线程不同步。\nMap集合存储和Collection有着很大不同：\nCollection一次存一个元素；Map一次存一对元素。\nCollection是单列集合；Map是双列集合。\nMap中的存储的一对元素：一个是键，一个是值，键与值之间有对应(映射)关系。\n特点：要保证map集合中键的唯一性。\n1，添加。\nput(key,value)：当存储的键相同时，新的值会替换老的值，若重复，则并将老值返回。如果键没有重复，返回null。\n void putAll(Map);\n2，删除。\n void clear()：清空\n value remove(key) ：删除指定键。将值返回。\n3，判断。\n boolean isEmpty()：\n boolean containsKey(key)：是否包含key\n boolean containsValue(value) ：是否包含value\n4，取出。\n int size()：返回长度\n value get(key) ：通过指定键获取对应的值。如果返回null，可以判断该键不存在。当然有特殊情况，就是在hashmap集合中，是可以存储null键null值的。并不删除元素\n Collection values()：获取map集合中的所有的值。\n5，想要获取map中的所有元素：\n 原理：map中是没有迭代器的，collection具备迭代器，只要将map集合转成Set集合，可以使用迭代器了。之所以转成set，是因为map集合具备着键的唯一性，其实set集合就来自于map，set集合底层其实用的就是map的方法。\n把map集合转成set的方法：\nSet keySet();\nSet entrySet();//取的是键和值的映射关系。\nEntry就是Map接口中的内部接口；\n为什么要定义在map内部呢？entry是访问键值关系的入口，是map的入口，访问的是map中的键值对。\n\n访问map集合中所有元素\n取出map集合中所有元素的方式一：keySet()方法。\n可以将map集合中的键都取出存放到set集合中。对set集合进行迭代。迭代完成，再通过get方法对获取到的键进行值的获取。\n     Set keySet = map.keySet();\n     Iterator it = keySet.iterator();\n    while(it.hasNext()) {\n        Object key = it.next();\n        Object value = map.get(key);\n        System.out.println(key+\":\"+value);\n    }\n--------------------------------------------------------\n取出map集合中所有元素的方式二：entrySet()方法。\n    Entry是Map接口中的一个内部接口。\n    entrySet将map集合中的映射关系去除，这个关系为Map.Entry类型。可直接用Map.Entry中getKey和getValue方法获取关系中的键和值.\n         //推荐，尤其是容量大时\n          System.out.println(\"通过Map.entrySet遍历key和value\");\n          for (Map.Entry<String, String> entry : map.entrySet()) {\n           System.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue());\n          }\n\n\n有关于 map.entrySet() 和 keySet():\n1、如果遍历 hashMap() 时 entrySet() 方法是将 key 和 value 全部取出来,所以性能开销是可以预计的, 而 keySet() 方法进行遍历的时候是根据取出的 key 值去查询对应的 value 值, 所以如果 key 值是比较简单的结构(如 1,2,3...)的话性能消耗上是比 entrySet() 方法低, 但随着 key 值得复杂度提高 entrySet() 的优势就会显露出来。\n2、综合比较在只遍历 key 的时候使用 keySet(), 在只遍历 value 的是使用 values() 方法, 在遍历 key-value 的时候使用 entrySet() 是比较合理的选择。\n3、如果遍历 TreeMap 的时候, 不同于 HashMap 在遍历 ThreeMap 的 key-value 时候务必使用 entrySet() 它要远远高于其他两个的性能, 同样只遍历 key 的时候使用 keySet(), 在只遍历 value 的是使用 values() 方法对于 TreeMap 也同样适用。\nSet entrySet = map.entrySet();\n       Iterator it = entrySet.iterator();\n       while(it.hasNext()) {\n           Map.Entry  me = (Map.Entry)it.next();\n           System.out.println(me.getKey()+\"::::\"+me.getValue());\n       }\n\n\n使用集合的技巧：\n看到Array就是数组结构，有角标，查询速度很快。\n看到link就是链表结构：增删速度快，而且有特有方法。addFirst； addLast； removeFirst()； removeLast()； getFirst()；getLast()；\n看到hash就是哈希表，就要想要哈希值，就要想到唯一性，就要想到存入到该结构的中的元素必须覆盖hashCode，equals方法。\n看到tree就是二叉树，就要想到排序，就想要用到比较。\n比较的两种方式：\n一个是Comparable：覆盖compareTo方法；\n一个是Comparator：覆盖compare方法。\nLinkedHashSet，LinkedHashMap:这两个集合可以保证哈希表有存入顺序和取出顺序一致，保证哈希表有序。\n集合什么时候用？\n当存储的是一个元素时，就用Collection。当存储对象之间存在着映射关系时，就使用Map集合。\n保证唯一，就用Set。不保证唯一，就用List。\n\n\nCollections：它的出现给集合操作提供了更多的功能。这个类不需要创建对象，内部提供的都是静态方法。\n静态方法：\nCollections.sort(list);//list集合进行元素的自然顺序排序。\nCollections.sort(list,new ComparatorByLen());//按指定的比较器方法排序。\nclass ComparatorByLen implements Comparator<String>{\n public int compare(String s1,String s2){\n     int temp = s1.length()-s2.length();\n     return temp==0?s1.compareTo(s2):temp;\n }\n}\nCollections.max(list); //返回list中字典顺序最大的元素。\nint index = Collections.binarySearch(list,\"zz\");//二分查找，返回角标。\nCollections.reverseOrder();//逆向反转排序。返回一个比较器,他强行逆转实现了Comparable接口的对象collection的自然顺序.\nCollections.shuffle(list);//如扑克牌洗牌,随机对list中的元素进行位置的置换。\n将非同步集合转成同步集合的方法：Collections中的 XXX synchronizedXXX(XXX);\nList synchronizedList(list);\nMap synchronizedMap(map);\n原理：定义一个类，将集合所有的方法加同一把锁后返回。\nCollection 和 Collections的区别：\nCollections是个java.util下的类，是针对集合类的一个工具类,提供一系列静态方法,实现对集合的查找、排序、替换、线程安全化（将非同步的集合转换成同步的）等操作。\nCollection是个java.util下的接口，它是各种集合结构的父接口，继承于它的接口主要有Set和List,提供了关于集合的一些操作,如插入、删除、判断一个元素是否其成员、遍历等。\n\n\nArrays：\n用于操作数组对象的工具类，里面都是静态方法。\nasList方法：将数组转换成list集合。\nString[] arr = {\"abc\",\"kk\",\"qq\"};\nList<String> list = Arrays.asList(arr);//将arr数组转成list集合。\n将数组转换成集合，有什么好处呢？用aslist方法，将数组变成集合；\n可以通过list集合中的方法来操作数组中的元素：isEmpty()、contains、indexOf、set；\n注意（局限性）：数组是固定长度，不可以使用集合对象增加或者删除等，会改变数组长度的功能方法。比如add、remove、clear。（会报不支持操作异常UnsupportedOperationException）；\n如果数组中存储的引用数据类型，直接作为集合的元素可以直接用集合方法操作。\n如果数组中存储的是基本数据类型，asList会将数组实体作为集合元素存在。\n集合变数组：用的是Collection接口中的方法：toArray();\n如果给toArray传递的指定类型的数据长度小于了集合的size，那么toArray方法，会自动再创建一个该类型的数据，长度为集合的size。\n   如果传递的指定的类型的数组的长度大于了集合的size，那么toArray方法，就不会创建新数组，直接使用该数组即可，并将集合中的元素存储到数组中，其他为存储元素的位置默认值null。\n   所以，在传递指定类型数组时，最好的方式就是指定的长度和size相等的数组。\n将集合变成数组后有什么好处？限定了对集合中的元素进行增删操作，只要获取这些元素即可。\n\n\nJdk5.0新特性：\nCollection在jdk1.5以后，有了一个父接口Iterable，这个接口的出现的将iterator方法进行抽取，提高了扩展性。\n\n增强for循环：foreach语句，foreach简化了迭代器。底层原理仍是迭代器,不可修改元素.\n格式：// 增强for循环括号里写两个参数，第一个是声明一个变量，第二个就是需要迭代的容器\nfor( 元素类型 变量名 : Collection集合 & 数组 ) {\n …\n}\n高级for循环和传统for循环的区别：\n高级for循环在使用时，必须要明确被遍历的目标。这个目标，可以是Collection集合或者数组，如果遍历Collection集合，在遍历过程中还需要对元素进行操作，比如删除，需要使用迭代器。\n如果遍历数组，还需要对数组元素进行操作，建议用传统for循环因为可以定义角标通过角标操作元素。如果只为遍历获取，可以简化成高级for循环，它的出现为了简化书写。\n\n高级for循环可以遍历map集合吗\n不可以。(map集合无迭代器)但是可以将map转成set后再使用foreach语句。\n1)、作用：对存储对象的容器进行迭代： 数组  collection   map\n2)、增强for循环迭代数组：\nString [] arr = {\"a\", \"b\", \"c\"};//数组的静态定义方式，只试用于数组首次定义的时候\nfor(String s : arr) {\n System.out.println(s);\n}\n3)、单列集合 Collection：\nList list = new ArrayList();\nlist.add(\"aaa\");\n// 增强for循环, 没有使用泛型的集合能不能使用增强for循环迭代？能\nfor(Object obj : list) {\n String s = (String) obj;\n System.out.println(s);\n}\n4)、双列集合 Map：\nMap map = new HashMap();\nmap.put(\"a\", \"aaa\");\n// 传统方式：必须掌握这种方式\nSet entrys = map.entrySet(); // 1.获得所有的键值对Entry对象\niter = entrys.iterator(); // 2.迭代出所有的entry\nwhile(iter.hasNext()) {\n Map.Entry entry = (Entry) iter.next();\n String key = (String) entry.getKey(); // 分别获得key和value\n String value = (String) entry.getValue();\n System.out.println(key + \"=\" + value);\n}\n// 增强for循环迭代：原则上map集合是无法使用增强for循环来迭代的，因为增强for循环只能针对实现了Iterable接口的集合进行迭代；Iterable是jdk5中新定义的接口，就一个方法iterator方法，只有实现了Iterable接口的类，才能保证一定有iterator方法，java有这样的限定是因为增强for循环内部还是用迭代器实现的，而实际上，我们可以通过某种方式来使用增强for循环。\nfor(Object obj : map.entrySet()) {\n Map.Entry entry = (Entry) obj; // obj 依次表示Entry\n System.out.println(entry.getKey() + \"=\" + entry.getValue());\n}\n5）、集合迭代注意问题：在迭代集合的过程中，不能对集合进行增删操作（会报并发访问异常）；可以用迭代器的方法进行操作（子类listIterator：有增删的方法）。\n6)、增强for循环注意问题：在使用增强for循环时，不能对元素进行赋值；\nint[] arr = {1,2,3};\nfor(int num : arr) {\n num = 0; //不能改变数组的值\n}\nSystem.out.println(arr[1]); //2\n\n\n可变参数（...）\n用到函数的参数上，当要操作的同一个类型元素个数不确定的时候，可是用这个方式，这个参数可以接受任意个数的同一类型的数据。\n和以前接收数组不一样的是：\n以前定义数组类型，需要先创建一个数组对象，再将这个数组对象作为参数传递给函数。现在，直接将数组中的元素作为参数传递即可。底层其实是将这些元素进行数组的封装，而这个封装动作，是在底层完成的，被隐藏了。所以简化了用户的书写，少了调用者定义数组的动作。\n如果在参数列表中使用了可变参数，可变参数必须定义在参数列表结尾(也就是必须是最后一个参数，否则编译会失败。)。\n如果要获取多个int数的和呢？可以使用将多个int数封装到数组中，直接对数组求和即可。\n\n\n静态导入：导入了类中的所有静态成员，简化静态成员的书写。连类名都省略,直接写方法\nimport static java.util.Collections.*;  //导入了Collections类中的所有静态成员\n\n\n枚举：关键字 enum\n问题：对象的某个属性的值不能是任意的，必须为固定的一组取值其中的某一个；\n解决办法：\n1）、在setGrade方法中做判断，不符合格式要求就抛出异常；\n2）、直接限定用户的选择，通过自定义类模拟枚举的方式来限定用户的输入，写一个Grade类，私有构造函数，对外提供5个静态的常量表示类的实例；\n3)、jdk5中新定义了枚举类型，专门用于解决此类问题；\n4)、枚举就是一个特殊的java类，可以定义属性、方法、构造函数、实现接口、继承类；\n\n\n自动拆装箱\njava中数据类型分为两种 ： 基本数据类型   引用数据类型(对象)\n在 java程序中所有的数据都需要当做对象来处理，针对8种基本数据类型提供了包装类，如下：\nint --> Integer\nbyte --> Byte\nshort --> Short\nlong --> Long\nchar --> Character\ndouble --> Double\nfloat --> Float\nboolean --> Boolean\njdk5以前基本数据类型和包装类之间需要互转：\n基本---引用   Integer x = new Integer(x);\n引用---基本   int num = x.intValue();\n1)、Integer x = 1; x = x + 1; 经历了什么过程？装箱 à 拆箱 à 装箱；\n2)、为了优化，虚拟机为包装类提供了缓冲池，Integer池的大小 -128~127 一个字节的大小；\n3)、String池：Java为了优化字符串操作 提供了一个缓冲池；\n面向对象中,子类转父类是一定可以成功的,但泛型中:子类泛型不可以转换为父类泛型.\n泛型\njdk1.5版本以后出现的一个安全机制。表现格式：< >\n好处：\n1：将运行时期的问题ClassCastException问题转换成了编译失败，体现在编译时期，程序员就可以解决问题。\n2：避免了强制转换的麻烦。\n只要带有<>的类或者接口，都属于带有类型参数的类或者接口，在使用这些类或者接口时，必须给<>中传递一个具体的引用数据类型。\n泛型技术：其实应用在编译时期，是给编译器使用的技术，到了运行时期，泛型就不存在了。\n为什么? 因为泛型的擦除：也就是说，编辑器检查了泛型的类型正确后，在生成的类文件中是没有泛型的。\n在运行时，如何知道获取的元素类型而不用强转呢？\n泛型的补偿：因为存储的时候，类型已经确定了是同一个类型的元素，所以在运行时，只要获取到该元素的类型，在内部进行一次转换即可，所以使用者不用再做转换动作了。\n什么时候用泛型类呢？泛型在集合框架中很常见\n当类中的操作的引用数据类型不确定的时候，以前用的Object来进行扩展的，现在可以用泛型来表示。这样可以避免强转的麻烦，而且将运行问题转移到的编译时期。\n----------------------------------------------------------\n泛型在程序定义上的体现：\n//泛型类：将泛型定义在类上。\nclass Tool<Q> {\n   private Q obj;\n   public  void setObject(Q obj) {\n       this.obj = obj;\n   }\n   public Q getObject() {\n       return obj;\n   }\n}\n//当方法操作的引用数据类型不确定的时候，可以将泛型定义在方法上。位置在返回值类型的前面,修饰符类型的后面.\n泛型类定义的泛型在整个类中有效\n当类被确定下来后,其引用数据类型也被确定,故要使用其他类型则需新建泛型类对象.也可将泛型定义在方法上.\n   public <W> void method(W w) {\n       System.out.println(\"method:\"+w);\n   }\n//静态方法上的泛型：静态方法无法访问类上定义的泛型。如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。\n   public static <Q> void function(Q t) {//注意位置\n       System.out.println(\"function:\"+t);\n   }\n//泛型接口.\ninterface Inter<T> {\n   void show(T t);\n}\nclass InterImpl<R> implements Inter<R> {//该情况为该类也不确定类型时使用\n   public void show(R r) {\n       System.out.println(\"show:\"+r);\n   }\n}\n\n\n泛型中的通配符\n可以解决当具体类型不确定的时候，这个通配符就是 ?  ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。用T,则可以对类型进行操作.\n泛型限定：\n   上限：？extends E：可以接收E类型或者E的子类型对象。\n   下限：？super E：可以接收E类型或者E的父类型对象。\n上限什么时候用：往集合中添加元素时，既可以添加E类型对象，又可以添加E的子类型对象。为什么？因为取的时候，E类型既可以接收E类对象，又可以接收E的子类型对象。\n下限什么时候用：当从集合中获取元素进行操作的时候，可以用当前元素的类型接收，也可以用当前元素的父类型接收。\n\n总结: 如果希望只取出,不插入,就使用 ? extends Hero.\n        如果希望只插入,不取出,就是用 ? extends Hero.\n\n泛型的细节：\n1）、泛型到底代表什么类型取决于调用者传入的类型，如果没传，默认是Object类型；\n2）、使用带泛型的类创建对象时，等式两边指定的泛型必须一致；\n  原因：编译器检查对象调用方法时只看变量，然而程序运行期间调用方法时就要考虑对象具体类型了；\n3）、等式两边可以在任意一边使用泛型，在另一边不使用(考虑向后兼容)；\nArrayList<String> al = new ArrayList<Object>(); //错\n\n//要保证左右两边的泛型具体类型一致就可以了，这样不容易出错。\nArrayList<? extends Object> al = new ArrayList<String>();\nal.add(\"aa\"); //错\n//因为集合具体对象中既可存储String，也可以存储Object的其他子类，所以添加具体的类型对象不合适，类型检查会出现安全问题。 ？extends Object 代表Object的子类型不确定，怎么能添加具体类型的对象呢？\npublic static void method(ArrayList<? extends Object> al) {\nal.add(\"abc\"); //错\n //只能对al集合中的元素调用Object类中的方法，具体子类型的方法都不能用，因为子类型不确定。\n}\n\n\nAPI--- java.lang.System: 属性和行为都是静态的。\nlong currentTimeMillis(); // 返回当前时间毫秒值\nexit();  // 退出虚拟机\nProperties getProperties() ;  // 获取当前系统的属性信息\nProperties prop = System.getProperties(); //获取系统的属性信息，并将这些信息存储到Properties集合中。\nSystem.setProperty(\"myname\",\"毕老师\"); //给系统属性信息集添加具体的属性信息\n//临时设置方式：运行jvm时，可以通过jvm的参数进行系统属性的临时设置，可以在java命令的后面加入 –D<name>=<value> 用法：java –Dmyname=小明 类名。\nString name = System.getProperty(\"os.name\");//获取指定属性的信息\n//想要知道该系统是否是该软件所支持的系统中的一个。\nSet<String> hs = new HashSet<String>();\nhs.add(\"Windows XP\");\nhs.add(\"Windows 7\");\nif(hs.contains(name))\n  System.out.println(\"可以支持\");\nelse\n  System.out.println(\"不支持\");\n\n\n\nAPI--- java.lang.Runtime: 类中没有构造方法，不能创建对象。\n但是有非静态方法。说明该类中应该定义好了对象，并可以通过一个static方法获取这个对象。用这个对象来调用非静态方法。这个方法就是 static Runtime getRuntime();\n这个Runtime其实使用单例设计模式进行设计。\nclass  RuntimeDemo {\n      public static void main(String[] args) throws Exception {\n             Runtime r = Runtime.getRuntime();\n             Process p = r.exec(\"notepad.exe SystemDemo.java\");      //运行指定的程序\n             Thread.sleep(4000);\n             p.destroy(); //杀掉进程\n      }\n}\n\n\n\nAPI--- java.util.Math: 用于数学运算的工具类，属性和行为都是静态的。该类是final不允许继承。\nstatic double ceil(double a) ; //返回大于指定数值的最小整数\nstatic double floor(double a) ; //返回小于指定数值的最大整数\nstatic long round(double a) ; //四舍五入成整数\nstatic double pow(double a, double b) ; //a的b次幂\nstatic double random(); //返回0~1的伪随机数\n      public static void main(String[] args) {\n             Random r = new Random();\n             for(int x=0; x<10; x++) {\n                    //double d = Math.floor(Math.random()*10+1);\n                    //int d  = (int)(Math.random()*10+1);\n                    int d = r.nextInt(10)+1;\n                    System.out.println(d);\n             }\n      }\n\n\nAPI--- java.util.Date：日期类，月份从0-11；\n\n    /*\n      日期对象和毫秒值之间的转换。\n      1，日期对象转成毫秒值。Date类中的getTime方法。\n      2，如何将获取到的毫秒值转成具体的日期呢？\n             Date类中的setTime方法。也可以通过构造函数。\n      */\n             //日期对象转成毫秒值\n             Date d = new Date();\n             long time1 = d.getTime();\n             long time2 = System.currentTimeMillis(); / /毫秒值。\n             \n             //毫秒值转成具体的日期\n             long time = 1322709921312l;\n             Date d = new Date();\n             d.setTime(time);\n/*\n      将日期字符串转换成日期对象：使用的就是DateFormat方法中的 Date parse(String source) ；\n      */\n      public static void method() throws Exception {\n             String str_time = \"2011/10/25\";\n             DateFormat df = new SimpleDateFormat(\"yyyy/MM/dd\"); //SimpleDateFormat作为可以指定用户自定义的格式来完成格式化。\n             Date d = df.parse(str_time);\n      }\n      /*\n      如果不需要使用特定的格式化风格，完全可以使用DateFormat类中的静态工厂方法获取具体的已经封装好风格的对象。getDateInstance();getDateTimeInstance();\n      */\n             Date d = new Date();\n             DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);\n             df = DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG);\n             String str_time = df.format(d);\n      //将日期对象转换成字符串的方式：DateFormat类中的format方法。\n          //创建日期格式对象。\n             DateFormat df = new SimpleDateFormat(); //该对象的建立内部会封装一个默认的日期格式。11-12-1 下午1:48\n             //如果想要自定义日期格式的话。可使用SimpleDateFormat的构造函数。将具体的格式作为参数传入到构造函数中。如何表示日期中年的部分呢？可以必须要参与格式对象文档。\n             df = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");\n             //调用DateFormat中的format方法。对已有的日期对象进行格式化。\n             String str_time = df.format(d);\n\n\nAPI--- java.util. Calendar：日历类\n\n     public static void method(){\n             Calendar c = Calendar.getInstance();\n             System.out.println(c.get(Calendar.YEAR)+\"年\"+(c.get(Calendar.MONTH)+1)+\"月\"\n                                         +getNum(c.get(Calendar.DAY_OF_MONTH))+\"日\"\n                                         +\"星期\"+getWeek(c.get(Calendar.DAY_OF_WEEK)));\n      }\n      public static String getNum(int num){\n             return num>9 ? num+\"\" : \"0\"+num;\n      }\n      public static String getWeek(int index){\n      /*\n      查表法：建立数据的对应关系.\n      最好：数据个数是确定的，而且有对应关系。如果对应关系的一方，是数字，而且可以作为角标，那么可以通过数组来作为表。\n      */\n             String[] weeks = {\"\",\"日\",\"一\",\"二\",\"三\",\"四\",\"五\",\"六\"};\n             return weeks[index];\n      }\n\n\nIO流：★★★★★，用于处理设备上数据。\n流：可以理解数据的流动，就是一个数据流。IO流最终要以对象来体现，对象都存在IO包中。\n流也进行分类：\n1：输入流（读）和输出流（写）。\n2：因为处理的数据不同，分为字节流和字符流。\n字节流\n处理字节数据的流对象。设备上的数据无论是图片或者dvd，文字，它们都以二进制存储的。二进制的最终都是以一个8位为数据单元进行体现，所以计算机中的最小数据单元就是字节。意味着，字节流可以处理设备上的所有数据，所以字节流一样可以处理字符数据。\n字符流\n因为字符每个国家都不一样，所以涉及到了字符编码问题，那么GBK编码的中文用unicode编码解析是有问题的，所以需要获取中文字节数据的同时+ 指定的编码表才可以解析正确数据。为了方便于文字的解析，所以将字节流和编码表封装成对象，这个对象就是字符流。只要操作字符数据，优先考虑使用字符流体系。\n注意：流的操作只有两种：读和写。\n流的体系因为功能不同，但是有共性内容，不断抽取，形成继承体系。该体系一共有四个基类，而且都是抽象类。\n字节流：InputStream  OutputStream\n字符流：Reader  Writer\n在这四个系统中，它们的子类，都有一个共性特点：子类名后缀都是父类名，前缀名都是这个子类的功能名称。\n\npublic static void main(String[] args) throws IOException { //读、写都会发生IO异常\n      /*\n      1：创建一个字符输出流对象，用于操作文件。该对象一建立，就必须明确数据存储位置，是一个文件。\n      2：对象产生后，会在堆内存中有一个实体，同时也调用了系统底层资源，在指定的位置创建了一个存储数据的文件。\n      3：如果指定位置，出现了同名文件，文件会被覆盖。\n      */\n      FileWriter fw = new FileWriter(\"demo.txt\"); // FileNotFoundException\n      /*\n      调用Writer类中的write方法写入字符串。字符串并未直接写入到目的地中，而是写入到了流中，(其实是写入到内存缓冲区中)。怎么把数据弄到文件中？\n      */\n      fw.write(\"abcde\");\n      fw.flush(); // 刷新缓冲区，将缓冲区中的数据刷到目的地文件中。\n      fw.close(); // 关闭流，其实关闭的就是java调用的系统底层资源。在关闭前，会先刷新该流。\n}\n\n\nclose()和flush()的区别：\nflush()：将缓冲区的数据刷到目的地中后，流可以使用。\nclose()：将缓冲区的数据刷到目的地中后，流就关闭了，该方法主要用于结束调用的底层资源。这个动作一定做。\n\n\nio异常的处理方式：io一定要写finally；\nFileWriter写入数据的细节：\n1：window中的换行符：\\r\\n两个符号组成。 linux：\\n。\n2：续写数据，只要在构造函数中传入新的参数true。\n3：目录分割符：window \\\\  /\npublic static void main(String[] args) {\n             FileWriter fw = null;\n             try {\n                    fw = new FileWriter(\"demo.txt\",true);\n                    fw.write(\"abcde\");\n             }\n             catch (IOException e ){\n                    System.out.println(e.toString()+\"....\");\n             }\n             finally{\n                    if(fw!=null)//可能在try中创建对象抛出异常\n                           try{\n                                  fw.close();\n                           }\n                           catch (IOException e){\n                                  System.out.println(\"close:\"+e.toString());\n                           }\n             }\n}\n\n\nFileReader\n使用Reader体系，read()方法,读取一个文本文件中的数据。返回 -1 ，标志读到结尾。\nimport java.io.*;\nclass  FileReaderDemo {\n      public static void main(String[] args) throws IOException {\n             /*\n             创建可以读取文本文件的流对象，FileReader让创建好的流对象和指定的文件相关联。\n             */\n             FileReader fr = new FileReader(\"demo.txt\");\n             int ch = 0;\n             while((ch = fr.read())!= -1) { //条件是没有读到结尾\n                    System.out.println((char)ch); //调用读取流的read方法，读取一个字符。\n             }\n             fr.close();//关闭该流并释放与之关联的所有资源\n      }\n}\n\n\n读取数据的第二种方式：第二种方式较为高效，自定义缓冲区。\nimport java.io.*;\nclass FileReaderDemo2 {\n      public static void main(String[] args) throws IOException {\n             FileReader fr = new FileReader(\"demo.txt\"); //创建读取流对象和指定文件关联。\n             //因为要使用read(char[])方法，将读取到字符存入数组。所以要创建一个字符数组，一般数组的长度都是1024的整数倍。\n             char[] buf = new char[1024];\n             int len = 0;\n             while(( len=fr.read(buf)) != -1) {\n                    System.out.println(new String(buf,0,len));\n             }\n             fr.close();\n      }\n}\n\n\nIO中的使用到了一个设计模式：装饰设计模式。灵活性较强\n装饰设计模式解决：对一组类进行功能的增强。\n包装：写一个类(包装类)对被包装对象进行包装；\n* 1、包装类和被包装对象要实现同样的接口；\n* 2、包装类要持有一个被包装对象；\n* 3、包装类在实现接口时，大部分方法是靠调用被包装对象来实现的，对于需要修改的方法我们自己实现；\n字符流：\nReader\n用于读取字符流的抽象类。子类必须实现的方法只有 read(char[], int, int) 和 close()。\n    |---BufferedReader：从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。 可以指定缓冲区的大小，或者可使用默认的大小。大多数情况下，默认值就足够大了。\n      |---LineNumberReader：跟踪行号的缓冲字符输入流。此类定义了方法 setLineNumber(int) 和 getLineNumber()，它们可分别用于设置和获取当前行号。\n    |---InputStreamReader：是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集。\n      |---FileReader：用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的。要自己指定这些值，可以先在 FileInputStream 上构造一个 InputStreamReader。\n    |---CharArrayReader：\n    |---StringReader：\n\n\nWriter\n写入字符流的抽象类。子类必须实现的方法仅有 write(char[], int, int)、flush() 和 close()。\n    |---BufferedWriter：将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。\n    |---OutputStreamWriter：是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集。\n      |---FileWriter：用来写入字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是可接受的。要自己指定这些值，可以先在 FileOutputStream 上构造一个 OutputStreamWriter。\n    |---PrintWriter：\n    |---CharArrayWriter：\n    |---StringWriter：\n\n\n字节流：\nInputStream\n是表示字节输入流的所有类的超类。\n    |--- FileInputStream：从文件系统中的某个文件中获得输入字节。哪些文件可用取决于主机环境。FileInputStream 用于读取诸如图像数据之类的原始字节流。要读取字符流，请考虑使用 FileReader。\n    |--- FilterInputStream：包含其他一些输入流，它将这些流用作其基本数据源，它可以直接传输数据或提供一些额外的功能。\n      |--- BufferedInputStream：该类实现缓冲的输入流。\n      |--- Stream：\n    |--- ObjectInputStream：\n    |--- PipedInputStream：\n-----------------------------------------------\nOutputStream\n此抽象类是表示输出字节流的所有类的超类。\n    |--- FileOutputStream：文件输出流是用于将数据写入 File 或 FileDescriptor 的输出流。\n    |--- FilterOutputStream：此类是过滤输出流的所有类的超类。\n      |--- BufferedOutputStream：该类实现缓冲的输出流。\n      |--- PrintStream：\n      |--- DataOutputStream：\n    |--- ObjectOutputStream：\n    |--- PipedOutputStream：\n\n\n缓冲区是提高效率用的，给谁提高呢？\nBufferedWriter\n是给字符输出流提高效率用的，那就意味着，缓冲区对象建立时，必须要先有流对象。明确要提高具体的流对象的效率。\n   FileWriter fw = new FileWriter(\"bufdemo.txt\");\n   BufferedWriter bufw = new BufferedWriter(fw);//让缓冲区和指定流相关联。\n   for(int x=0; x<4; x++){\n       bufw.write(x+\"abc\");\n       bufw.newLine(); //写入一个换行符，这个换行符可以依据平台的不同写入不同的换行符。\n       bufw.flush();//对缓冲区进行刷新，可以让数据到目的地中。\n   }\n   bufw.close();//关闭缓冲区，其实就是在关闭具体的流。\n\n\nBufferedReader：\n   FileReader fr = new FileReader(\"bufdemo.txt\");\n   BufferedReader bufr  = new BufferedReader(fr);\n   String line = null;\n   while((line=bufr.readLine())!=null){ //readLine方法返回的时候是不带换行符的。\n       System.out.println(line);\n   }\n   bufr.close();\n-----------------------------\n//记住，只要一读取键盘录入，就用这句话。\nBufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));\nBufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));//输出到控制台\nString line = null;\nwhile((line=bufr.readLine())!=null){\n   if(\"over\".equals(line))\n       break;\n   bufw.write(line.toUpperCase());//将输入的字符转成大写字符输出\n   bufw.newLine();\n   bufw.flush();\n   }\nbufw.close();\nbufr.close();\n\n\n\n\n流对象\n其实很简单，就是读取和写入。但是因为功能的不同，流的体系中提供N多的对象。那么开始时，到底该用哪个对象更为合适呢？这就需要明确流的操作规律。\n流的操作规律：\n1，明确源和目的。\n      数据源：就是需要读取，可以使用两个体系：InputStream、Reader；输入流\n      数据汇：就是需要写入，可以使用两个体系：OutputStream、Writer；输出流\n2，操作的数据是否是纯文本数据？\n      如果是(字符流)：数据源：Reader\n                数据汇：Writer\n      如果不是(字节流)：数据源：InputStream\n                  数据汇：OutputStream\n3，虽然确定了一个体系，但是该体系中有太多的对象，到底用哪个呢？\n      明确操作的数据设备。\n      数据源对应的设备：硬盘(File)，内存(数组)，键盘(System.in)\n      数据汇对应的设备：硬盘(File)，内存(数组)，控制台(System.out)。\n4，需要在基本操作上附加其他功能吗？比如缓冲。(提高效率)\n      如果需要就进行装饰。\n转换流特有功能\n转换流可以将字节转成字符，原因在于，将获取到的字节通过查编码表获取到指定对应字符。\n转换流的最强功能就是基于 字节流 + 编码表 。没有转换，没有字符流。\n发现转换流有一个子类就是操作文件的字符流对象：\nInputStreamReader\n      |--FileReader\nOutputStreamWriter\n      |--FileWrier\n想要操作文本文件，必须要进行编码转换，而编码转换动作转换流都完成了。所以操作文件的流对象只要继承自转换流就可以读取一个字符了。\n但是子类有一个局限性，就是子类中使用的编码是固定的，是本机默认的编码表，对于简体中文版的系统默认码表是GBK。\nFileReader fr = new FileReader(\"a.txt\");\nInputStreamReader isr = new InputStreamReader(new FileInputStream(\"a.txt\"),\"gbk\");\n以上两句代码功能一致，\n如果仅仅使用平台默认码表，就使用FileReader fr = new FileReader(\"a.txt\"); //因为简化。\n如果需要制定码表，必须用转换流。\n转换流 = 字节流+编码表。\n转换流的子类File = 字节流 + 默认编码表。\n凡是操作设备上的文本数据，涉及编码转换，必须使用转换流。\n\n\nFile类\n将文件系统中的文件和文件夹封装成了对象。提供了更多的属性和行为可以对这些文件和文件夹进行操作。这些是流对象办不到的，因为流只操作数据。\nFile类常见方法：\n1：创建。\n   boolean createNewFile()：在指定目录下创建文件，如果该文件已存在，则不创建。而对操作文件的输出流而言，输出流对象已建立，就会创建文件，如果文件已存在，会覆盖。除非续写。不同于输出流.\n   boolean mkdir()：创建此抽象路径名指定的目录。\n   boolean mkdirs()：创建多级目录。\n2：删除。\n   boolean delete()：删除此抽象路径名表示的文件或目录。\n   void deleteOnExit()：在虚拟机退出时删除。\n注意：在删除文件夹时，必须保证这个文件夹中没有任何内容，才可以将该文件夹用delete删除。\n   window的删除动作，是从里往外删。注意：java删除文件不走回收站。要慎用。\n3：获取.\n   long length()：获取文件大小。\n   String getName()：返回由此抽象路径名表示的文件或目录的名称。\n   String getPath()：将此抽象路径名转换为一个路径名字符串。你封装成什么就获取什么\n   String getAbsolutePath()：返回此抽象路径名的绝对路径名字符串。无论封装成什么都获取绝对路径\n   String getParent()：返回此抽象路径名父目录的抽象路径名，如果此路径名没有指定父目录，则返回 null。\nlong lastModified()：返回此抽象路径名表示的文件最后一次被修改的时间。\nFile.pathSeparator：返回当前系统默认的路径分隔符，windows默认为 “；”。\nFile.Separator：返回当前系统默认的目录分隔符，windows默认为 “\\”。\n4：判断：\n   boolean exists()：判断文件或者文件夹是否存在。\n   boolean isDirectory()：测试此抽象路径名表示的文件是否是一个目录。\n   boolean isFile()：测试此抽象路径名表示的文件是否是一个标准文件。\n   boolean isHidden()：测试此抽象路径名指定的文件是否是一个隐藏文件。\n   boolean isAbsolute()：测试此抽象路径名是否为绝对路径名。即使文件不存在也可判断\n5：重命名。\n    boolean renameTo(File dest)：可以实现移动的效果。剪切+重命名。//两个操作对象都是文件\nString[] list()：列出指定目录下的当前的文件和文件夹的名称。包含隐藏文件。\n如果调用list方法的File 对象中封装的是一个文件，那么list方法返回数组为null。如果封装的对象不存在也会返回null。只有封装的对象存在并且是文件夹时，这个方法才有效。根据FilenameFilter类的accept方法的返回值判定是否需要过滤文件\n\n\n递归：就是函数自身调用自身。\n\n什么时候用递归呢？\n当一个功能被重复使用，而每一次使用该功能时的参数不确定，都由上次的功能元素结果来确定。\n简单说：功能内部又用到该功能，但是传递的参数值不确定。(每次功能参与运算的未知内容不确定)。\n递归的注意事项：\n1：一定要定义递归的条件。\n2：递归的次数不要过多。容易出现 StackOverflowError 栈内存溢出错误。\n其实递归就是在栈内存中不断的加载同一个函数。\n------------------------------------------------------------------------------------------------\nJava.util.Properties\n\n一个可以将键值进行持久化存储的对象。Map--Hashtable的子类。\nMap\n      |--Hashtable\n             |--Properties：用于属性配置文件，键和值都是字符串类型。\n特点：1：可以持久化存储数据。2：键值都是字符串。3：一般用于配置文件。\n|-- load()：将流中的数据加载进集合。\n原理：其实就是将读取流和指定文件相关联，并读取一行数据，因为数据是规则的key=value，所以获取一行后，通过 = 对该行数据进行切割，左边就是键，右边就是值，将键、值存储到properties集合中。\n|-- store()：写入各个项后，刷新输出流。\n|-- list()：将集合的键值数据列出到指定的目的地。\n-------------------------------------------------------------------------------------------------\n以下介绍IO包中扩展功能的流对象：基本都是装饰设计模式。\nJava.io.outputstream.PrintStream：打印流\n1：提供了更多的功能，比如打印方法。可以直接打印任意类型的数据。(不修改类型)\n2：它有一个自动刷新机制，创建该对象，指定参数，对于指定方法可以自动刷新。\n3：它使用的本机默认的字符编码.\n4：该流的print方法不抛出IOException。\n该对象的构造函数。\nPrintStream(File file)  ：创建具有指定文件且不带自动行刷新的新打印流。\nPrintStream(File file, String csn) ：创建具有指定文件名称和字符集且不带自动行刷新的新打印流。\nPrintStream(OutputStream out) ：创建新的打印流。\nPrintStream(OutputStream out, boolean autoFlush) ：创建新的打印流。\nPrintStream(OutputStream out, boolean autoFlush, String encoding) ：创建新的打印流。\nPrintStream(String fileName) ：创建具有指定文件名称且不带自动行刷新的新打印流。\nPrintStream(String fileName, String csn)\nPrintStream可以操作目的：1：File对象。2：字符串路径。3：字节输出流。\n前两个都JDK1.5版本才出现。而且在操作文本文件时，可指定字符编码了。\n当目的是一个字节输出流时，如果使用的println方法，可以在printStream对象上加入一个true参数。这样对于println方法可以进行自动的刷新，而不是等待缓冲区满了再刷新。最终print方法都将具体的数据转成字符串，而且都对IO异常进行了内部处理。\n既然操作的数据都转成了字符串，那么使用PrintWriter更好一些。因为PrintWrite是字符流的子类，可以直接操作字符数据，同时也可以指定具体的编码。\n--------------------------------------------------------\nPrintWriter：具备了PrintStream的特点同时，还有自身特点：\n该对象的目的地有四个：1：File对象。2：字符串路径。3：字节输出流。4：字符输出流。\n开发时尽量使用PrintWriter。\n方法中直接操作文件的第二参数是编码表。\n直接操作输出流的，第二参数是自动刷新。\n//读取键盘录入将数据转成大写显示在控制台.\nBufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));//源：键盘输入\n//目的：把数据写到文件中，还想自动刷新。\nPrintWriter out = new PrintWriter(new FileWriter(\"out.txt\"),true);//设置true后自动刷新\nString line = null;\nwhile((line=bufr.readLine())!=null){\n   if(\"over\".equals(line))\n       break;\n   out.println(line.toUpperCase());//转大写输出\n}\n   //注意：System.in，System.out这两个标准的输入输出流，在jvm启动时已经存在了。随时可以使用。当jvm结束了，这两个流就结束了。但是，当使用了显示的close方法关闭时，这两个流在提前结束了。\nout.close();\nbufr.close();\n\n\n\n\nSequenceInputStream：序列流\n作用就是将多个读取流合并成一个读取流。实现数据合并。\n表示其他输入流的逻辑串联。它从输入流的有序集合开始，并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末尾为止。\n这样做，可以更方便的操作多个读取流，其实这个序列流内部会有一个有序的集合容器，用于存储多个读取流对象。\n该对象的构造函数参数是枚举，想要获取枚举，需要有Vector集合，但不高效。需用ArrayList，但ArrayList中没有枚举，只有自己去创建枚举对象。\n但是方法怎么实现呢？因为枚举操作的是具体集合中的元素，所以无法具体实现，但是枚举和迭代器是功能一样的，所以，可以用迭代替代枚举。\n合并原理：多个读取流对应一个输出流。\n切割原理：一个读取流对应多个输出流。\nimport java.io.*;\nimport java.util.*;\nclass  SplitFileDemo{\n   private static final String CFG = \".properties\";\n   private static final String SP = \".part\";\n   public static void main(String[] args) throws IOException{\n       File file = new File(\"c:\\\\0.bmp\");\n       File dir = new File(\"c:\\\\partfiles\");\n       meger(dir);\n   }\n   //数据的合并。\n   public static void meger(File dir)throws IOException{\n       if(!(dir.exists() && dir.isDirectory()))\n           throw new RuntimeException(\"指定的目录不存在，或者不是正确的目录\");\n       File[] files = dir.listFiles(new SuffixFilter(CFG));\n       if(files.length==0)\n           throw new RuntimeException(\"扩展名.proerpties的文件不存在\");\n       //获取到配置文件\n       File config = files[0];\n       //获取配置文件的信息。\n       Properties prop = new Properties();\n       FileInputStream fis = new FileInputStream(config);\n       prop.load(fis);\n       String fileName = prop.getProperty(\"filename\");\n       int partcount = Integer.parseInt(prop.getProperty(\"partcount\"));\n       //--------------------------\n       File[] partFiles = dir.listFiles(new SuffixFilter(SP));\n       if(partFiles.length!=partcount)\n           throw new RuntimeException(\"缺少碎片文件\");\n       //---------------------\n       ArrayList<FileInputStream> al = new ArrayList<FileInputStream>();\n       for(int x=0; x<partcount; x++){\n           al.add(new FileInputStream(new File(dir,x+SP)));\n       }\n       Enumeration<FileInputStream> en = Collections.enumeration(al);\n       SequenceInputStream sis = new SequenceInputStream(en);\n       File file = new File(dir,fileName);\n       FileOutputStream fos = new FileOutputStream(file);\n       byte[] buf = new byte[1024];\n       int len = 0;\n       while((len=sis.read(buf))!=-1){\n           fos.write(buf,0,len);\n       }\n       fos.close();\n       sis.close();\n   }\n   //带有配置信息的数据切割。\n   public static void splitFile(File file)throws IOException{\n       //用一个读取流和文件关联。\n       FileInputStream fis = new FileInputStream(file);\n       //创建目的地。因为有多个。所以先创建引用。\n       FileOutputStream fos = null;\n       //指定碎片的位置。\n       File dir = new File(\"c:\\\\partfiles\");\n       if(!dir.exists())\n           dir.mkdir();\n       //碎片文件大小引用。\n       File f = null;\n       byte[] buf = new byte[1024*1024];\n       //因为切割完的文件通常都有规律的。为了简单标记规律使用计数器。\n       int count = 0;\n       int len = 0;\n       while((len=fis.read(buf))!=-1){\n           f = new File(dir,(count++)+\".part\");\n           fos = new FileOutputStream(f);\n           fos.write(buf,0,len);\n           fos.close();\n       }\n       //碎片文件生成后，还需要定义配置文件记录生成的碎片文件个数。以及被切割文件的名称。\n       //定义简单的键值信息，可是用Properties。\n       String filename = file.getName();\n       Properties prop = new Properties();\n       prop.setProperty(\"filename\",filename);\n       prop.setProperty(\"partcount\",count+\"\");\n       File config = new File(dir,count+\".properties\");\n       fos = new FileOutputStream(config);\n       prop.store(fos,\"\");\n       fos.close();\n       fis.close();\n   }\n}\nclass SuffixFilter implements FileFilter{\n   private String suffix;\n   SuffixFilter(String suffix){\n       this.suffix  = suffix;\n   }\n   public boolean accept(File file){\n       return  file.getName().endsWith(suffix);\n   }\n}\n\n\nRandomAccessFile:\n特点：可实现数据的分段写入(运行多线程)\n1：该对象即可读取，又可写入。\n2：该对象中的定义了一个大型的byte数组，通过定义指针来操作这个数组。\n3：可以通过该对象的getFilePointer()获取指针的位置，通过seek()方法设置指针的位置。\n4：该对象操作的源和目的必须是文件。操作文件时还需要格式\n5：其实该对象内部封装了字节读取流和字节写入流。\n注意：实现随机访问，最好是数据有规律。\nclass RandomAccessFileDemo{\n   public static void main(String[] args) throws IOException{\n       write();\n       read();\n       randomWrite();\n   }\n   //随机写入数据，可以实现已有数据的修改。\n   public static void randomWrite()throws IOException{\n       RandomAccessFile raf = new RandomAccessFile(\"random.txt\",\"rw\");\n       raf.seek(8*4);\n       System.out.println(\"pos :\"+raf.getFilePointer());\n       raf.write(\"王武\".getBytes());\n       raf.writeInt(102);\n       raf.close();\n   }\n   public static void read()throws IOException{\n       RandomAccessFile raf = new RandomAccessFile(\"random.txt\",\"r\");//只读模式。\n       //指定指针的位置。\n       raf.seek(8*1);//实现随机读取文件中的数据。注意：数据最好有规律。\n       System.out.println(\"pos1 :\"+raf.getFilePointer());\n       byte[] buf = new byte[4];\n       raf.read(buf);\n       String name = new String(buf);\n       int age = raf.readInt();\n       System.out.println(name+\"::\"+age);\n       System.out.println(\"pos2 :\"+raf.getFilePointer());\n       raf.close();\n   }\n   public static void write()throws IOException{\n        //r: 不会创建文件,若不存在,则异常\n       //rw：当这个文件不存在，会创建该文件。当文件已存在，不会创建。所以不会像输出流一样覆盖。\n       RandomAccessFile raf = new RandomAccessFile(\"random.txt\",\"rw\");//rw读写模式\n       //往文件中写入人的基本信息，姓名，年龄。\n       raf.write(\"张三\".getBytes());\n       raf.writeInt(97);\n       raf.close();\n   }\n}\n\n\n\n管道流\n管道读取流和管道写入流可以像管道一样对接上，管道读取流就可以读取管道写入流写入的数据。\n注意：需要加入多线程技术，因为单线程，先执行read，会发生死锁，因为read方法是阻塞式的，没有数据的read方法会让线程等待。\npublic static void main(String[] args) throws IOException{\n   PipedInputStream pipin = new PipedInputStream();\n   PipedOutputStream pipout = new PipedOutputStream();\n   pipin.connect(pipout);\n   new Thread(new Input(pipin)).start();\n   new Thread(new Output(pipout)).start();\n}\n\n\n\n对象的序列化\n目的：将一个具体的对象进行持久化，写入到硬盘上。\n注意：静态数据不能被序列化，因为静态数据不在堆内存中，是存储在静态方法区中。\n如何将非静态的数据不进行序列化？用transient(保证其值在堆内存中存在,而不在文本文件中存在) 关键字修饰此变量即可。\nSerializable：用于启动对象的序列化功能，可以强制让指定类具备序列化功能，该接口中没有成员，这是一个标记接口。这个标记接口用于给序列化类提供UID。这个uid是依据类中的成员的数字签名进行运行获取的。如果不需要自动获取一个uid，可以在类中，手动指定一个名称为serialVersionUID id号。依据编译器的不同，或者对信息的高度敏感性。最好每一个序列化的类都进行手动显示的UID的指定。\nimport java.io.*;\nclass ObjectStreamDemo {\n   public static void main(String[] args) throws Exception{\n       writeObj();\n       readObj();\n   }\n   public static void readObj()throws Exception{\n       ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"obj.txt\"));\n       Object obj = ois.readObject();//读取一个对象。\n       System.out.println(obj.toString());\n   }\n   public static void writeObj()throws IOException{\n       ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"obj.txt\"));\n       oos.writeObject(new Person(\"lisi\",25)); //写入一个对象。\n       oos.close();\n   }\n}\nclass Person implements Serializable{\n   private static final long serialVersionUID = 42L;\n   private transient String name;//用transient修饰后name将不会进行序列化\n   public int age;\n   Person(String name,int age){\n       this.name = name;\n       this.age = age;\n   }\n   public String toString(){\n       return name+\"::\"+age;\n   }\n}\n\n\n\nDataOutputStream、DataInputStream\n专门用于操作基本数据类型数据的对象。\nDataOutputStream dos =  new DataOutputStream(new FileOutputStream(\"data.txt\"));\n   dos.writeInt(256);\n   dos.close();\n   DataInputStream dis = new DataInputStream(new FileInputStream(\"data.txt\"));\n   int num = dis.readInt();\n   System.out.println(num);\n   dis.close();\n\n\nByteArrayInputStream：源：内存    ArrayStream\nByteArrayOutputStream：目的：内存。\n这两个流对象不涉及底层资源调用，操作的都是内存中数组，所以不需要关闭。\n直接操作字节数组就可以了，为什么还要把数组封装到流对象中呢？因为数组本身没有方法，只有一个length属性。为了便于数组的操作，将数组进行封装，对外提供方法操作数组中的元素。\n对于数组元素操作无非两种操作：设置（写）和获取（读），而这两操作正好对应流的读写操作。这两个对象就是使用了流的读写思想来操作数组。\n//创建源：\n   ByteArrayInputStream bis = new ByteArrayInputStream(\"abcdef\".getBytes());将字符串转换成Byte数组\n   //创建目的：\n   ByteArrayOutputStream bos = new ByteArrayOutputStream();\n   int ch = 0;\n   while((ch=bis.read())!=-1){\n       bos.write(ch);\n   }\n   System.out.println(bos.toString());\n\n\n网络编程\nIP找主机,端口找程序\n端口：\n物理端口：\n逻辑端口：用于标识进程的逻辑地址，不同进程的标识；有效端口：0~65535，其中0~1024系统使用或保留端口。\njava 中ip对象：InetAddress.\nimport java.net.*;\nclass  IPDemo{\n   public static void main(String[] args) throws UnknownHostException{\n       //通过名称(ip字符串or主机名)来获取一个ip对象。\n       InetAddress ip = InetAddress.getByName(\"www.baidu.com\");//java.net.UnknownHostException\n       System.out.println(\"addr:\"+ip.getHostAddress());\n       System.out.println(\"name:\"+ip.getHostName());\n   }\n}\n\n\nSocket：★★★★，套接字，通信的端点。\n就是为网络服务提供的一种机制，通信的两端都有Socket，网络通信其实就是Socket间的通信，数据在两个Socket间通过IO传输。\nUDP传输：\n1，只要是网络传输，必须有socket 。\n2，数据一定要封装到数据包中，数据包中包括目的地址、端口、数据等信息。\n直接操作udp不可能，对于java语言应该将udp封装成对象，易于我们的使用，这个对象就是DatagramSocket. 封装了udp传输协议的socket对象。\n因为数据包中包含的信息较多，为了操作这些信息方便，也一样会将其封装成对象。这个数据包对象就是：DatagramPacket.通过这个对象中的方法，就可以获取到数据包中的各种信息。\nDatagramSocket具备发送和接受功能，在进行udp传输时，需要明确一个是发送端，一个是接收端。\nudp的发送端：\n1，建立udp的socket服务，创建对象时如果没有明确端口，系统会自动分配一个未被使用的端口。\n2，明确要发送的具体数据。\n3，将数据封装成了数据包。\n4，用socket服务的send方法将数据包发送出去。\n5，关闭资源。\n\nimport java.net.*;\nclass  UdpSend{\n   public static void main(String[] args)throws Exception {\n//      1，建立udp的socket服务。\n       DatagramSocket ds = new DatagramSocket(8888);//指定发送端口，不指定系统会随机分配。\n//      2，明确要发送的具体数据。\n       String text = \"udp传输演示 哥们来了\";\n       byte[] buf = text.getBytes();\n//      3，将数据封装成了数据包。\n       DatagramPacket dp = new DatagramPacket(buf,\nbuf.length,InetAddress.getByName(\"10.1.31.127\"),10000);\n//      4，用socket服务的send方法将数据包发送出去。\n       ds.send(dp);\n//      5，关闭资源。\n       ds.close();\n   }\n}\n\n\n\nudp的接收端：\n1，创建udp的socket服务，必须要明确一个端口，作用在于，只有发送到这个端口的数据才是这个接收端可以处理的数据。\n2，定义数据包，用于存储接收到数据。\n3，通过socket服务的接收方法将收到的数据存储到数据包中。\n4，通过数据包的方法获取数据包中的具体数据内容，比如ip、端口、数据等等。\n5，关闭资源。\nclass UdpRece {\n   public static void main(String[] args) throws Exception{\n//      1，创建udp的socket服务。\n       DatagramSocket ds = new DatagramSocket(10000);\n//      2，定义数据包，用于存储接收到数据。先定义字节数组，数据包会把数据存储到字节数组中。\n       byte[] buf = new byte[1024];\n       DatagramPacket dp = new DatagramPacket(buf,buf.length);\n//      3，通过socket服务的接收方法将收到的数据存储到数据包中。\n       ds.receive(dp);//该方法是阻塞式方法。\n//      4，通过数据包的方法获取数据包中的具体数据内容，比如ip，端口，数据等等。\n       String ip = dp.getAddress().getHostAddress();\n       int port = dp.getPort();\n       String text = new String(dp.getData(),0,dp.getLength());//将字节数组中的有效部分转成字符串。\n       System.out.println(ip+\":\"+port+\"--\"+text);\n//      5，关闭资源。\n       ds.close();\n   }\n}\n\n\nTCP传输：两个端点的建立连接后会有一个传输数据的通道，这通道称为流，而且是建立在网络基础上的流，称之为socket流。该流中既有读取，也有写入。\ntcp的两个端点：一个是客户端，一个是服务端。\n客户端：对应的对象，Socket\n服务端：对应的对象，ServerSocket\nTCP客户端：应先启动服务端\n1，建立tcp的socket服务，最好明确具体的地址和端口。这个对象在创建时，就已经可以对指定ip和端口进行连接(三次握手)。\n2，如果连接成功，就意味着通道建立了，socket流就已经产生了。只要获取到socket流中的读取流和写入流即可，只要通过getInputStream和getOutputStream就可以获取两个流对象。\n3，关闭资源。\nimport java.net.*;\nimport java.io.*;\n//需求：客户端给服务器端发送一个数据。\nclass  TcpClient{\n   public static void main(String[] args) throws Exception{\n       Socket s = new Socket(\"10.1.31.69\",10002);\n       OutputStream out = s.getOutputStream();//获取了socket流中的输出流对象。\n       out.write(\"tcp演示，哥们又来了!\".getBytes());\n       s.close();\n   }\n}\n\n\nTCP服务端：\n1，创建服务端socket服务，并监听一个端口。\n2，服务端为了给客户端提供服务，获取客户端的内容，可以通过accept方法(阻塞式)获取连接过来的客户端对象。\n3，可以通过获取到的socket对象中的socket流和具体的客户端进行通讯。\n4，如果通讯结束，关闭资源。注意：要先关客户端，再关服务端。\nclass  TcpServer{\n   public static void main(String[] args) throws Exception{\n       ServerSocket ss = new ServerSocket(10002);//建立服务端的socket服务\n       Socket s = ss.accept();//获取客户端对象\n       String ip = s.getInetAddress().getHostAddress();\n       System.out.println(ip+\".....connected\");\n//      可以通过获取到的socket对象中的socket流和具体的客户端进行通讯。\n       InputStream in = s.getInputStream();//读取客户端的数据，使用客户端对象的socket读取流\n       byte[] buf = new byte[1024];\n       int len = in.read(buf);\n       String text = new String(buf,0,len);\n       System.out.println(text);\n//      如果通讯结束，关闭资源。注意：要先关客户端，在关服务端。\n       s.close();\n       ss.close();\n   }\n}\n\n\n反射技术\n其实就是动态加载一个指定的类，并获取该类中的所有的内容。而且将字节码文件封装成对象，并将字节码文件中的内容都封装成对象，这样便于操作这些成员。简单说：反射技术可以对一个类进行解剖。\n反射的好处：大大的增强了程序的扩展性。\n反射的基本步骤：\n1、获得Class对象，就是获取到指定的名称的字节码文件对象。\n2、实例化对象，获得类的属性、方法或构造函数。\n3、访问属性、调用方法、调用构造函数创建对象。\n获取这个Class对象，有三种方式：\n1：通过每个对象都具备的方法getClass来获取。弊端：必须要创建该类对象，才可以调用getClass方法。\n2：每一个数据类型(基本数据类型和引用数据类型)都有一个静态的属性class。弊端：必须要先明确该类。\n    前两种方式不利于程序的扩展，因为都需要在程序使用具体的类来完成。\n3：使用的Class类中的方法，静态的forName方法。\n    指定什么类名，就获取什么类字节码文件对象，这种方式的扩展性最强，只要将类名的字符串传入即可。\n// 1. 根据给定的类名来获得  用于类加载\nString classname = \"cn.itcast.reflect.Person\";// 来自配置文件\nClass clazz = Class.forName(classname);// 此对象代表Person.class\n// 2. 如果拿到了对象，不知道是什么类型   用于获得对象的类型\nObject obj = new Person();\nClass clazz1 = obj.getClass();// 获得对象具体的类型\n// 3. 如果是明确地获得某个类的Class对象  主要用于传参\nClass clazz2 = Person.class;\n\n\n反射的用法：\n1）、需要获得java类的各个组成部分，首先需要获得类的Class对象，获得Class对象的三种方式：\n      Class.forName(classname) 用于做类加载\n      obj.getClass()                      用于获得对象的类型\n      类名.class                       用于获得指定的类型，传参用\n2)、反射类的成员方法：\n      Class clazz = Person.class;\n      Method method = clazz.getMethod(methodName, new Class[]{paramClazz1, paramClazz2});\n      method.invoke();\n     \n3)、反射类的构造函数：\n      Constructor con = clazz.getConstructor(new Class[]{paramClazz1, paramClazz2,...})\n      con.newInstance(params...)\n4)、反射类的属性：\n      Field field = clazz.getField(fieldName);\n      field.setAccessible(true);\n      field.setObject(value);\n\n\n获取了字节码文件对象后，最终都需要创建指定类的对象：\n创建对象的两种方式(其实就是对象在进行实例化时的初始化方式)：\n1，调用空参数的构造函数：使用了Class类中的newInstance()方法。\n2，调用带参数的构造函数：先要获取指定参数列表的构造函数对象，然后通过该构造函数的对象的newInstance(实际参数) 进行对象的初始化。\n综上所述，第二种方式，必须要先明确具体的构造函数的参数类型，不便于扩展。所以一般情况下，被反射的类，内部通常都会提供一个公有的空参数的构造函数。\n   // 如何生成获取到字节码文件对象的实例对象。\n       Class clazz = Class.forName(\"cn.itcast.bean.Person\");//类加载\n// 直接获得指定的类型\n      clazz = Person.class;\n      // 根据对象获得类型\n      Object obj = new Person(\"zhangsan\", 19);\n      clazz = obj.getClass();\n       Object obj = clazz.newInstance();//该实例化对象的方法调用就是指定类中的空参数构造函数，给创建对象进行初始化。当指定类中没有空参数构造函数时，该如何创建该类对象呢？请看method_2();\n   public static void method_2() throws Exception {\n       Class clazz = Class.forName(\"cn.itcast.bean.Person\");\n       //既然类中没有空参数的构造函数,那么只有获取指定参数的构造函数,用该函数来进行实例化。\n       //获取一个带参数的构造器。\n       Constructor constructor = clazz.getConstructor(String.class,int.class);\n       //想要对对象进行初始化，使用构造器的方法newInstance();\n       Object obj = constructor.newInstance(\"zhagnsan\",30);\n       //获取所有构造器。\n       Constructor[] constructors = clazz.getConstructors();//只包含公共的\n       constructors = clazz.getDeclaredConstructors();//包含私有的\n       for(Constructor con : constructors) {\n           System.out.println(con);\n       }\n   }\n\n\n反射指定类中的方法：\n   //获取类中所有的方法。\n   public static void method_1() throws Exception {\n       Class clazz = Class.forName(\"cn.itcast.bean.Person\");\n       Method[] methods = clazz.getMethods();//获取的是该类中的公有方法和父类中的公有方法。\n       methods = clazz.getDeclaredMethods();//获取本类中的方法，包含私有方法。\n       for(Method method : methods) {\n           System.out.println(method);\n       }\n   }\n   //获取指定方法；\n   public static void method_2() throws Exception {\n       Class clazz = Class.forName(\"cn.itcast.bean.Person\");\n       //获取指定名称的方法。\n       Method method = clazz.getMethod(\"show\", int.class,String.class);\n       //想要运行指定方法，当然是方法对象最清楚，为了让方法运行，调用方法对象的invoke方法即可，但是方法运行必须要明确所属的对象和具体的实际参数。\n       Object obj = clazz.newInstance();\n       method.invoke(obj, 39,\"hehehe\");//执行一个方法\n   }\n   //想要运行私有方法。\n   public static void method_3() throws Exception {\n       Class clazz = Class.forName(\"cn.itcast.bean.Person\");\n       //想要获取私有方法。必须用getDeclearMethod();\n       Method method = clazz.getDeclaredMethod(\"method\", null);\n       // 私有方法不能直接访问，因为权限不够。非要访问，可以通过暴力的方式。\n       method.setAccessible(true);//一般很少用，因为私有就是隐藏起来，所以尽量不要访问。\n   }\n   //反射静态方法。\n   public static void method_4() throws Exception {\n       Class clazz = Class.forName(\"cn.itcast.bean.Person\");\n       Method method = clazz.getMethod(\"function\",null);\n       method.invoke(null,null);\n   }\n\n\n正则表达式：★★★☆，其实是用来操作字符串的一些规则。\n好处：正则的出现，对字符串的复杂操作变得更为简单。\n特点：将对字符串操作的代码用一些符号来表示。只要使用了指定符号，就可以调用底层的代码对字符串进行操作。符号的出现，简化了代码的书写。\n弊端：符号的出现虽然简化了书写，但是却降低了阅读性。\n其实更多是用正则解决字符串操作的问题。\n组\n用小括号标示，每定义一个小括号，就是一个组，而且有自动编号，从1开始。\n   只要使用组，对应的数字就是使用该组的内容。别忘了，数组要加\\\\。\n   (aaa(wwww(ccc))(eee))技巧，从左括号开始数即可。有几个左括号就是几组。\n常见操作：\n1，匹配：其实用的就是String类中的matches方法。\nString reg = \"[1-9][0-9]{4,14}\";\n   boolean b = qq.matches(reg);//将正则和字符串关联对字符串进行匹配。\n2，切割：其实用的就是String类中的split方法。\n3，替换：其实用的就是String类中的replaceAll();\n4，获取：\n  1），先要将正则表达式编译成正则对象。使用的是Pattern中静态方法 compile(regex);\n  2），通过Pattern对象获取Matcher对象。\n      Pattern用于描述正则表达式，可以对正则表达式进行解析。\n      而将规则操作字符串，需要从新封装到匹配器对象Matcher中。\n      然后使用Matcher对象的方法来操作字符串。\n      如何获取匹配器对象呢？\n      通过Pattern对象中的matcher方法。该方法可以正则规则和字符串想关联。并返回匹配器对象。\n  3），使用Matcher对象中的方法即可对字符串进行各种正则操作。\n","tags":["java"],"categories":["mytech"]},{"title":"工具使用-Git笔记","url":"/posts/1415913582/","content":"# 工具使用 | Git 笔记\n\n@[toc]\n## **1、git提交文件到仓库——多次add,一次commit**\n<!-- more -->\n为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：\n\n```shell\ngit add file1.txt\ngit add file2.txt file3.txt\ngit commit -m \"add 3 files.\"\n```\n\n**小结**\n\n现在总结一下今天学的两点内容：\n\n初始化一个Git仓库，使用git init命令。\n\n添加文件到Git仓库，分两步：\n\n使用命令git add ，注意，可反复多次使用，添加多个文件；\n\n使用命令git commit -m ，完成。\n\n------\n\n##  **2、当本地修改了文件时候，如何提交与版本控制** \n\n```shell\ngit status #查看当前状态\ngit diff readme.txt # 查看文件readme.txt哪几行发生了增减\n```\n\n**小结**\n\n要随时掌握工作区的状态，使用git status命令。\n\n如果git status告诉你有文件被修改过，用git diff可以查看修改内容。\n\n------\n\n## **3、穿梭未来–回到过去**\n\n`HEAD`指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令`git reset --hard commit_id`。\n\n穿梭前，用`git log`可以查看提交历史，以便确定要回退到哪个版本。\n\n要重返未来，用`git reflog`查看命令历史，以便确定要回到未来的哪个版本。\n\n------\n\n## **4、git工作区与缓存区**\n\n工作区是当前的目录，缓冲区是可以保存多次文件修改的地方，使用`git add <file>`将工作区的修改内容提交到缓冲区。\n\n版本库是`.git`文件，利用`git commit -m \"comment\"`可以将缓冲区的所有修改一次性全部提交到版本库`.git`中。\n\n在Git中，用`HEAD`表示版本库当前版本，也就是最新的提交`1094adb...`\n(**实际上HEAD指向的master分支，master指向最新的一次提交1094adb...**)，注意我的提交ID和你的肯定不一样，上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，当然往上100个版本写100个^比较容易数不过来，所以写成`HEAD~100`。\n\n------\n\n## **5、管理修改**\n\n用`git diff HEAD -- readme.txt`命令可以查看版本库里面最新版本和工作区的区别\n\n**小结**\n\n第一次修改 -> `git add`-> 第二次修改 -> `git add`-> `git commit`\n好，现在，把第二次修改提交了，\n\n然后开始小结。\n理解了Git是如何跟踪修改的，每次修改，如果不用git add到暂存区，那就不会加入到commit中。\n\n------\n\n## **6、撤销修改**\n\n命令`git checkout -- readme.txt`意思就是，把`readme.txt`文件在工作区的修改全部撤销，这里有两种情况：\n\n一种是`readme.txt`自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库[一模一样](https://www.baidu.com/s?wd=%E4%B8%80%E6%A8%A1%E4%B8%80%E6%A0%B7&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)的状态；\n\n一种是`readme.txt`已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n\n总之，就是让这个文件回到最近一次`git commit`或`git add`时的状态。\n\n**小结**\n\n`git checkout -- file`命令中的`--`很重要，没有`--`，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git `checkout`命令。\n\n------\n\n## **7、删除本地文件后如何与版本库同步**\n\n现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令`git rm`删掉，并且`git commit`：\n\n```shell\n$ git rm test.txt\nrm 'test.txt'\n$ git commit -m \"remove test.txt\"\n[master d46f35e] remove test.txt\n 1 file changed, 1 deletion(-)\n delete mode 100644 test.txt\n```\n\n**小结**\n\n命令`git rm <file>`用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。\n\n------\n\n## **8、远程仓库**\n\n**1.添加远程库**\n\n要将**本地的版本库**关联一个**远程库(一般用origin表示远程库)**，使用命令`git remote add origin git@server-name:path/repo-name.git`；\n\n关联后，使用命令`git push -u origin master`第一次推送本地版本库`master`分支的所有内容；\n\n说明：我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n此后，每次本地提交后，只要有必要，就可以使用命令`git push origin master`推送最新修改。\n\n**2.从远程库克隆**\n\nGit支持多种协议，包括`https`，但通过`ssh`支持的原生`git`协议速度最快。\n\n如：`git clone git@github.com:michaelliao/gitskills.git`即可。\n\n------\n\n## **9、分支管理**\n\n**1.创建与合并分支**\n\n首先，我们创建dev分支，然后切换到dev分支：\n\n```shell\ngit checkout -b dev\n\nSwitched to a new branch 'dev'\n\ngit checkout命令加上-b参数表示创建并切换，相当于以下两条命令：\n\n$ git branch dev\n$ git checkout dev\nSwitched to branch 'dev'\n然后，用git branch命令查看当前分支：\n\n$ git branch\n* dev\n  master\ngit branch命令会列出所有分支，当前分支前面会标一个*号。\n\n然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：\nCreating a new branch is quick.\n\n然后提交：\n$ git add readme.txt \n$ git commit -m \"branch test\"\n[dev b17d20e] branch test\n 1 file changed, 1 insertion(+)\n \n现在，dev分支的工作完成，我们就可以切换回master分支：\n$ git checkout master\nSwitched to branch 'master'\n\n切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：\n\n现在，我们把dev分支的工作成果合并到master分支上：\n$ git merge dev\nUpdating d46f35e..b17d20e\nFast-forward\n readme.txt | 1 +\n 1 file changed, 1 insertion(+)\ngit merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。\n\n注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。\n\n当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。\n\n合并完成后，就可以放心地删除dev分支了：\n$ git branch -d dev\nDeleted branch dev (was b17d20e).\n删除后，查看branch，就只剩下master分支了：\n\n$ git branch\n* master\n因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。\n```\n\n**小结**\n\nGit鼓励大量使用分支：\n\n查看分支：`git branch`\n\n创建分支：`git branch <name>`\n\n切换分支：`git checkout <name>`\n\n创建+切换分支：`git checkout -b <name>`\n\n合并某分支到当前分支：`git merge <name>`\n\n删除分支：`git branch -d <name>`\n\n------\n\n**2.解决冲突**\n\n我们可以直接查看readme.txt的内容：\n\n```shell\nGit is a distributed version control system.\nGit is free software distributed under the GPL.\nGit has a mutable index called stage.\nGit tracks changes of files.\n<<<<<<< HEAD\nCreating a new branch is quick & simple.\n=======\nCreating a new branch is quick AND simple.\n>>>>>>> feature1\n```\n\nGit用`<<<<<<<，=======，>>>>>>>`标记出不同分支的内容，我们修改如下后保存：\n\n`Creating a new branch is quick and simple.`\n\n再提交：\n\n```shell\n$ git add readme.txt \n$ git commit -m \"conflict fixed\"\n[master cf810e4] conflict fixed\n```\n\n现在，master分支和feature1分支使用下面命令查看：\n`git log --graph --pretty=oneline --abbrev-commit`\n\n或者是`git log --graph`查看解决矛盾图。\n\n------\n\n**3.分支合并策略**\n\n`--no-ff`表示普通合并，合并后可以看得到分支，而 fast-farwaef模式看不到分支，\n\n格式：`git merge --no-ff -m \"merge with no-ff\" dev`\n\n------\n\n**4.bug分支**\n\n```shell\nBug分支\n软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。\n\n当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：\n\n$ git status\nOn branch dev\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n    new file:   hello.py\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   readme.txt\n并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？\n\n幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：\n\n$ git stash\nSaved working directory and index state WIP on dev: f52c633 add merge\n现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。\n\n首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：\n\n$ git checkout master\nSwitched to branch 'master'\nYour branch is ahead of 'origin/master' by 6 commits.\n  (use \"git push\" to publish your local commits)\n\n\n$ git checkout -b issue-101\nSwitched to a new branch 'issue-101'\n现在修复bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交：\n\n\n$ git add readme.txt \n$ git commit -m \"fix bug 101\"\n[issue-101 4c805e2] fix bug 101\n 1 file changed, 1 insertion(+), 1 deletion(-)\n修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：\n\n\n$ git checkout master\nSwitched to branch 'master'\nYour branch is ahead of 'origin/master' by 6 commits.\n  (use \"git push\" to publish your local commits)\n\n$ git merge --no-ff -m \"merged bug fix 101\" issue-101\nMerge made by the 'recursive' strategy.\n readme.txt | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！\n\n$ git checkout dev\nSwitched to branch 'dev'\n\n\n$ git status\nOn branch dev\nnothing to commit, working tree clean\n工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：\n\n\n$ git stash list\nstash@{0}: WIP on dev: f52c633 add merge\n工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：\n```\n\n```shell\n一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；\n\n\n另一种方式是用git stash pop，恢复的同时把stash内容也删了：\n\n$ git stash pop\nOn branch dev\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    new file:   hello.py\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   readme.txt\n\nDropped refs/stash@{0} (5d677e2ee266f39ea296182fb2354265b91b3b2a)\n再用git stash list查看，就看不到任何stash内容了：\n\n$ git stash list\n你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：\n\n$ git stash apply stash@{0}\n```\n\n-  ​\n\n**小结**\n\n修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n\n当手头工作没有完成时，先把工作现场`git stash`一下，然后去修复bug，修复后，再`git stash pop`，\n\n------\n\n**5.feature 分支**\n\n```shell\n添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。\n\n现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。\n\n于是准备开发：~~++*此时我们是在dev分支上进行的开发*++~~。\n\n$ git checkout -b feature-vulcan\nSwitched to a new branch 'feature-vulcan'\n5分钟后，开发完毕：\n\n$ git add vulcan.py\n\n$ git status\nOn branch feature-vulcan\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n  \n    new file:   vulcan.py\n\n$ git commit -m \"add feature vulcan\"\n[feature-vulcan 287773e] add feature vulcan\n 1 file changed, 2 insertions(+)\n create mode 100644 vulcan.py\n切回dev，准备合并：\n\n$ git checkout dev\n一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。\n\n\n但是！\n\n就在此时，接到上级命令，因经费不足，新功能必须取消！\n虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：\n\n$ git branch -d feature-vulcan\nerror: The branch 'feature-vulcan' is not fully merged.\nIf you are sure you want to delete it, run 'git branch -D feature-vulcan'.\n销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。\n\n\n现在我们强行删除：\n\n\n$ git branch -D feature-vulcan\nDeleted branch feature-vulcan (was 287773e).\n终于删除成功！\n```\n\n**小结**\n\n开发一个新`feature`，最好新建一个分支；\n\n如果要丢弃一个没有被合并过的分支，可以通过`git branch -D <name>`强行删除。\n\n------\n\n## **10、多人协作**\n\n多人协作的工作模式通常是这样：\n\n1.首先，可以试图用`git push origin <branch-name>`推送自己的修改；\n\n2如果推送失败，则因为远程分支比你的本地更新，需要先用`git pull`试图合并；\n\n3如果合并有冲突，则解决冲突，并在本地提交；\n\n4没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！\n\n如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to origin/。\n\n这就是多人协作的工作模式，一旦熟悉了，就非常简单。\n\n**小结**\n\n1查看远程库信息，使用`git remote -v`；\n\n2本地新建的分支如果不推送到远程，对其他人就是不可见的；\n\n3从本地推送分支，使用`git push origin branch-name`，如果推送失败，先用`git pull`抓取远程的新提交；\n\n4在本地创建和远程分支对应的分支，使用`git checkout -b branch-name origin/branch-name`，本地和远程分支的名称最好一致；\n\n5建立本地分支和远程分支的关联，使用`git branch --set-upstream branch-name origin/branch-name`；\n\n6从远程抓取分支，使用`git pull`，如果有冲突，要先处理冲突。\n\n------\n\n## **11、多人协作-rebase**\n[link](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0015266568413773c73cdc8b4ab4f9aa9be10ef3078be3f000)\n\n**小结**\n\nrebase操作可以把本地未push的分叉提交历史整理成直线；\n\nrebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比\n\n------\n\n## **12、打tag以及修改tag**\n\n**1.打标签tag**\n\n命令`git tag <tagname>`用于新建一个标签，默认为HEAD，也可以指定一个`commit id`；\n\n命令`git tag -a <tagname> -m \"blablabla...\"`可以指定标签信息；\n\n命令`git tag`可以查看所有标签。\n\n标签不是按时间顺序列出，而是按字母排序的。可以用`git show <tagname>`查看标签信息。\n\n注意：标签总是和某个`commit`挂钩。如果这个`commit`既出现在````master`分支，又出现`在dev```分支，那么在这两个分支上都可以看到这个标签.\n\n**2.修改tag**\n\n删除标签 `git tag -d v0.1`\n\n如果要推送某个标签到远程，使用命令`git push origin <tagname>`：\n\n```shell\n$ git push origin v1.0\nTotal 0 (delta 0), reused 0 (delta 0)\nTo github.com:michaelliao/learngit.git\n * [new tag]         v1.0 -> v1.0\n或者，一次性推送全部尚未推送到远程的本地标签：\n\n\n$ git push origin --tags\nTotal 0 (delta 0), reused 0 (delta 0)\nTo github.com:michaelliao/learngit.git\n * [new tag]         v0.9 -> v0.9\n如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：\n\n\n$ git tag -d v0.9\nDeleted tag 'v0.9' (was f52c633)\n然后，从远程删除。删除命令也是push，但是格式如下：\n\n\n$ git push origin :refs/tags/v0.9\nTo github.com:michaelliao/learngit.git\n - [deleted]         v0.9\n```\n\n要看看是否真的从远程库删除了标签，可以登陆GitHub查看。\n\n**小结**\n\n命令`git push origin <tagname>`可以推送一个本地标签；\n\n命令`git push origin --tags`可以推送全部未推送过的本地标签；\n\n命令`git tag -d <tagname>`可以删除一个本地标签；\n\n命令`git push origin :refs/tags/<tagname>`可以删除一个远程标签。\n\n------\n\n## **13、github使用**\n\n在GitHub上，可以任意Fork开源仓库；\n\n自己拥有Fork后的仓库的读写权限；\n\n可以推送pull request给官方仓库来贡献代码","tags":["Git","工具"],"categories":["mytech"]},{"title":"分治 芯片测试","url":"/posts/2307581756/","content":"# 1. 芯片测试\n在讲解具体的芯片测试的分治策略算法之前，先来了芯片测试的意思\n<!-- more -->\n## 1.1 一次测试的过程\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200429173027710.png)\n\n如上图，A、B为芯片。测试方法为：将2片芯片（A和B）置于测试台上，互相进行测试，测试报告是“好”或者“坏”，只取其一。\n\n- 假设：好芯片的报告一定是正确的，坏芯片的报告是不确定的（可能会出错）\n\n那么上述测试的结果有四种可能,如下图:\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200429173041111.png)\n\n> 上面的结果应该不难理解\n\n那么现在问题来了:\n\n- 输入：n片芯片，其中好芯片，至少比坏芯片多一片\n- 问题：设计一种测试方法，通过测试从n片中挑出1片好芯片\n- 要求：使用最少的测试次数\n## 1.2 如何测试一块芯片的好坏\n> 针对上述问题，现在先来研究一下，如何在上述n片芯片中，测试出A是好芯片还是坏芯片？\n> - 问题：给定芯片A，判定A的好坏\n> - 方法：用其他n-1片芯片对A进行测试。\n\n假设：n=7:好芯片数>=4\n\n1. A好，6个芯片中至少3个报“好”\n2. A坏，6个芯片中至少4个报坏\n\n所以对于n是奇数情况下：好芯片数>=（n+1）/2\nA好，至少有(n-1)/2个报“好”\nA坏，至少有(n+1)/2个报“坏”\n\n> 结论：\n至少一半报好，A是好芯片\n超过一半报坏，A是坏芯片\n\n假设: n=8:好芯片数>=5\n\n1. A好，7个芯片中至少4个报“好”\n2. A坏，7个芯片中至少5个报“坏”\n\n所以对于n是偶数：好芯片数 >= n/2+1.\nA 好, 至少有 n/2个报告“好”\nA 坏, 至少有 n/2+1个报告“坏”\n\n> 结论：n-1份报告中\n至少一半报好，A是好芯片\n至少一半报坏，A是坏芯片\n\n上面的分析，已经很清晰，我们已经知道如何测试一块芯片的好坏。那么人们最拿手的方法就是：暴力算法（蛮力算法）可以直接写代码了。。。\n\n## 1.3 蛮力算法\n测试算法：任取 1片测试，如果是好芯片，测试结束；如果是坏芯片，抛弃，再从剩下芯片中任取 1片测试，直到得到 1片好芯片\n\n时间估计：\n\n第一片是坏芯片，最多测试n-2次\n第二片是坏芯片，最多测试n-3次\n…\n\n**总计：Θ(n^2 )**\n```cpp\n#include<iostream>\n#include<cmath>\n#include <stdio.h>\n#include <time.h>\n#include <stdlib.h>\n#include <cstring>\n#define MAX 100\nusing namespace std;\n\nint main(){\n    int n;\n    int a[MAX];\n    while(cin>>n){\n        srand(time(NULL));\n        memset(a,0,sizeof(a));\n        for(int i=1;i<=n;i++){   /*芯片编号为数组下标，从1开始*/\n             cin>>a[i];             /*数组值代表芯片好坏，1为真0为假*/\n        }\n        int cnt=0;                  /*查找次数*/\n        for(int i=1;i<=n;i++){\n            int sum=0;\n            for(int j=1;j<=n;j++){\n                cnt++;\n                if(i!=j&&a[i]==1&&a[j]==1)   /*两片芯片都是好的*/\n                    sum++;\n                    if(i!=j&&a[i]==1&&a[j]==0)   /*测试芯片是坏的*/\n                        sum+=rand()%2;\n                    if(i!=j&&a[i]==0&&a[j]==0)   /*两片芯片都是坏的*/\n                        sum+=rand()%2;\n                }\n                if(sum>=n/2){\n                    cout<<\"查找次数：\"<<cnt<<endl;\n                    break;\n                }\n            }\n        }\n        return 0;\n}\n```\n可见时间复杂度之高，数据量一多，肯定会超时。\n\n## 1.4 分治算法设计思想\n在分析分治算法的正确性之前，我们先给出这个算法的描述：\n\n假设n为偶数，将n片芯片两两一组做测试淘汰，剩下芯片构成子问题，进入下一轮分组淘汰。\n\n淘汰规则为：\n\n- “好，好” ==> 任留1片，进入下轮\n- 其他情况 ==> 全部抛弃\n\n**递归截止条件：n<=3**\n3片芯片，一次测试可得到好芯片\n1或者2片芯片，不需要再测试，他们都为好芯片。\n\n上述算法过程就是我们给出的分治策略的设计。那么为什么上述的策略是正确的呢？\n\n回忆一下，前面的文章，要保证分治策略的正确性的基本条件是：子问题与原问题性质相同。下面我们就来证明，上述分治策略的子问题与原问题性质相同。\n\n### 1.41 分治算法的正确性证明\n原问题：n片芯片，其中好芯片，至少比坏芯片多一片\n\n> 那么子问题，命题1：当 n 是偶数时，在上述淘汰规则下，经过一轮淘汰，剩下的好芯片比坏芯片至少多1片\n\n我们需要证明上述子问题的命题1是正确的。\n\n证明：假设原问题中A，B都好的芯片有i组，A与B一好一坏的有j组，A与B都坏的有k组。那么经过一轮淘汰后，好芯片还剩i片，坏芯片还剩k片。\n\n因为\n\n- 初始芯片总数 2i+2j+2k = n\n- 初始好芯片多于坏芯片：2i+j > 2k+j\n\n得出：i>k\n\n所以，剩余的芯片好芯片比坏芯片，至少多1片。命题1 是正确的。即证明了上述分治算法的正确性。\n\n> 当n为奇数时，特殊处理。当n是奇数时，可能会出现问题，如图：\n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200429173514882.png)\n> 可见淘汰后的子问题并不满足于原问题性质相同，此时无法继续测试。\n>- 处理办法是：当n为奇数时，增加一轮对轮空芯片的单独测试，如果该轮空芯片为好芯片则算法结束，如果是坏芯片，则淘汰该芯片。\n\n下面给出上述分治算法的伪码描述：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200429173538122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n补充说明：\n1. 第6点：`if(1好1坏) `，则说明测试的两个至少一个为坏，所以未参加测试的一定为好的\n2. 第7点：由于题目**初始条件**，好的芯片一定比坏的芯片多\n\n\n### 1.42 时间复杂度分析\n设输入规模为n，，每轮淘汰后，芯片数至少减半，测试次数（含轮空处理）：O(n)\n\n时间复杂度：\n\nW(n) = W(n/2) + O(n)\nW(3)=1,W(2)=W(1)=0\n\n解上述方程的得：W(n) = O(n)\n\n> 结果很振奋人心，你已经将一个O(n^2)级别的算法优化为了O(n)O(n)O(n)级别!!!\n\n# 2. 总结\n最大的需要注意的地方就是：如何保证子问题与原问题性质相同:\n可以：\n1. 增加额外处理（比如上述n为奇数时对轮空数据的处理）\n2. 额外处理的工作量，不改变函数的阶\n```cpp\n  #include<iostream>\n  #include <cmath>\n  #include <stdio.h>\n  #include <time.h>\n  #include <stdlib.h>\n  #include <cstring>\n  #define MAX 100\n  using namespace std;\n\n  int main(){\n      int n;\n      int num1,num2,sum;\n      int a[MAX],b[MAX];\n      while(cin>>n){            \n          srand(time(NULL));\n          memset(a,0,sizeof(a));\n          memset(b,0,sizeof(b));\n          /*a数组标记芯片好坏，b数组记录被保留芯片编号*/\n          for(int i=1;i<=n;i++){                    \n              cin>>a[i];\n              b[i]=i;\n          }\n          num1=n;\n          num2=1;\n          sum=0; \n          while(1){\n              /*芯片只剩一片或两片则可以直接得到结果，结束循环*/\n              if(num1<=2)                   \n                  break;\n              else if(num1%2){     /*芯片个数为奇数*/\n                  for(int i=1;i<num1;i+=2){\n                      sum++;            /*记录查找次数*/\n                      if(a[b[i]]==1&&a[b[i+1]]==1)   /*两片芯片都是好的*/\n                          b[num2++]=b[i+rand()%2];\n                      /*两片芯片是坏的，rand模拟结果是好的这一随机现象*/\n                      if(a[b[i]]==0&&a[b[i+1]]==0&&rand()%2)                                               \n                        b[num2++]=b[i+rand()%2];\n                    }\n                    b[num2++]=b[num1];      /*最后一块芯片保留*/\n               }\n               else{                      /*芯片个数为偶数*/\n                   for(int i=1;i<=num1;i+=2){\n                      sum++;\n                      if(a[b[i]]==1&&a[b[i+1]]==1)   /*两片芯片都是好的*/\n                          b[num2++]=b[i+rand()%2];\n                      if(a[b[i]]==0&&a[b[i+1]]==0&&rand()%2)  /*两片芯片是坏的*/\n                         b[num2++]=b[i+rand()%2];\n                    }\n               }\n               num1=num2-1;     /*一次比较后保留芯片的个数*/\n               num2=1;          /*下一次查找的开始位置*/\n          }\n          cout<<\"查找次数：\"<<sum<<endl; \n          cout<<\"找到的芯片编号：\"<<b[1]<<endl; \n      }\n      return 0;\n  }\n```\n\n> 参考链接：https://www.jianshu.com/p/1cec17bfb2d5\n> 参考链接：https://blog.csdn.net/qq_37375427/article/details/102529005\n","tags":["算法","快速幂"],"categories":["mytech"]},{"title":"分治 斐波那契矩阵快速幂","url":"/posts/2601188585/","content":"斐波那契数列通过矩阵快速幂递推关系如下：\n<!-- more -->\n![斐波那契数列](https://img-blog.csdnimg.cn/20200429190211691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200429191850697.png)\n不理解可以计算一遍，验证其正确性\n```cpp\n#include<iostream>\nusing namespace std;\n//定义矩阵结构体，同时定义两个全局变量\nstruct matrix{\n    int m[2][2];\n}ans,base;\n//矩阵的乘法\nmatrix multi(matrix a,matrix b){\n    matrix tmp;\n    for(int i=0;i<2;i++)\n        for(int j=0;j<2;j++){\n            tmp.m[i][j]=0;\n            for(int k=0;k<2;k++)\n                tmp.m[i][j] += a.m[i][k] * b.m[k][j];\n        }\n    return tmp;\n}\nint matrix_pow(int n){\n    // 1 1\n    // 1 0\n    // 基矩阵\n    base.m[0][0] = base.m[0][1] = base.m[1][0] = 1;\n    base.m[1][1] = 0;\n    ans.m[0][0] = ans.m[1][1] = 1;\n    ans.m[0][1] = ans.m[1][0] = 0;\n    while(n){\n        if(n&1){\n            ans = multi(ans,base);\n        }\n        base = multi(base,base);\n        n >>= 1;\n    }\n    return ans.m[1][0];\n}\nint main(){\n    int n;\n    while(cin>>n){\n        cout<<\"第\"<<n<<\"个斐波那契数列的值为：\"<<matrix_pow(n)<<\"\\n\";\n    }\n    return 0;\n}\n```\n代码**正确性**验证如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200429191724734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n\n---\n码字不易，觉得写的可以还请麻烦**关注**一下","tags":["算法","快速幂"],"categories":["mytech"]},{"title":"王小波语录","url":"/posts/3453314697/","content":"\n1. 不愿清醒，宁愿一直沉迷放纵。\n  不知归路，宁愿一世无悔追逐。\n<!-- more -->\n2. 人的一切痛苦，本质上都是对自己的无能的愤怒。\n\n3. 我思故我在，既然我存在，就不能装作不存在。\n  无论如何，我要为自己负起责任。\n\n4. 一个人只有今生今世是不够的。\n  他还应当有诗意的世界。\n\n5. 我的勇气和你的勇气加起来，对付这个世界总够了吧？\n  去向世界发出我们的声音，我一个人是不敢的，有了你，我就敢。\n\n6. 什么样的灵魂就要什么样的养料，越悲怆的时候我越想嬉皮。\n\n7. 你要是愿意，我就永远爱你。\n  你要是不愿意，我就永远相思。\n\n8. 从话语中，你很少能学到人性，从沉默中却能。\n  假如还想学得更多，那就要继续一声不吭。\n\n9. 不管我本人多么平庸，我总觉得对你的爱很美。\n\n10. 深思熟虑的结果往往就是说不清楚。\n\n11. 人在年轻时，最头疼的一件事就是决定自己这一生要做什么。\n\n12. 活下去的诀窍是：保持愚蠢，又不能知道自己有多蠢。\n\n13. 一个人倘若需要从思想中得到快乐，那么他的第一个欲望就是学习。\n\n14. 一想起你，我这张丑脸上就泛起微笑。\n\n15. 我时常回到童年，用一片童心来思考问题，很多烦恼的问题就变得易解。\n\n16. 我对自己的要求很低：我活在世上，无非想要明白些道理，遇见些有趣的事。倘能如我愿，我的一生就算成功。\n\n17. 不相信世界就是这样，在明知道有的时候必须低头，有的人必将失去，有的东西命中注定不能长久的时候，依然要说，在第一千个选择之外，还有第一千零一个可能，有一扇窗等着我打开，然后有光透进来。\n\n18. 人在年轻的时候，觉得到处都是人，别人的事就是你的事，\n   到了中年以后，才觉得世界上除了家人已经一无所有。\n\n19. 人走茶凉伤感吗？不伤感！\n   真正伤感的是：人走了，却把我的茶杯也骗走了。\n\n20. 真实就是无法醒来。不管怎么哭喊怎么大闹，\n   就是无法从那样的梦中清醒过来，这就是现实！\n\n21. 绝望是无限的美好。\n\n22. 只有那些知道自己智慧一文不值的人，才是最有智慧的人。\n\n23. 所有无聊的事情都会衍生出很多细节让你觉得它复杂而有趣，\n\n   投入其中而浑然不知其无聊的本质。\n\n24. 你知道什么是天才的诀窍吗？\n\n    那就是永远只做一件事。\n\n25. 我相信这不是我一个人的经历：傍晚时分，你坐在屋檐下，\n    看着天慢慢的黑下去，心里寂寞而凄凉，感到自己的生命被剥夺了。\n    当时我是个年轻人，但我害怕这样生活下去，衰老下去。\n    在我看来，这是比死亡更可怕的事。\n\n    ​\n    ​\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["读书","生活"],"categories":["mylife"]},{"title":"杀死一只知更鸟摘抄","url":"/posts/2715346686/","content":"\n1. 勇敢是，当你还未开始就已知道自己会输，可你依然要去做，而且无论如何都要把它坚持到底。\n<!-- more -->\n2. 你不可能真正了解谁，除非你进入他的鞋子，陪他走上一段。\n2. 我想让你见识一下什么是真正的勇敢，而不要错误地认为一个人手握枪支就是勇敢 。勇敢是：当你还未开始就已知道自己会输，可你依然要去做，而且无论如何都要把它坚持到底。你很少能赢，但有时也会。\n1. 去掉那些形容词剩下的就是真实了\n1. 我长大了要去当小丑，我对这世上的人除了大笑没什么可做的，干脆我就加入马戏团，笑他个痛快。\n1. 你太年轻，品不出我的话的味道。\n1. 有一种东西不能遵循从众原则，那就是人的良心。\n1. 我伸出舌头接住了一片雪，觉得它很烫。\n1. 追踪猎物时最好要沉着，什么话也不说，他肯定会感到奇怪而走出来的。\n1. 道理很简单，不能因为我们在此之前已经失败了一百年，就认为我们没有理由去争取胜利。\n1. 人之所以要呼吸是不得已，我读书也是这样。\n1. 我说很喜欢，其实是谎话，可是人在某种情况下不得不撒谎，而在无能为力的情况下老得撒谎。\n1. 可是，在这个国家里，有一种方式能够让一切人生来平等——有一种社会机构可以让乞丐平等于洛克菲勒，让蠢人平等于爱因斯坦，让无知的人平等于任何大学的校长。这种机构，先生们，就是法庭。\n1. 我从不喜欢阅读，直到我开始担心我会无法阅读。就像一个人从来不在意呼吸这件事。\n1. 大多数人都是好人，在你终于了解他们以后。\n1. 永远都不要从别人的口中去认识一个人，不要相信流言蜚语。\n1. 直到你亲自去接触他的时候，你才能够看见事实。\n1. 希望读完这本书的你，也能够告诉自己的孩子，要保持敬畏，那种男人对女人的敬畏，文明对自然的敬畏，有权力的人对没有权力的人的敬畏。\n1. 真正的勇敢不是你手握权力和武器，而是你知道什么是正义，并坚持不做不义的事。\n1. 孩子，被人加上有人认为是很难听的称号并不是侮辱。这只说明那个人太可怜了，对你并无损害。\n1. 知更鸟什么坏事都不做，只是衷心的唱歌给我们听，这就是为什么说杀死一只知更鸟就是罪恶。\n1. 我敢保证，在这个法庭上，没有谁没有撒过谎，没有谁没有做过不道德的事情！在这个世界上，没有一个男人不曾带着肉欲瞧过女人。\n1. 但是，在处理好与他人的关系之前，我首先得处理好与自己的关系。大多数人公认的准则是应当遵守的，但如果这样做违背了一个人的良心，就不应当遵守。只有在这种情况下才可以不遵守。\n1. 但是在我能和别人过得去之前，我首先要和自己过得去。有一种东西不能遵循从众原则，那就是人的良心。\n1. 我想让你了解了解她，让你见识见识真正的勇敢是什么，而不要总认为男子手里拿支枪才是勇敢。真正的勇敢是，在行动之前就知道要失败，但还是要行动，不管怎样，要进行到底。你往往失败，但有时候你也能取得胜利。\n1. “一个人没必要把自己懂的东西都展现出来。这不是淑女的做派——再说了，人们不喜欢他们身边有什么人比他们懂得多。这会让他们气不打一处来。你使用的语言再标准，也改变不了他们。除非他们自己想学，否则一点儿办法也没有。你要么闭上嘴巴，要么跟他们说一样的话。”\n1. 你只要明白这一件事，斯科特，你与形形色色的人都会交往得更好。你永远也无法真正理解一个人，直到你用他的眼睛来看世界……直到你钻进他的皮肤，和他一起走路。\n","tags":["读书","生活"],"categories":["mylife"]},{"title":"分治 平面上的最近点对","url":"/posts/3632233996/","content":"\n**分治 平面上的最近点对**\n**题目描述**\n给定平面上n个点，找出其中的一对点的距离，使得在这n个点的所有点对中，该距离为所有点对中最小的。\n<!-- more -->\n**输入格式：**\n多行输入\n第一行：n；2≤n≤200000\n接下来n行：每行两个实数：x y，表示一个点的行坐标和列坐标，中间用一个空格隔开。\n\n**输出格式：**\n仅一行，一个实数，表示最短距离，精确到小数点后面4位。\n\n**输入输出样例\n输入样例#1：**\n```\n10\n1 1\n1 5\n3 1\n5 1\n5 6\n6 7\n7 3\n8 1\n10 3\n9 9\n3\n1 1\n1 2\n2 2\n2\n1 1\n2 2\n```\n**输出样例#1：**\n```\n1.0000\n1.4142\n1.4142\n```\n**说明**\n0<=x,y<=10^9\n\n**题目分析**\n先把点坐标x从小到大排序，然后从中间分开，最短距离有以下两种情况：\n1. 最短距离两点都在同一侧：\n对于这种来说递归的终止时只需计算2-3点的距离，设计这两种情况的递归终止条件即可。\n2. 最短距离两点分别在两侧：\n\t1. 由于我们先递归求得左右两侧的最短距离`minDistance1`和`minDistance2`\n\t2. 求出左右两侧的较短距离`minDistance = min{minDistance1,minDistance2}`;\n\t3. 现在只需要比距离d小的点，这时我们以中间的坐标x为准，对[x-d,x+d]之间的点暴力进行判断，找出最小值就可以得到答案了\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200429230140439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5TW9vbw==,size_16,color_FFFFFF,t_70)\n\n\n\n\n**代码详解**\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstruct node{//定义每个坐标\n\tdouble x,y;\n}a[200010];\nint c[200010];\ndouble cmpy(int t1,int t2)  \n{  \n  return a[t1].y<a[t2].y;  \n}  \nbool cmp(node t1,node t2)\n{\n\treturn t1.x<t2.x;\n}\ndouble dis(node t1,node t2)//计算两点间的距离\n{\n\treturn sqrt((t1.x-t2.x)*(t1.x-t2.x)+(t1.y-t2.y)*(t1.y-t2.y));\n}\ndouble min(double t1,double t2)//返回较小数值\n{\n\treturn t1<t2?t1:t2;\n}\ndouble find(int left,int right)\n{\n\tif(left+1==right)//如果只有两个点，则直接返回两点距离\n\t\treturn dis(a[left],a[right]);\n\tif(left+2==right)//如果只有三个点，则求这三个点相距的最小距离\n\t\treturn min(dis(a[left],a[right]),min(dis(a[left],a[left+1]),dis(a[left+1],a[right])));\n\tint mid=(left+right)>>1;//求中点\n\tdouble ans=min(find(left,mid),find(mid+1,right));  //将平面一分为二\n    int i,j,cnt=0;  \n    //------------------------核心代码-------------\n    //有可能最小值的点位于分界直线两边，计算位于分界直线两边的点\n    for(i=left;i<=right;i++)//将点坐标 x 到中间点坐标 a[mid] 的距离小于ans的值保存进数组c\n\t\tif(abs(a[mid].x-a[i].x)<ans)  \n\t\t\tc[cnt++]=i;  \n\tsort(c,c+cnt,cmpy);//将点坐标按 y 从小到大排序 \n    for(i=0;i<cnt;i++) //比较数组c内两点距离找最小值（暴力，因为此时数据范围很小）\n\t\tfor(j=i+1;j<cnt;j++)  \n\t\t{  \n            //y坐标升序排列，有j>i所以差值肯定为正，故不需要绝对值\n\t\t\tif(a[c[j]].y-a[c[i]].y>ans)//如果y相差已经大于ans，则算上x肯定大于ans\n\t\t\t\tbreak;  \n\t\t\tans=min(ans,dis(a[c[i]],a[c[j]]));//求出最小值了\n\t\t}\n    return ans;\n}\nint main()\n{\n\tint n,i;\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\twhile(cin>>n)\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t\tcin>>a[i].x>>a[i].y;\n\t\tstd::sort(a,a+n,cmp);\n\t\tprintf(\"%.4lf\\n\",find(0,n-1));\n\t}\n\treturn 0;\n}\n```\n---\n代码思路，编辑格式不易，大家觉得还可以可以**点赞**、**收藏**、**关注**一下吧！","tags":["算法","分治"],"categories":["mytech"]},{"title":"高精度","url":"/posts/1237449692/","content":"\n\n[TOC]\n\n## 高精度\n\n### 高精度加法\n<!-- more -->\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nint a[10000],b[100000],c[100000],la,lb,lc;\n//1.字符串读入\n//2.字符串转数组\n//3.竖式加法\n//4.消前导0\n//5.倒序输出\nint main(){\n    cin>>x>>y;\n    la = x.length();\n    lb = y.length();\n    for(int i=0;i<la;i++){\n        a[la-i]=x[i]-'0';\n    }\n    for(int i=0;i<lb;i++){\n        b[lb-i]=y[i]-'0';\n    }\n    lc = max(la,lb);\n    for(int i=1;i<=lc;i++){\n        c[i]+=a[i]+b[i];\n        c[i+1] = c[i]/10;\n        c[i] %= 10;\n    }\n    if(c[lc+1]>0) lc++;\n    for(int i=lc;i>=1;i--)\n        cout<<c[i];\n}\n```\n\n### 高精度减法\n\n```c++\n#include<iostream>\nusing namespace std;\nstring x,y;\nint a[100005],b[100005],c[100005],la,lb;\nint main(){\n    cin>>x>>y;\n    la = x.length();\n    lb = y.length();\n    if(la<lb||la==lb&&x<y){\n        swap(x,y);\n        swap(la,lb);\n        cout<<'-';\n    }\n    for(int i=0;i<la;i++)\n        a[la-i] = x[i] - '0';\n    \n    for(int i=0;i<lb;i++)\n        b[lb-i] = y[i] - '0';\n    \n    for(int i=1;i<=la;i++){\n        if(a[i]<b[i]){\n            a[i]+=10;\n            a[i+1]--;\n        }\n        c[i]=a[i]-b[i];\n    }\n    while(c[la]==0&&la>1)\n        la--;\n    for(int i=la;i>=1;i--)\n        cout<<c[i];\n    return 0;\n}\n```\n\n### 高精度乘法\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nstring x,y;\nint a[100005],b[100005],c[100005],la,lb,lc;\nint main(){\n    cin>>x>>y;\n    la = x.length();\n    lb = y.length();\n    for(int i=0;i<la;i++){\n        a[la-i]=x[i]-'0';\n    }\n    for(int i=0;i<lb;i++){\n        b[lb-i]=y[i]-'0';\n    }\n    for(int i=1;i<=la;i++){\n        for(int j=1;j<=lb;j++){\n\t\t\tc[i+j-1] += a[i]*b[j];\n\t\t\tc[i+j] += c[i+j-1] / 10;\n\t\t\tc[i+j-1] %= 10;\n        }\n    }\n    lc = la+lb;\n    while(c[lc]==0&&lc>1){\n        lc--;\n    }\n    for(int i=lc;i>=1;i--){\n        cout<<c[i];\n    }\n    return 0;\n}\n```\n\n### 高精度斐波那契数列\n\n```c++\n#include<bis/stdc++.h>\nusing namespace std;\nconst int Maxn = 5005;\nint a[Maxn],b[Maxn],c[Maxn],lc=1;//lc的初始化是由于题目中a[1]b[1]都为1位数\nint main(){\n    a[1]=1;\n    b[1]=2;\n    int n;\n    cin>>n;\n    for(i=2;i<=n;i++){\n        //c=a+b;\n        memset(c,0,sizeof(c));//c[]为全局变量，每次计算需要重新置零\n        for(int j=1;j<=lc;j++){\n            c[j]+=a[j]+b[j];\n            c[j+1]+=c[j]/10;\n            c[j]%=10;\n        }\n        //注意这里每一次相加最多会向前加一位，由于有多次相加，所以lc会一直++\n        if(c[lc+1]>0)lc++;\n        //a=b;\n        for(int j=1;j<=lc;j++)a[j]=b[j];\n        //b=c;\n        for(int j=1;j<=lc;j++)b[j]=c[j];\n    }\n    //cout>>c;\n    for(int i=lc;i>=1;i--){\n        cout<<c[i];\n    }\n    return 0;\n}\n```\n\n### B进制星球\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nstring x,y;\nint a[100005],b[100005],c[100005],la,lb,lc;\nint main(){\n    cin>>n>>x>>y;\n    la = x.length;\n    lb = y.length;\n    for(int i=0;i<la;i++){\n        if(x[i]>='A')\n            a[la-i]=x[i]-'A'+10;\n        else\n        \ta[la-i]=x[i]-'0';\n    }\n    for(int i=0;i<lb;i++){\n        if(y[i]>='A')\n            b[lb-i]=y[i]-'A'+10;\n        else\n        \tb[lb-i]=y[i]-'0';\n    }\n    lc = max(la,lb);\n    for(int i=1;i<=lc;i++){\n        c[i]+=a[i]+b[i];\n        //c[i+1]+=c[i]/10;\n        c[i+1]+=c[i]/n;\n        //c[i]%=10;\n        c[i]%=n;\n    }\n    if(c[lc+1]>0)lc++;\n    for(int i=lc;i>=1;i--){\n        if(c[i]>=10)\n            cout>>char(c[i]-10+'A');\n        else\n        \tcout>>c[i];\n    }\n    return 0;\n}\n```\n\n## ","tags":["算法","高精度"],"categories":["mytech"]}]